diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/configure.ac enigma2-nightly.patched/configure.ac
--- enigma2-nightly.org/configure.ac	2011-09-03 18:23:23.590021783 +0200
+++ enigma2-nightly.patched/configure.ac	2011-09-03 18:23:47.060032502 +0200
@@ -33,6 +34,26 @@
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 
+AC_ARG_ENABLE([tf7700],
+        [AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-tf7700]))
+        [case "${enableval}" in
+                yes) enable_tf7700=true ;;
+                no) enable_tf7700=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+        [AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-cuberevo]))
+        [case "${enableval}" in
+                yes) enable_cuberevo=true ;;
+                no) enable_cuberevo=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
 AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
 AC_SUBST(LIBDL_LIBS)
 AC_CHECK_LIB([jpeg], [jpeg_set_defaults], [LIBJPEG_LIBS="-ljpeg"], [AC_MSG_ERROR([Could not find libjpeg])])
@@ -135,9 +155,6 @@
 lib/python/Components/Sources/Makefile
 lib/python/Screens/Makefile
 lib/python/Plugins/Makefile
-lib/python/Plugins/DemoPlugins/Makefile
-lib/python/Plugins/DemoPlugins/TPMDemo/Makefile
-lib/python/Plugins/DemoPlugins/TestPlugin/Makefile
 lib/python/Plugins/Extensions/CutListEditor/Makefile
 lib/python/Plugins/Extensions/CutListEditor/meta/Makefile
 lib/python/Plugins/Extensions/DVDBurn/Makefile
@@ -152,15 +169,12 @@
 lib/python/Plugins/Extensions/MediaPlayer/meta/Makefile
 lib/python/Plugins/Extensions/MediaScanner/Makefile
 lib/python/Plugins/Extensions/MediaScanner/meta/Makefile
-lib/python/Plugins/Extensions/Modem/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/meta/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
 lib/python/Plugins/Extensions/SocketMMI/Makefile
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/meta/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
@@ -200,6 +214,12 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile 
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 lib/service/Makefile
 lib/components/Makefile
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/include/shmE2.h enigma2-nightly.patched/include/shmE2.h
--- enigma2-nightly.org/include/shmE2.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/include/shmE2.h	2011-09-03 18:23:47.060032502 +0200
@@ -0,0 +1,337 @@
+#ifndef SHME2
+#define SHME2
+
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+#define SHMSZ 27
+#define KEY 1234
+
+static char* createshm()
+{
+	int shmid;
+	key_t key = KEY;
+	char *shm = NULL;
+
+	if((shmid = shmget(key, SHMSZ, IPC_CREAT | 0666)) < 0) {
+		return NULL;
+	}
+
+	shm = (char *) shmat(shmid, NULL, 0);
+	if(shm == (char *) -1)
+		return NULL;
+
+	*shm = '\0';
+
+	return shm;
+}
+
+static char* findshm()
+{
+	int shmid;
+	key_t key = KEY;
+	char *shm = NULL;
+
+	if((shmid = shmget(key, SHMSZ, 0666)) < 0) {
+		return NULL;
+	}
+
+	shm = (char *) shmat(shmid, NULL, 0);
+	if(shm == (char *) -1)
+		return NULL;
+
+	return shm;
+}
+
+static int delshmentry(char *shm, char *key)
+{
+	if(shm == NULL) return -1;
+	char *vbuf = NULL, *shmbuf = NULL;
+	char *v, *s = shm;
+	int matchkey = 0;
+	int ret = 0;
+
+	vbuf = (char *) malloc(256);
+	if(vbuf == NULL)
+		return -1;
+	v = vbuf;
+	memset(vbuf, '\0', 256);
+
+	//FIXME: here we can have a segfault
+	shmbuf = (char *) malloc(4096);
+	if(shmbuf == NULL)
+	{
+		free(vbuf);
+		return -1;
+	}
+	memset(shmbuf, '\0', 4096);
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, vbuf) == 0)
+		{
+			matchkey = 1;
+			ret = 1;
+		}
+		if(matchkey == 0 && *s == ';')
+		{
+			*v++ = ';';
+			*v = '\0';
+			strcat(shmbuf, vbuf);
+			v = vbuf;
+			s++;
+		}
+		if(matchkey == 1 && *s == ';')
+		{
+			matchkey = 0;
+			v = vbuf;
+			s++;
+		}
+	}
+	if(matchkey == 0)
+	{
+		*v++ = ';';
+		*v = '\0';
+		strcat(shmbuf, vbuf);
+		v = vbuf;
+	}
+	shmbuf[strlen(shmbuf)-1] = '\0';
+	*shm = '\0';
+	strcpy(shm, shmbuf);
+
+	free(vbuf);
+	free(shmbuf);
+
+	return ret;
+}
+
+static int setshmentry(char *shm, char *entry)
+{
+	if(shm == NULL) return -1;
+	char *buf = NULL;
+	char *c = NULL;
+	int pos = 0;
+
+	if(strlen(entry) > 255)
+		return -1;
+
+	buf = (char *) malloc(256);
+	if(buf == NULL)
+		return -1;
+	memset(buf, '\0', 256);
+
+	c = strchr(entry, '=');
+	if(c != NULL)
+		pos = (c - entry) + 1;
+	else
+	{
+		free(buf);
+		return -1;
+	}
+
+	strncpy(buf, entry, pos);
+	buf[pos] = '\0';
+
+	if(delshmentry(shm, buf) < 0)
+	{
+		free(buf);
+		return -1;
+	}
+
+	if(*shm != '\0')
+		strcat(shm, ";");
+	strcat(shm, entry);
+
+	free(buf);
+	return 1;
+}
+
+static int getshmentry(char *shm, char *key, char *buf, int buflen)
+{
+	if(shm == NULL) return -1;
+	char *v, *s = shm, *shmbuf;
+	int matchkey = 0;
+	int ret = 0;
+
+	shmbuf = (char *) malloc(256);
+	if(shmbuf == NULL)
+		return -1;
+	memset(shmbuf, '\0', 256);
+
+	v = shmbuf;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, shmbuf) == 0)
+		{
+			v = shmbuf;
+			matchkey = 1;
+			ret = 1;
+		}
+		if(matchkey == 0 && *s == ';')
+		{
+			v = shmbuf;
+			s++;
+		}
+		if(matchkey == 1 && *s == ';')
+		break;
+	}
+	if(matchkey == 0)
+	v = shmbuf;
+	*v = '\0';
+
+	strncpy(buf, shmbuf, buflen-1);
+	buf[buflen] = '\0';
+	free(shmbuf);
+
+	return ret;
+}
+
+static int checkshmentry(char *shm, char *key)
+{
+	if(shm == NULL) return -1;
+	char *v = NULL, *s = shm, *shmbuf = NULL;
+	int ret = 0;
+
+	shmbuf = (char *) malloc(256);
+	if(shmbuf == NULL)
+		return -1;
+	memset(shmbuf, '\0', 256);
+
+	v = shmbuf;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		if(strcmp(key, shmbuf) == 0)
+		{
+			ret = 1;
+			break;
+		}
+		if(*s == ';')
+		{
+			v = shmbuf;
+			s++;
+		}
+	}
+	free(shmbuf);
+	return ret;
+}
+
+static int getshmentryall(char *shm, char *shmbuf, int buflen)
+{
+	if(shm == NULL) return -1;
+	char *v = shmbuf, *s = shm;
+	int count = 0;
+
+	while(*s != '\0')
+	{
+		*v++ = *s++;
+		*v = '\0';
+		count++;
+		if(*s == ';')
+		{
+			if(count >= buflen-1)
+				break;
+			s++;
+			*v++ = '\n';
+			count++;
+                }
+		if(count >= buflen-1)
+			break;
+	}
+	*v = '\0';
+
+	return 0;
+}
+
+static int incshmentry(char *shm, char *entry)
+{
+	if(shm == NULL) return -1;
+	char *buf = NULL;
+	char *pch;
+	int value;
+	
+	if(strlen(entry) > 255)
+		return -1;
+
+	buf = (char *) malloc(256);
+	if(buf == NULL)
+		return -1;
+	memset(buf, '\0', 256);
+	
+	getshmentry(shm, entry, buf, 256);
+		
+	if(strlen(buf) == 0) {
+		sprintf(buf, "%s%d", entry, 1);
+		if(setshmentry(shm, buf) != 1) {
+			free(buf);
+			return 0;
+		}
+		free(buf);
+		return 1;
+	}
+		
+	pch = strtok(buf, "=");
+	if(pch != NULL) {
+		value = atoi(pch);
+		value++;
+		sprintf(buf, "%s%d", entry, value);
+		if(setshmentry(shm, buf) != 1) {
+			free(buf);
+			return 0;
+		}
+	}
+		
+	free(buf);
+	return 1;
+}
+	
+static int decshmentry(char *shm, char *entry)
+{
+	if(shm == NULL) return -1;
+	char *buf = NULL;
+	char *pch;
+	int value;
+	
+	if(strlen(entry) > 255)
+		return -1;
+
+	buf = (char *) malloc(256);
+	if(buf == NULL)
+		return -1;
+	memset(buf, '\0', 256);
+
+	getshmentry(shm, entry, buf, 256);
+		
+	if(strlen(buf) == 0) {
+		free(buf);
+		return 1;
+	}
+			
+	pch = strtok(buf, "=");
+	if(pch != NULL) {
+		value = atoi(pch);
+		value--;
+		if(value < 1) {
+			delshmentry(shm, entry);
+			free(buf);
+			return 1;
+		}
+		sprintf(buf, "%s%d", entry, value);
+		if(setshmentry(shm, buf) != 1) {
+			free(buf);
+			return 0;
+		}
+	}
+
+	free(buf);
+	return 1;
+}
+
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/etpm.cpp enigma2-nightly.patched/lib/base/etpm.cpp
--- enigma2-nightly.org/lib/base/etpm.cpp	2011-09-03 18:23:24.860021777 +0200
+++ enigma2-nightly.patched/lib/base/etpm.cpp	2011-09-03 18:23:47.070032973 +0200
@@ -6,14 +6,17 @@
 #include <string.h>
 #include <sys/un.h>
 #include <unistd.h>
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 #include <openssl/bn.h>
 #include <openssl/sha.h>
+#endif
 #include <lib/base/eerror.h>
 
 #include "etpm.h"
 
 eTPM::eTPM()
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	struct sockaddr_un addr;
 	unsigned char buf[8];
 	unsigned int tag;
@@ -53,6 +56,7 @@
 
 	parse_data(val, len);
 	free(val);
+#endif
 }
 
 eTPM::~eTPM()
@@ -62,6 +66,7 @@
 
 bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[len + 4];
 
 	buf[0] = (cmd >> 8) & 0xff;
@@ -76,11 +81,13 @@
 		return false;
 	}
 
+#endif
 	return true;
 }
 
 void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[4];
 	void *val;
 
@@ -110,10 +117,14 @@
 	}
 
 	return val;
+#else
+	return NULL;
+#endif
 }
 
 void eTPM::parse_data(const unsigned char *data, size_t datalen)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned int i;
 	unsigned int tag;
 	unsigned int len;
@@ -139,19 +150,23 @@
 			break;
 		}
 	}
+#endif
 }
 
 std::string eTPM::getCert(cert_type type)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (type == TPMD_DT_LEVEL2_CERT && level2_cert_read)
 		return std::string((char*)level2_cert, 210);
 	else if (type == TPMD_DT_LEVEL3_CERT && level3_cert_read)
 		return std::string((char*)level3_cert, 210);
+#endif
 	return "";
 }
 
 std::string eTPM::challenge(std::string rnd)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (rnd.length() == 8)
 	{
 		if (!send_cmd(TPMD_CMD_COMPUTE_SIGNATURE, rnd.c_str(), 8))
@@ -168,5 +183,6 @@
 		free(val);
 		return ret;
 	}
+#endif
 	return "";
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/filepush.cpp enigma2-nightly.patched/lib/base/filepush.cpp
--- enigma2-nightly.org/lib/base/filepush.cpp	2011-09-03 18:23:24.870021998 +0200
+++ enigma2-nightly.patched/lib/base/filepush.cpp	2011-09-03 18:23:47.070032973 +0200
@@ -4,6 +4,21 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) // this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+
+#define USBDEVICE_SUPER_MAGIC 0x9fa2 
+#define EXT2_SUPER_MAGIC      0xEF53 
+#define EXT3_SUPER_MAGIC      0xEF53 
+#define SMB_SUPER_MAGIC       0x517B 
+#define NFS_SUPER_MAGIC       0x6969 
+#define MSDOS_SUPER_MAGIC     0x4d44            /* MD */
+#endif
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly
+#include "include/shmE2.h"
+extern char *shm;
+#endif
+
 #define PVR_COMMIT 1
 
 //FILE *f = fopen("/log.ts", "wb");
@@ -19,6 +34,15 @@
 	flush();
 	enablePVRCommit(0);
 	CONNECT(m_messagepump.recv_msg, eFilePushThread::recvEvent);
+
+// vvv Initialize with 0, because otherwise playback may stop
+// (In case of playback eFilePushThread::start is not called)		
+#if defined(__sh__)
+	m_record_split_size = 0;
+	m_record_split_type = 0;
+#endif
+// ^^^ Initialize with 0, because otherwise playback may stop
+
 }
 
 static void signal_handler(int x)
@@ -37,6 +61,11 @@
 	
 	size_t written_since_last_sync = 0;
 
+#if defined(__sh__) // used for filesplitting
+	int file_count = 1;
+	unsigned long long total_bytes_written = 0;
+#endif
+
 	eDebug("FILEPUSH THREAD START");
 	
 		/* we set the signal to not restart syscalls, so we can detect our signal. */
@@ -47,7 +76,16 @@
 	
 	hasStarted();
 
+#if defined(__sh__) // opens video device for the reverse playback workaround
+//Changes in this file are cause e2 doesnt tell the player to play reverse
+//No idea how this is handeld in dm drivers
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+#endif
 		/* m_stop must be evaluated after each syscall. */
+		
+// vvv Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+	bool already_empty=false;
+// ^^^ Fix to ensure that event evtEOF is called at end of playbackl part 1/3
 	while (!m_stop)
 	{
 			/* first try flushing the bufptr */
@@ -124,6 +162,37 @@
 				dest_pos -= toflush;
 				posix_fadvise(m_fd_dest, dest_pos, toflush, POSIX_FADV_DONTNEED);
 				written_since_last_sync -= toflush;
+#if defined(__sh__) // splits files
+				//split file only after sync
+				if (m_record_split_size)
+				{
+					total_bytes_written += toflush;
+					if(total_bytes_written > m_record_split_size)
+					{
+						char filename[255];
+
+						close(m_fd_dest);
+						total_bytes_written = 0;
+						written_since_last_sync = 0;
+
+						if(m_record_split_type)
+							snprintf(filename, 255, "%s.%03d.ts", m_filename, file_count++);
+						else
+							snprintf(filename, 255, "%s.%03d", m_filename, file_count++);
+
+						eDebug("split record file - Recording to %s...", filename);
+
+						m_fd_dest = open(filename, m_flags, 0644);
+						if (m_fd_dest == -1)
+						{
+							eDebug("split record file - can't open recording file!");
+						}
+
+						/* turn off kernel caching strategies */
+						posix_fadvise(m_fd_dest, 0, 0, POSIX_FADV_RANDOM);
+					}
+				}
+#endif
 			}
 
 //			printf("FILEPUSH: wrote %d bytes\n", w);
@@ -135,6 +204,19 @@
 			
 		if (m_sg && !current_span_remaining)
 		{
+#if defined (__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o',  84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+				//eDebug("VIDEO_DISCONTINUITY (fd %d, rc %d)", fd_video, rc);
+			}
+#endif
 			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 			m_current_position = current_span_offset;
@@ -187,7 +269,17 @@
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
-						continue;
+// vvv Fix to ensure that event evtEOF is called at end of playbackl part 2/3
+						if(already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty=true;
+							continue;
+						}
+// ^^^ Fix to ensure that event evtEOF is called at end of playbackl	part 2/3
 					case 1:
 						eDebug("wait for driver eof ok");
 						break;
@@ -212,6 +304,9 @@
 			break;
 		} else
 		{
+// vvv Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+			already_empty=false;
+// ^^^ Fix to ensure that event evtEOF is called at end of playbackl part 3/3
 			m_current_position += m_buf_end;
 			bytes_read += m_buf_end;
 			if (m_sg)
@@ -219,11 +314,76 @@
 		}
 //		printf("FILEPUSH: read %d bytes\n", m_buf_end);
 	}
-	fdatasync(m_fd_dest);
+	// Do NOT call "fdatasync(m_fd_dest);" here because on some systems it doesn't return
+	// and freezes the whole box.
+	// Calling this function here is not that important, anyway, because the initiator closes
+	// m_fd_dest immediatedly when the filepush thread has been stopped.
+	// Original code has been:	
+	// fdatasync(m_fd_dest);
+
+#if defined(__sh__) // closes video device for the reverse playback workaround
+	close(fd_video);
+#endif
 
 	eDebug("FILEPUSH THREAD STOP");
 }
 
+#if defined(__sh__) // here we prioritise and split the files
+void eFilePushThread::start(int fd, int fd_dest, const char *filename)
+{
+	struct statfs sbuf;
+	eRawFile *f = new eRawFile();
+	ePtr<iTsSource> source = f;
+	f->setfd(fd);
+	start(source, fd_dest);
+	m_record_split_size = 0;
+	m_record_split_type = 0;
+	m_flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+
+//FIXME: (schischu) This should be changed, 
+//such values should come for e2 and not from an external source
+	char record_split_size[3] = "";
+	getshmentry(shm, "record_split_size=", record_split_size, 3);
+	m_record_split_size = atoi(record_split_size);
+	m_record_split_size = m_record_split_size * 1000 * 1000 * 1000;
+	
+	char record_split_type[2] = "";
+	getshmentry(shm, "record_split_type=", record_split_type, 2);
+	m_record_split_type = atoi(record_split_type);
+
+	m_filename[0] = NULL;
+	strcpy(m_filename, filename);
+
+	if (statfs(m_filename, &sbuf) < 0)
+	{
+		eDebug("split record file - can't get fs type assuming none NFS!");
+	} else
+	{
+		if (sbuf.f_type == EXT3_SUPER_MAGIC)
+			eDebug("split record file - Ext2/3/4 Filesystem\n");
+		else
+		if (sbuf.f_type == NFS_SUPER_MAGIC)
+		{
+			eDebug("split record file - NFS Filesystem; add O_DIRECT to flags\n");
+			m_flags |= O_DIRECT;
+		}
+		else
+		if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+			eDebug("split record file - USB Device\n");
+		else
+		if (sbuf.f_type == SMB_SUPER_MAGIC)
+			eDebug("split record file - SMBs Device\n");
+		else
+		if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+			eDebug("split record file - MSDOS Device\n");
+	}
+
+	resume();
+}
+#endif
+
+
+
 void eFilePushThread::start(int fd, int fd_dest)
 {
 	eRawFile *f = new eRawFile();
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/filepush.h enigma2-nightly.patched/lib/base/filepush.h
--- enigma2-nightly.org/lib/base/filepush.h	2011-09-03 18:23:24.870021998 +0200
+++ enigma2-nightly.patched/lib/base/filepush.h	2011-09-03 18:23:47.090033672 +0200
@@ -13,6 +13,11 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	//No idea how this is handeld in dm drivers
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
@@ -23,6 +28,9 @@
 	void thread();
 	void stop();
 	void start(int sourcefd, int destfd);
+#if defined(__sh__) // our own thread to prioritise and split the files
+	void start(int sourcefd, int destfd, const char *filename);
+#endif
 	int start(const char *filename, int destfd);
 
 	void start(ePtr<iTsSource> &source, int destfd);
@@ -52,7 +60,16 @@
 private:
 	iFilePushScatterGather *m_sg;
 	int m_stop;
+#if defined(__sh__) // has something todo with splitting files
+	// align buffer to standard blocksize of 188
+	unsigned char m_buffer[348*188];
+	unsigned long long m_record_split_size;
+	int m_record_split_type;
+	char m_filename[256];
+	int m_flags;
+#else
 	unsigned char m_buffer[65536];
+#endif
 	int m_buf_start, m_buf_end, m_filter_end;
 	int m_fd_dest;
 	int m_send_pvr_commit;
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/ioprio.cpp enigma2-nightly.patched/lib/base/ioprio.cpp
--- enigma2-nightly.org/lib/base/ioprio.cpp	2011-09-03 18:23:24.880022438 +0200
+++ enigma2-nightly.patched/lib/base/ioprio.cpp	2011-09-03 18:23:47.090033672 +0200
@@ -28,6 +28,9 @@
 	#elif defined(__mips__)
 		#define __NR_ioprio_set		4284
 		#define __NR_ioprio_get		4285
+	#elif defined(__sh__) // the correct values for our kernel
+		#define __NR_ioprio_set         288 
+		#define __NR_ioprio_get         289 
 	#else
 		#error "Unsupported arch"
 	#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/base/object.h enigma2-nightly.patched/lib/base/object.h
--- enigma2-nightly.org/lib/base/object.h	2011-09-03 18:23:24.910022698 +0200
+++ enigma2-nightly.patched/lib/base/object.h	2011-09-03 18:23:47.100033173 +0200
@@ -169,6 +169,50 @@
 				if (!ref) \
 					delete this; \
 			}
+	#elif defined(__sh__) // refcounting asm code for sh4 cpus
+		#define DECLARE_REF(x)                  \
+			private: oRefCount ref;         \
+			public: void AddRef();          \
+					void Release();
+		#define DEFINE_REF(c) \
+			void c::AddRef() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+       				asm volatile( \
+                		"   .align 2              \n\t" \
+                		"   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+                		"   mov    #-6,   r15     \n\t" \
+                		"   mov.l  @%1,   %0      \n\t" \
+                		"   add     #1,   %0      \n\t" \
+                		"   mov.l   %0,   @%1     \n\t" \
+                		"1: mov     r1,   r15     \n\t" \
+                		: "=&r" (tmp),      \
+                  		  "+r"  (v) \
+				:                   \
+                		: "memory" , "r0", "r1" ); \
+			} \
+			void c::Release() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+			        asm volatile( \
+                		"   .align 2              \n\t" \
+		                "   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+ 		                "   mov    #-6,   r15     \n\t" \
+		                "   mov.l  @%1,   %0      \n\t" \
+		                "   add    #-1,   %0      \n\t" \
+		                "   mov.l   %0,   @%1     \n\t" \
+		                "1: mov     r1,   r15     \n\t" \
+		                : "=&r" (tmp),      \
+		                  "+r"  (v) \
+				:                   \
+		                : "memory" , "r0", "r1" ); \
+				if (!ref) \
+					delete this; \
+			}
 	#else
 		#warning use non optimized implementation of refcounting.
 		#define DECLARE_REF(x) 			\
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/Makefile.am enigma2-nightly.patched/lib/driver/Makefile.am
--- enigma2-nightly.org/lib/driver/Makefile.am	2011-09-03 18:23:24.950022197 +0200
+++ enigma2-nightly.patched/lib/driver/Makefile.am	2011-09-03 18:23:47.100033173 +0200
@@ -16,7 +16,8 @@
 	rc.cpp \
 	rcconsole.cpp \
 	rcinput.cpp \
-	rfmod.cpp
+	rfmod.cpp \
+	vfd.cpp
 
 driverincludedir = $(pkgincludedir)/lib/driver
 driverinclude_HEADERS = \
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/rc.cpp enigma2-nightly.patched/lib/driver/rc.cpp
--- enigma2-nightly.org/lib/driver/rc.cpp	2011-09-03 18:23:24.980022362 +0200
+++ enigma2-nightly.patched/lib/driver/rc.cpp	2011-09-03 18:23:47.110032823 +0200
@@ -10,6 +10,11 @@
 #include <lib/base/init_num.h>
 #include <lib/base/eerror.h>
 
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly. here rc blocking
+#include "include/shmE2.h"
+extern char *shm;
+#endif
+
 /*
  *  note on the enigma input layer:
  *  the enigma input layer (rc*) supports n different devices which
@@ -64,6 +69,10 @@
 	{
 		if (read(handle, &rccode, 2)!=2)
 			break;
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly. here rc blocking
+		if(checkshmentry(shm, "stopRC=") == 1)
+			continue;
+#endif
 		if (enabled && !input->islocked())
 			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
 				(*i)->handleCode(rccode);
@@ -97,6 +106,10 @@
 	{
 		if (read(handle, &ev, sizeof(struct input_event))!=sizeof(struct input_event))
 			break;
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly. here rc blocking
+		if(checkshmentry(shm, "stopRC=") == 1)
+			continue;
+#endif
 		if (enabled && !input->islocked())
 			for (std::list<eRCDevice*>::iterator i(listeners.begin()); i!=listeners.end(); ++i)
 				(*i)->handleCode((long)&ev);
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/vfd.cpp enigma2-nightly.patched/lib/driver/vfd.cpp
--- enigma2-nightly.org/lib/driver/vfd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/driver/vfd.cpp	2011-09-03 18:23:47.110032823 +0200
@@ -0,0 +1,399 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h> 
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../misc/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF	0xc0425a0a
+#define	VFDDISPLAYCHARS 	0xc0425a00
+#define VFDBRIGHTNESS           0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF    0xc0425a05
+
+bool startloop_running = false;
+static bool icon_onoff[32];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+char chars[64];
+
+
+struct vfd_ioctl_data {
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);	
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if(fd < 0)
+		return 0;
+
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if(n < 0)
+		n = 0;
+	else if((n > 1) && (progress[n-1] == 0xa))
+		n--;
+
+	progress[n] = 0;
+
+	return progress;
+}
+
+#define MAX_CHARS 8
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+
+	if((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n",
+					fplarge, fpsmall, fpc);
+		return NULL;
+	}
+
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+	
+	// display string
+	char str[] = "        AAF DEV-TEAM ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while(!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if(index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for(i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if((index % 4) == 0)
+		{
+		  // display progress
+		  progress = getProgress();
+		  write(fpsmall, progress, strlen(progress) + 1);
+		  if(strncmp("100", progress, 3) == 0)
+		    break;
+		}
+	}
+
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+
+#else
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string("AAF DEV-TEAM", true);
+	//run 2 times through all icons 
+	for  (int vloop = 0; vloop < 128; vloop++) {
+		/*if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);*/
+		if (vloop%2 == 1) {
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+	
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);	
+	}
+
+	blocked = false;
+	return NULL;
+}
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	memset ( chars, ' ', 63 );
+	memcpy ( chars, str, i);	
+
+#ifdef PLATFORM_TF7700
+
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked) usleep(200000);
+
+	{
+#else
+	if (!blocked || force) {
+#endif
+		struct vfd_ioctl_data data;
+		memset ( data.data, ' ', 63 );
+		memcpy ( data.data, str, i );	
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text) {
+	if (!blocked) {
+		int i, len = strlen(text);
+		char* out = (char *) malloc(16);
+
+		for (i=0; i<=(len-16); i++) { // scroll text till end
+			memset(out, ' ', 16);
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++) { // scroll text with whitespaces from right
+			memset(out, ' ', 16);
+			memcpy(out, text+len+i-16, 16-i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+
+	if (!blocked || force) {
+		struct vfd_ioctl_data data;
+
+		if (!startloop_running) {
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+    			data.data[0] = id;
+    			data.data[4] = onoff;
+    			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+    			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd_set_icon((tvfd_icon)id, false);	
+	}
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+
+	return;
+}
+
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+    	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+
+    	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
+
+void evfd::vfd_set_fan(bool onoff)
+{
+#if defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD)
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+    	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+
+    ioctl(file_vfd, 0xc0425af8, &data);
+
+	close (file_vfd);
+#endif
+
+	return;
+}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/driver/vfd.h enigma2-nightly.patched/lib/driver/vfd.h
--- enigma2-nightly.org/lib/driver/vfd.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/driver/vfd.h	2011-09-03 18:23:47.120032982 +0200
@@ -0,0 +1,41 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+    void vfd_set_fan(bool onoff);
+};
+
+
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/decoder.cpp enigma2-nightly.patched/lib/dvb/decoder.cpp
--- enigma2-nightly.org/lib/dvb/decoder.cpp	2011-09-03 18:23:25.050021898 +0200
+++ enigma2-nightly.patched/lib/dvb/decoder.cpp	2011-09-03 18:23:47.120032982 +0200
@@ -166,7 +166,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -174,6 +178,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -181,6 +187,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
+
 	int bypass = 0;
 
 	switch (type)
@@ -213,7 +221,10 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -439,7 +450,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -447,6 +462,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -455,6 +471,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -753,7 +770,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -761,6 +782,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -768,6 +790,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 #endif
@@ -813,7 +836,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -822,6 +849,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -829,6 +857,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -1022,12 +1051,30 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__)  // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif 
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__) 
+/* 
+the VIDEO_CONTINUE would reset the FASTFORWARD  command so we 
+execute the FASTFORWARD after the VIDEO_CONTINUE
+*/ 
+			if(s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif 
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1104,9 +1151,11 @@
 eTSMPEGDecoder::~eTSMPEGDecoder()
 {
 	finishShowSinglePic();
+#if not defined(__sh__) // why dont we need this ?
 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
 	m_changed = -1;
 	setState();
+#endif
 }
 
 RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
@@ -1304,6 +1353,10 @@
 			struct stat s;
 			size_t written=0;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)  
+				finishShowSinglePic();  
+#endif  
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1319,8 +1372,10 @@
 				read(f, iframe, s.st_size);
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
+#if not defined(__sh__) 
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
+#endif 
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("VIDEO_PLAY failed (%m)");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1337,7 +1392,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				write(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__) 
 				m_showSinglePicTimer->start(150, true);
+#endif 
 			}
 			close(f);
 		}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/demux.cpp enigma2-nightly.patched/lib/dvb/demux.cpp
--- enigma2-nightly.org/lib/dvb/demux.cpp	2011-09-03 18:23:25.060022563 +0200
+++ enigma2-nightly.patched/lib/dvb/demux.cpp	2011-09-03 18:23:47.130032918 +0200
@@ -548,6 +548,9 @@
 		eDebug("FAILED to open dvr (%s) in ts recoder (%m)", filename);
 		return -3;
 	}
+#if defined(__sh__) // we need to set the correct buffer size for some reason ;-)
+	setBufferSize(256*1024);
+#endif
 #else
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
 
@@ -588,7 +591,14 @@
 	if (m_target_filename != "")
 		m_thread->startSaveMetaInformation(m_target_filename);
 	
+#if defined(__sh__) // this calls our own filepushthread which supports prioritising and splitting
+	if (m_target_filename != "")
+		m_thread->start(m_source_fd, m_target_fd, m_target_filename.c_str());
+	else
+		m_thread->start(m_source_fd, m_target_fd);
+#else
 	m_thread->start(m_source_fd, m_target_fd);
+#endif
 	m_running = 1;
 
 	while (i != m_pids.end()) {
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/dvb.cpp enigma2-nightly.patched/lib/dvb/dvb.cpp
--- enigma2-nightly.org/lib/dvb/dvb.cpp	2011-09-03 18:23:25.070021752 +0200
+++ enigma2-nightly.patched/lib/dvb/dvb.cpp	2011-09-03 18:23:47.140033223 +0200
@@ -100,6 +100,47 @@
 		m_boxtype = DM800SE;
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs912\n", rd))
+		m_boxtype = UFS912;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "spark7162\n", rd))
+		m_boxtype = SPARK7162;
+	else if (!strncmp(tmp, "vip1-v2\n", rd))
+		m_boxtype = VIP1_V2;
+	else if (!strncmp(tmp, "vip2-v1\n", rd))
+		m_boxtype = VIP2_V1;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+	else if (!strncmp(tmp, "octagon1008\n", rd)) m_boxtype = OCTAGON1008;
+	else if (!strncmp(tmp, "hs7810a\n", rd)) m_boxtype = HS7810A;
+	else if (!strncmp(tmp, "hs7110\n", rd)) m_boxtype = HS7110;
+	else if (!strncmp(tmp, "atevio7500\n", rd))
+		m_boxtype = ATEVIO7500;
+#endif
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -552,7 +592,58 @@
 			}
 		}
 	}
+#if defined(__sh__) // we use our own algo for demux detection
+	else if (m_boxtype == UFS910 || m_boxtype == UFS912 || m_boxtype == SPARK || m_boxtype == SPARK7162 || m_boxtype == UFS922 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX ||
+		m_boxtype == HL101 || m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || m_boxtype == VIP1_V2 || m_boxtype == VIP2_V1 || m_boxtype == HS7810A || m_boxtype == HS7110 ||
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD || m_boxtype == OCTAGON1008 || m_boxtype == ATEVIO7500)
+	{
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter &&
+				    i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
 
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	if (unused)
 	{
 		demux = new eDVBAllocatedDemux(unused);
@@ -1799,6 +1890,12 @@
 			return -ENODEV;
 		}
 #else
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -1815,6 +1912,7 @@
 			return -ENODEV;
 		}
 #endif
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush();
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/dvb.h enigma2-nightly.patched/lib/dvb/dvb.h
--- enigma2-nightly.org/lib/dvb/dvb.h	2011-09-03 18:23:25.070021752 +0200
+++ enigma2-nightly.patched/lib/dvb/dvb.h	2011-09-03 18:23:47.150033502 +0200
@@ -135,7 +135,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
-	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+#if defined(__sh__)
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, UFS910, UFS912, UFS922, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD, OCTAGON1008, VIP1_V2, VIP2_V1, SPARK, SPARK7162, ATEVIO7500, HS7810A, HS7110};
+#else
+ 	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+#endif
 
 	int m_boxtype;
 
@@ -245,6 +249,9 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/epgcache.cpp enigma2-nightly.patched/lib/dvb/epgcache.cpp
--- enigma2-nightly.org/lib/dvb/epgcache.cpp	2011-09-03 18:23:25.100021762 +0200
+++ enigma2-nightly.patched/lib/dvb/epgcache.cpp	2011-09-03 18:23:47.160032893 +0200
@@ -115,11 +115,25 @@
 	int tmp = ByteSize-10;
 	memcpy(data, EITdata, 10);
 	int descriptors_length=0;
+#ifndef __sh__
 	__u32 *p = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while(tmp>3)
 	{
+#ifndef __sh__
 		descriptorMap::iterator it =
 			descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);			*/
+		descriptorMap::iterator it =
+			descriptors.find(index);
+
+		p += 4;
+#endif
 		if ( it != descriptors.end() )
 		{
 			int b = it->second.second[1]+2;
@@ -128,7 +142,11 @@
 			descriptors_length += b;
 		}
 		else
+#ifndef __sh__  
 			eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-1));
+#else
+			eDebug("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-4));
+#endif
 		tmp-=4;
 	}
 	ASSERT(pos <= 4108);
@@ -142,12 +160,26 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);			*/
+			descriptorMap::iterator it =
+				descriptors.find(index);
+				
+			d += 4;
+#endif
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -159,7 +191,13 @@
 				}
 			}
 			else
+#ifndef __sh__
 				eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-1));
+#else
+//Dagobert: currently this happens sporadicly on ufs922 (with new skin). Not sure why
+//we must observe this!
+				eDebug("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-4));
+#endif
 			ByteSize -= 4;
 		}
 		delete [] EITdata;
@@ -1446,6 +1484,46 @@
 	int source;
 	int map;
 	iDVBSectionReader *reader=NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is 
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */ 
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+	
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+		
+	if (isNotAligned)
+	{
+	
+	   /* see HILO macro and eit.h */
+	   int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+           /*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+	   if ( EIT_SIZE >= len )
+		   return;
+
+	   aligned_data = (const __u8 *) malloc(len);
+
+	   if ((unsigned int)aligned_data % 4 != 0)
+	   {
+		   eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+	   }
+
+           /*eDebug("%p %p\n", aligned_data, data); */
+	   memcpy((void *) aligned_data, (const __u8 *) data, len);
+	   data = aligned_data;	
+	}	
+#endif
 	switch(data[0])
 	{
 		case 0x4E ... 0x4F:
@@ -1535,6 +1613,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+	   free((void *)aligned_data);
+#endif	
 }
 
 RESULT eEPGCache::lookupEventTime(const eServiceReference &service, time_t t, const eventData *&result, int direction)
@@ -2261,11 +2343,22 @@
 						{
 							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
+#ifndef __sh__
 							__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+							__u8 *p = (__u8*)(data+10);
+#endif
 								// search short and extended event descriptors
 							while(tmp>3)
 							{
+#ifndef __sh__
 								__u32 crc = *p++;
+#else
+/* Dagobert: Alignment fix */
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
@@ -2443,12 +2536,23 @@
 					continue;
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else
+/* Dagobert: Alignment fix */
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb/volume.cpp enigma2-nightly.patched/lib/dvb/volume.cpp
--- enigma2-nightly.org/lib/dvb/volume.cpp	2011-09-03 18:23:25.270022138 +0200
+++ enigma2-nightly.patched/lib/dvb/volume.cpp	2011-09-03 18:23:47.170033468 +0200
@@ -29,7 +29,9 @@
 eDVBVolumecontrol::eDVBVolumecontrol()
 {
 	volumeUnMute();
+#if not defined (__sh__) // dont reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_appmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp	2011-09-03 18:23:25.290021763 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_appmgr.cpp	2011-09-03 18:23:47.170033468 +0200
@@ -6,17 +6,32 @@
 
 eDVBCIApplicationManagerSession::eDVBCIApplicationManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setAppManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIApplicationManagerSession::~eDVBCIApplicationManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setAppManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIApplicationManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/APP %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -58,11 +73,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIApplicationManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
   switch (state)
   {
   case stateStarted:
@@ -70,6 +91,9 @@
     const unsigned char tag[3]={0x9F, 0x80, 0x20}; // application manager info e    sendAPDU(tag);
 		sendAPDU(tag);
     state=stateFinal;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 1;
   }
   case stateFinal:
@@ -81,19 +105,35 @@
       const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
       sendAPDU(tag);
       wantmenu=0;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
       return 0;
     } else
       return 0;
   default:
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 0;
   }
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::startMMI()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_camgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_camgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_camgr.cpp	2011-09-03 18:23:25.300022213 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_camgr.cpp	2011-09-03 18:23:47.180033057 +0200
@@ -5,17 +5,32 @@
 
 eDVBCICAManagerSession::eDVBCICAManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setCAManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCICAManagerSession::~eDVBCICAManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setCAManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCICAManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/CA %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -41,11 +56,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCICAManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -58,16 +79,28 @@
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::sendCAPMT(unsigned char *data, int len)
 {
 	const unsigned char tag[3]={0x9F, 0x80, 0x32}; // ca_pmt
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendAPDU(tag, data, len);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci.cpp	2011-09-03 18:23:25.280022067 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci.cpp	2011-09-03 18:23:47.190032918 +0200
@@ -16,6 +16,10 @@
 #include <lib/dvb_ci/dvbci_appmgr.h>
 #include <lib/dvb_ci/dvbci_mmi.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+#endif
+
 #include <dvbsi++/ca_program_map_section.h>
 
 //#define CIDEBUG 1
@@ -28,6 +32,271 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+
+//#define x_debug
+
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+
+}
+
+/* from dvb-apps
+ */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug	
+        printf("%s: %p, %d\n", __func__, data, len);
+#endif
+       
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+		
+	/* should we send a data last ?
+	 */
+	if (data != NULL)
+	{
+	   if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+	   {
+	      memcpy(d, data, len);
+	   } else
+	   {
+	      //send data_last and data
+	      memcpy(d + 5, data, len);
+
+	      d[0] = getSlotID();
+	      d[1] = connection_id;
+	      d[2] = T_DATA_LAST; 	
+	      d[3] = len + 1; 		/* len */
+	      d[4] = connection_id; 	/* transport connection identifier*/
+
+	      len += 5;	
+	   }
+	}
+	else
+	{
+	      //send a data last only
+	      d[0] = getSlotID();
+	      d[1] = connection_id;
+	      d[2] = T_DATA_LAST; 	
+	      d[3] = len + 1; 		/* len */
+	      d[4] = connection_id; 	/* transport connection identifier*/
+
+	      len = 5;	
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for(int i=0; i < len; i++)
+	   printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len); 
+
+	free(d);
+	if (res < 0 || res != len) 
+	{ 
+            printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+            return eDataError; 
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif	 
+	
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+   //printf("%s:%s >\n", FILENAME, __FUNCTION__);
+   unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+
+   tx_time.tv_sec = 0;
+   
+   data[0] = getSlotID();
+   data[1] = getSlotID() + 1; 	/* conid */
+   data[2] = T_CREATE_T_C;
+   data[3] = 1;
+   data[4] = getSlotID() + 1 	/*conid*/;
+
+   write(fd, data, 5);
+
+   //printf("%s:%s <\n", FILENAME, __FUNCTION__);
+   return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+   switch (tpdu_tag) 
+   {
+	   case T_C_T_C_REPLY:
+	      printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+          tx_time.tv_sec = 0;
+	      
+		  state = stateInserted;
+          
+          //answer with data last (and if we have with data)
+	      sendData(NULL, 0);
+	      
+	      break;
+	   case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+
+	      printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+	      
+	      break;
+	   case T_D_T_C_REPLY:
+
+	      printf("Got \"Delete Transport Connection Replay\" from module!\n");
+	      break;
+
+	   case T_REQUEST_T_C:
+
+	      printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+
+	      break;
+	   case T_DATA_MORE:
+	   {
+		  int new_data_length = receivedLen + asn_data_length;
+
+	      printf("Got \"Data More\" from Module\n");
+
+		  __u8 *new_data_buffer = (__u8*)
+	      realloc(receivedData, new_data_length);
+
+		  receivedData = new_data_buffer;
+
+		  memcpy(receivedData + receivedLen, data, asn_data_length);
+
+		  receivedLen = new_data_length;
+
+	      tx_time.tv_sec = 0;
+	      break;
+ 	  }
+	  case T_DATA_LAST:
+	 
+#ifdef x_debug	
+	        printf("Got \"Data Last\" from Module\n");
+#endif
+		
+	    tx_time.tv_sec = 0;
+		/* single package */
+	    if (receivedData == NULL) 
+		{
+
+	       printf("->single package\n");
+#ifdef x_debug	
+			printf("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < asn_data_length; i++)
+				printf("%02x ", data[i]);
+                        printf("\n");
+#endif
+
+			eDVBCISession::receiveData(this, data, asn_data_length);
+			eDVBCISession::pollAll();
+		} else 
+		{
+			/* chained package */
+			int new_data_length = receivedLen + asn_data_length;
+
+	        printf("->chained data\n");
+
+			__u8 *new_data_buffer =
+	    	(__u8*) realloc(receivedData, new_data_length);
+	
+			receivedData = new_data_buffer;
+
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+		
+			receivedLen = new_data_length;
+					
+#ifdef x_debug	
+			printf("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < receivedLen; i++)
+				printf("%02x ", receivedData[i]);
+                        printf("\n");
+#endif
+
+			eDVBCISession::receiveData(this, receivedData, receivedLen);
+			eDVBCISession::pollAll();
+
+//fixme: must also be moved in e2 behind the data processing ;) 
+
+			free(receivedData);
+			receivedData = NULL;
+			receivedLen = 0;
+		}
+	    break;
+	    case T_SB:
+	    {
+#ifdef x_debug	
+	      printf("Got \"SB\" from Module\n");
+#endif
+
+	      if (data[0] & 0x80)
+	      {
+	      	printf("->data ready (%d)\n", getSlotID());
+	
+		    // send the RCV and ask for the data
+		    unsigned char send_data[5];
+
+		    send_data[0] = getSlotID();
+		    send_data[1] = connection_id;
+		    send_data[2] = T_RCV;
+		    send_data[3] = 1;
+		    send_data[4] = connection_id;
+
+		    write(fd, send_data, 5);
+		    gettimeofday(&tx_time, 0);
+	      } else
+          {
+             tx_time.tv_sec = 0;
+          }
+	      break;
+	 }
+	 default:
+	      printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+   }
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -40,10 +309,21 @@
 	{
 		struct stat s;
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (stat(filename, &s))
+#ifdef __sh__
+		{
+			eDebug("stat on %s failed\n", filename);		
+#endif
 			break;
+#ifdef __sh__
+		}
+#endif
 
 		ePtr<eDVBCISlot> cislot;
 
@@ -105,6 +385,9 @@
 int eDVBCIInterfaces::reset(int slotid)
 {
 	eDVBCISlot *slot;
+#ifdef __sh__
+	eDebug("eDVBCIInterfaces::reset %d\n", slotid);
+#endif
 
 	if( (slot = getSlot(slotid)) == 0 )
 		return -1;
@@ -957,8 +1240,14 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+
+#ifdef __sh__
+        sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -967,6 +1256,7 @@
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -982,7 +1272,6 @@
 		}
 		return;
 	}
-
 	if (state == stateInvalid)
 		reset();
 
@@ -1020,8 +1309,202 @@
 			}
 		}
 		else
-			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
+			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority); 
 	}
+#else
+    	unsigned char data[1024];
+        int len = 1024;
+        unsigned char* d;
+        eData status;
+	    ca_slot_info_t info;
+		    
+        if (what & eSocketNotifier::Read)
+        {
+	        eDebugCI("eSocketNotifier::Read\n");
+            status = eDataReady;
+		    len = ::read(fd, data, len);
+        }    
+        else
+        if (what & eSocketNotifier::Write)
+        {
+	        eDebugCI("eSocketNotifier::Write\n");
+            status = eDataWrite;
+        }
+        else
+        if (what & eSocketNotifier::Priority)
+        {
+	        eDebugCI("eSocketNotifier::Priority\n");
+            status = eDataStatusChanged;
+        }
+
+	    switch (getState())
+	    {
+	        case stateInvalid:
+		    {
+                 if (status == eDataStatusChanged)
+                 {
+                    info.num = getSlotID();
+
+			        if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+			                printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+	   	            if (info.flags & CA_CI_MODULE_READY)
+		            {
+		                  printf("1. cam status changed ->cam now present\n");
+
+		                  state = stateInserted;
+	                      mmi_active = false;
+
+                          tx_time.tv_sec = 0;
+
+	                      application_manager = 0;
+	                      ca_manager = 0;
+
+                          sendCreateTC();
+
+                          eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+		             }
+                  }
+                  else
+                  {
+                       usleep(100000);
+                  }
+		    }
+		    break;
+		    case stateInserted:
+            {    
+		       if (status == eDataReady)
+		       {
+                 eDebugCI("received data - len %d\n", len);
+               
+		         //int s_id = data[0];
+		         //int c_id = data[1];
+
+		         //printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+                       
+		         d = data;
+
+		         /* taken from the dvb-apps */
+		         int data_length = len - 2;
+		         d += 2; /* remove leading slot and connection id */
+		         while (data_length > 0)
+		         {
+			         unsigned char tpdu_tag = d[0];
+			         unsigned short asn_data_length;
+			         int length_field_len;
+
+			         if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0) 
+			         {
+				         printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+				         break;
+			         }
+
+			         if ((asn_data_length < 1) ||
+		    		      (asn_data_length > (data_length - (1 + length_field_len)))) 
+			         {
+				         printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+				         break;
+			         }
+
+			         connection_id = d[1 + length_field_len];
+
+			         //printf("Setting connection_id from received data to %d\n", slot->connection_id);
+
+			         d += 1 + length_field_len + 1;
+			         data_length -= (1 + length_field_len + 1);
+			         asn_data_length--;
+
+			         process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+
+			         // skip over the consumed data
+			         d += asn_data_length;
+			         data_length -= asn_data_length;
+
+		         } // while (data_length)
+		       } /* data ready */
+		       else if (status == eDataWrite)
+		       {
+		           if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+                   {
+			          const queueData &qe = sendqueue.top();
+			     
+			          int res = write(fd, qe.data, qe.len);
+			          if (res >= 0 && (unsigned int)res == qe.len)
+			          {
+				         delete [] qe.data;
+				         sendqueue.pop();
+					     gettimeofday(&tx_time, 0);
+			          }
+			          else
+			          {
+				         printf("r = %d, %m\n", res);
+			          }			
+		           }
+
+                   /* the spec say's that we _must_ poll the connection
+                    * if the transport connection is in active state
+                    */
+                   if ((tx_time.tv_sec == 0) && (!checkQueueSize()) &&
+			           (time_after(last_poll_time, 1000)))
+		           {
+		              sendData(NULL, 0);
+		              clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+                   }
+		       }
+		       else if (status == eDataStatusChanged)
+		       {
+                   info.num = getSlotID();
+
+		           if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+			           printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+	               
+	               if (info.flags & CA_CI_MODULE_READY)
+		           {
+		              printf("2. cam status changed ->cam now present\n");
+
+	                  mmi_active = false;
+		              state = stateInvalid;
+	                  application_manager = 0;
+	                  ca_manager = 0;
+                      tx_time.tv_sec = 0;
+                      
+		              eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+
+                   } 
+                   else
+	   	           if (!(info.flags & CA_CI_MODULE_READY))
+			       {
+		               printf("cam status changed ->cam now _not_ present\n");
+
+	 	               eDVBCISession::deleteSessions(this);
+
+	                   mmi_active = false;
+			           state = stateInvalid;
+	                   application_manager = 0;
+	                   ca_manager = 0;
+                       tx_time.tv_sec = 0;
+
+	                   eDVBCIInterfaces::getInstance()->ciRemoved(this);
+
+			           eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+
+	                   while(sendqueue.size())
+	                   {
+		        	       delete [] sendqueue.top().data;
+		        	       sendqueue.pop();
+	                   }
+                   }
+		       }
+		    }
+		    break;
+		    default:
+               printf("unknown state %d\n", state);		
+		    break;
+	    }
+
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+       
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1040,7 +1523,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1051,10 +1538,26 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+
+	    tx_time.tv_sec = 0;
+	    tx_time.tv_usec = 0;
+	    last_poll_time.tv_sec = 0;
+        last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+
+#ifdef __sh__
+        reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1089,7 +1592,15 @@
 int eDVBCISlot::reset()
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+    eDVBCIInterfaces::getInstance()->ciRemoved(this);
 
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1097,6 +1608,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif	
 
 	while(sendqueue.size())
 	{
@@ -1104,7 +1616,12 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_datetimemgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_datetimemgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_datetimemgr.cpp	2011-09-03 18:23:25.300022213 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_datetimemgr.cpp	2011-09-03 18:23:47.200033618 +0200
@@ -5,6 +5,9 @@
 
 int eDVBCIDateTimeSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIDateTimeSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/DATETIME %02x %02x %02x: ", session_nb, tag[0],tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -16,6 +19,9 @@
 		{
 		case 0x40:
 			state=stateSendDateTime;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		default:
@@ -23,25 +29,43 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIDateTimeSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	case stateSendDateTime:
 	{
 		unsigned char tag[3]={0x9f, 0x84, 0x41}; // date_time_response
 		unsigned char msg[7]={0, 0, 0, 0, 0, 0, 0};
 		sendAPDU(tag, msg, 7);
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci.h enigma2-nightly.patched/lib/dvb_ci/dvbci.h
--- enigma2-nightly.org/lib/dvb_ci/dvbci.h	2011-09-03 18:23:25.290021763 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci.h	2011-09-03 18:23:47.200033618 +0200
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,6 +46,44 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+
+
+#endif
+
 class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
@@ -66,6 +107,15 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char 		connection_id;
+	bool		mmi_active;	
+
+    int            receivedLen;
+	unsigned char* receivedData;
+
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +145,20 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+
+	void thread();  // thread function
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+
+    void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+    bool sendCreateTC();
+    eData sendData(unsigned char* data, int len);
+
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif	
 };
 
 struct CIPmtHandler
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_mmi.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp	2011-09-03 18:23:25.310022027 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_mmi.cpp	2011-09-03 18:23:47.210032967 +0200
@@ -19,18 +19,34 @@
 
 eDVBCIMMISession::eDVBCIMMISession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setMMIManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+	slot->mmiClosed();
+#endif	
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIMMISession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIMMISession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/MMI %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -40,14 +56,23 @@
 		if (eDVBCI_UI::getInstance()->processMMIData(slot->getSlotID(), tag, data, len) == 1)
 		{
 			state=stateDisplayReply;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 		}
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIMMISession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -76,6 +101,9 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -87,6 +115,9 @@
 	unsigned char data[]={0x00};
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -99,6 +130,9 @@
 	data[0] = answer & 0xff;
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -114,6 +148,9 @@
 	unsigned char tag[]={0x9f, 0x88, 0x08};
 	sendAPDU(tag, data, len+1);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -125,6 +162,9 @@
 	unsigned char data[]={0x00}; // canceled
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_resmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp	2011-09-03 18:23:25.320022003 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_resmgr.cpp	2011-09-03 18:23:47.210032967 +0200
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
@@ -16,6 +21,9 @@
 		case 0x10:  // profile enquiry
 			eDebug("cam fragt was ich kann.");
 			state=stateProfileEnquiry;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		case 0x11: // Tprofile
@@ -28,6 +36,9 @@
 
 			if (state == stateFirstProfileEnquiry)
 			{
+#ifdef __sh__
+				eDebug("%s <", __func__);
+#endif
 				// profile change
 				return 1;
 			}
@@ -38,11 +49,17 @@
 		}
 	}
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIResourceManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -50,6 +67,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x10}; // profile enquiry
 		sendAPDU(tag);
 		state = stateFirstProfileEnquiry;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFirstProfileEnquiry:
@@ -57,6 +77,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x12}; // profile change
 		sendAPDU(tag);
 		state=stateProfileChange;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateProfileChange:
@@ -86,5 +109,8 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_session.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp	2011-09-03 18:23:25.320022003 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_session.cpp	2011-09-03 18:23:47.220032903 +0200
@@ -14,6 +14,9 @@
 
 int eDVBCISession::buildLengthField(unsigned char *pkt, int len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	if (len < 127)
 	{
 		*pkt++=len;
@@ -34,14 +37,23 @@
 		eDebug("too big length");
 		exit(0);
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::parseLengthField(const unsigned char *pkt, int &len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	len=0;
 	if (!(*pkt&0x80)) 
 	{
 		len = *pkt;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 1;
 	}
 	for (int i=0; i<(pkt[0]&0x7F); ++i)
@@ -49,6 +61,9 @@
 		len <<= 8;
 		len |= pkt[i + 1];
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return (pkt[0] & 0x7F) + 1;
 }
 
@@ -56,22 +71,37 @@
 {
 	unsigned char pkt[len+3+4];
 	int l;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	memcpy(pkt, tag, 3);
 	l=buildLengthField(pkt+3, len);
 	if (data)
 		memcpy(pkt+3+l, data, len);
 	sendSPDU(0x90, 0, 0, pkt, len+3+l);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(unsigned char tag, const void *data, int len, const void *apdu, int alen)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(slot, tag, data, len, session_nb, apdu, alen);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(eDVBCISlot *slot, unsigned char tag, const void *data, int len, unsigned short session_nb, const void *apdu,int alen)
 {
 	unsigned char pkt[4096];
 	unsigned char *ptr=pkt;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	*ptr++=tag;
 	ptr+=buildLengthField(ptr, len+2);
 	if (data)
@@ -85,6 +115,9 @@
 
 	ptr+=alen;
 	slot->send(pkt, ptr - pkt);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendOpenSessionResponse(eDVBCISlot *slot, unsigned char session_status, const unsigned char *resource_identifier, unsigned short session_nb)
@@ -94,32 +127,53 @@
 	eDebug("sendOpenSessionResponse");
 	memcpy(pkt + 1, resource_identifier, 4);
 	sendSPDU(slot, 0x92, pkt, 5, session_nb);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCreateSessionResponse(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	status = data[0];
 	state = stateStarted;
 	action = 1;
 	eDebug("create Session Response, status %x", status);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCloseSessionRequest(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	state = stateInDeletion;
 	action = 1;
 	eDebug("close Session Request");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::deleteSessions(const eDVBCISlot *slot)
 {
 	ePtr<eDVBCISession> ptr;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (unsigned short session_nb=0; session_nb < SLMS; ++session_nb)
 	{
 		ptr = sessions[session_nb];
 		if (ptr && ptr->slot == slot)
 			sessions[session_nb]=0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status, ePtr<eDVBCISession> &session)
@@ -127,12 +181,21 @@
 	unsigned long tag;
 	unsigned short session_nb;
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (session_nb=1; session_nb < SLMS; ++session_nb)
 		if (!sessions[session_nb-1])
 			break;
+#ifdef __sh__		
+	eDebug("use session_nb = %d\n", session_nb);
+#endif		
 	if (session_nb == SLMS)
 	{
 		status=0xF3;
+#ifdef __sh__
+	        eDebug("%s <", __func__);
+#endif
 		return;
 	}
 
@@ -190,16 +253,28 @@
 		status = 0;
 	}
 	session->state = stateInCreation;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::handleClose()
 {
 	unsigned char data[1]={0x00};
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(0x96, data, 1, 0, 0);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::pollAll()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (int session_nb=1; session_nb < SLMS; ++session_nb)
 		if (sessions[session_nb-1])
 		{
@@ -214,8 +289,18 @@
 				r=sessions[session_nb-1]->poll();
 
 			if (r)
+#ifdef __sh__
+			{
+				eDebug("%s <", __func__);
+#endif
 				return 1;
+#ifdef __sh__
+			}
+#endif
 		}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -224,6 +309,9 @@
 	const unsigned char *pkt = (const unsigned char*)ptr;
 	unsigned char tag = *pkt++;
 	int llen, hlen;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 
 	eDebug("slot: %p",slot);
 
@@ -251,12 +339,22 @@
 	else
 	{
 		unsigned session_nb;
+#ifdef __sh__
+		eDebug("hlen = %d, %d, %d\n", hlen,  pkt[hlen-2], pkt[hlen-1]);
+#endif
 		session_nb=pkt[hlen-2]<<8;
 		session_nb|=pkt[hlen-1]&0xFF;
 		
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset
+			//it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
@@ -290,6 +388,10 @@
 	len -= hlen;
 
 	if (session)
+#ifdef __sh__
+	{
+		eDebug("len %d\n", len);
+#endif
 		while (len > 0)
 		{
 			int alen;
@@ -299,6 +401,9 @@
 			hlen=parseLengthField(pkt, alen);
 			pkt+=hlen;
 			len-=hlen;
+#ifdef __sh__
+			eDebug("len = %d, hlen = %d, alen = %d\n", len, hlen, alen);
+#endif
 
 			//if (eDVBCIModule::getInstance()->workarounds_active & eDVBCIModule::workaroundMagicAPDULength)
 			{
@@ -308,14 +413,23 @@
 					alen=len;
 				}
 			}
+#ifdef __sh__
+			eDebug("1. Call receivedAPDU tag = 0x%2x, len = %d\n", tag, alen);
+#endif
 			if (session->receivedAPDU(tag, pkt, alen))
 				session->action = 1;
 			pkt+=alen;
 			len-=alen;
 		}
 		
+#ifdef __sh__
+	}
+#endif
 	if (len)
 		eDebug("PROTOCOL: warning, TL-Data has invalid length");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCISession::~eDVBCISession()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/dvb_ci/dvbci_ui.cpp enigma2-nightly.patched/lib/dvb_ci/dvbci_ui.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_ui.cpp	2011-09-03 18:23:25.330022288 +0200
+++ enigma2-nightly.patched/lib/dvb_ci/dvbci_ui.cpp	2011-09-03 18:23:47.220032903 +0200
@@ -17,8 +17,14 @@
 eDVBCI_UI::eDVBCI_UI()
 	:eMMI_UI(MAX_SLOTS)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	ASSERT(!instance);
 	instance = this;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCI_UI *eDVBCI_UI::getInstance()
@@ -28,51 +34,96 @@
 
 void eDVBCI_UI::setInit(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->initialize(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCI_UI::setReset(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->reset(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCI_UI::startMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->startMMI(slot);
 	return 0;
 }
 
 int eDVBCI_UI::stopMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->stopMMI(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerMenu(int slot, int answer)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerText(slot, answer);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerEnq(int slot, char *value)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerEnq(slot, value);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::cancelEnq(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->cancelEnq(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::getMMIState(int slot)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->getMMIState(slot);
 }
 
 int eDVBCI_UI::setClockRate(int slot, int rate)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->setCIClockRate(slot, rate);
 }
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/accel.cpp enigma2-nightly.patched/lib/gdi/accel.cpp
--- enigma2-nightly.org/lib/gdi/accel.cpp	2011-09-03 18:23:25.340022052 +0200
+++ enigma2-nightly.patched/lib/gdi/accel.cpp	2011-09-03 18:23:47.230032703 +0200
@@ -9,8 +9,25 @@
 #include <lib/gdi/gpixmap.h>
 
 gAccel *gAccel::instance;
+#if not defined(__sh__) 
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -47,6 +64,9 @@
 	m_accel_allocation = 0;
 	instance = this;
 
+#ifdef STMFB_ACCEL	
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -57,6 +77,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL	
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -87,6 +110,77 @@
 
 int gAccel::blit(gSurface *dst, const gSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+     	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+        	if(accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if(data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if(data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/epng.cpp enigma2-nightly.patched/lib/gdi/epng.cpp
--- enigma2-nightly.org/lib/gdi/epng.cpp	2011-09-03 18:23:25.360022298 +0200
+++ enigma2-nightly.patched/lib/gdi/epng.cpp	2011-09-03 18:23:47.240032937 +0200
@@ -4,6 +4,10 @@
 #include <lib/gdi/epng.h>
 #include <unistd.h>
 
+#if (PNG_LIBPNG_VER > 10500)
+#include "zlib.h"
+#endif
+
 extern "C" {
 #include <jpeglib.h>
 }
@@ -52,7 +56,11 @@
 		fclose(fp);
 		return 0;
 	 }
+#if (PNG_LIBPNG_VER < 10500)
 	if (setjmp(png_ptr->jmpbuf))
+#else
+	if (setjmp(png_jmpbuf(png_ptr)))
+#endif
 	{
 		eDebug("das war wohl nix");
 		png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
@@ -262,7 +270,11 @@
 		PNG_COLOR_TYPE_RGB_ALPHA, 
 		PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
 
+#if (PNG_LIBPNG_VER < 10500)
 	if (setjmp(png_ptr->jmpbuf))
+#else
+	if (setjmp(png_jmpbuf(png_ptr)))
+#endif
 	{
 		eDebug("error :/");
 		png_destroy_write_struct(&png_ptr, &info_ptr);
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/fb.cpp enigma2-nightly.patched/lib/gdi/fb.cpp
--- enigma2-nightly.org/lib/gdi/fb.cpp	2011-09-03 18:23:25.380022383 +0200
+++ enigma2-nightly.patched/lib/gdi/fb.cpp	2011-09-03 18:23:47.240032937 +0200
@@ -70,6 +70,15 @@
 		perror("mmap");
 		goto nolfb;
 	}
+#if defined(__sh__) 
+	//we use 2MB at the end of the buffer, the rest does the blitter 
+	lfb_direct = lfb;     
+	lfb += 1920*1080*4;     
+	topDiff = 0;
+	leftDiff = 0;
+	rightDiff = 0;
+	bottomDiff = 0;
+#endif 
 
 	showConsole(0);
 
@@ -83,6 +92,9 @@
 
 int fbClass::showConsole(int state)
 {
+#if defined(__sh__) 
+	int fd=open("/dev/null", O_RDWR); // [spider] changed it because conflict with hdbox frontpanel
+#else 
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{
@@ -92,13 +104,18 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(unsigned int nxRes, unsigned int nyRes, unsigned int nbpp)
 {
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
+#if defined(__sh__) 
+	screeninfo.yres_virtual=screeninfo.yres=nyRes; 
+#else 
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
+#endif
 	screeninfo.height=0;
 	screeninfo.width=0;
 	screeninfo.xoffset=screeninfo.yoffset=0;
@@ -129,6 +146,7 @@
 		break;
 	}
 
+#if not defined(__sh__) 
 	if (ioctl(fd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
 	{
 		// try single buffering
@@ -143,6 +161,7 @@
 		eDebug(" - double buffering not available.");
 	} else
 		eDebug(" - double buffering available!");
+#endif
 	
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 	
@@ -154,6 +173,10 @@
 			nxRes, nyRes, nbpp,
 			screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
 	}
+#if defined(__sh__) 
+	xResFB=nxRes; 
+	yResFB=nyRes; 
+#endif 
 	xRes=screeninfo.xres;
 	yRes=screeninfo.yres;
 	bpp=screeninfo.bits_per_pixel;
@@ -164,7 +187,9 @@
 		printf("fb failed\n");
 	}
 	stride=fix.line_length;
+#if not defined(__sh__) 
 	memset(lfb, 0, stride*yRes);
+#endif
 	return 0;
 }
 
@@ -183,10 +208,81 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__)
+	int modefd=open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if(modefd > 0){
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA  bltData; 
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA)); 
+	bltData.operation  = BLT_OP_COPY; 
+	bltData.srcOffset  = 1920*1080*4; 
+	bltData.srcPitch   = xResFB * 4; 
+	bltData.dstOffset  = 0; 
+	bltData.dstPitch   = xRes*4; 
+	bltData.src_top    = 0;
+	bltData.src_left   = 0; 
+	bltData.src_right  = xResFB;
+ 	bltData.src_bottom = yResFB; 
+	bltData.srcFormat = SURF_BGRA8888; bltData.dstFormat = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER; bltData.dstMemBase = STMFBGP_FRAMEBUFFER; 
+ 
+	if(strncmp(buf,"sbs",3)==0){
+		bltData.dst_top    = 0 + topDiff; 
+		bltData.dst_left   = 0 + leftDiff/2; 
+		bltData.dst_right  = xRes/2 + rightDiff/2; 
+		bltData.dst_bottom = yRes + bottomDiff; 
+		if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+		{ 
+			perror("FBIO_BLIT"); 
+		}
+		bltData.dst_top    = 0 + topDiff; 
+		bltData.dst_left   = xRes/2 + leftDiff/2; 
+		bltData.dst_right  = xRes + rightDiff/2; 
+		bltData.dst_bottom = yRes + bottomDiff; 
+		if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+		{ 
+			perror("FBIO_BLIT"); 
+		}
+	}else if(strncmp(buf,"tab",3)==0){
+		bltData.dst_top    = 0 + topDiff/2; 
+		bltData.dst_left   = 0 + leftDiff; 
+		bltData.dst_right  = xRes + rightDiff; 
+		bltData.dst_bottom = yRes/2 + bottomDiff/2; 
+		if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+		{ 
+			perror("FBIO_BLIT"); 
+		}
+		bltData.dst_top    = yRes/2 + topDiff/2; 
+		bltData.dst_left   = 0 + leftDiff; 
+		bltData.dst_right  = xRes + rightDiff; 
+		bltData.dst_bottom = yRes + bottomDiff/2; 
+		if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+		{ 
+			perror("FBIO_BLIT"); 
+		}
+	}else{
+		bltData.dst_top    = 0 + topDiff; 
+		bltData.dst_left   = 0 + leftDiff; 
+		bltData.dst_right  = xRes + rightDiff; 
+		bltData.dst_bottom = yRes + bottomDiff; 
+		if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+		{ 
+			perror("FBIO_BLIT"); 
+		}
+	
+	}
+
+#else 
 	if (m_manual_blit == 1) {
 		if (ioctl(fd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -231,19 +327,62 @@
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 1;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 0;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0) 
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
 }
 
+#if defined(__sh__) 
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+	memset(lfb_direct, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
+
+}
+
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/fb.h enigma2-nightly.patched/lib/gdi/fb.h
--- enigma2-nightly.org/lib/gdi/fb.h	2011-09-03 18:23:25.380022383 +0200
+++ enigma2-nightly.patched/lib/gdi/fb.h	2011-09-03 18:23:47.250032923 +0200
@@ -4,10 +4,18 @@
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
 
+#if defined(__sh__) 
+	#include <linux/stmfb.h> 
+#endif
 class fbClass
 {
 	int fd;
 	unsigned int xRes, yRes, stride, bpp;
+#if defined(__sh__) 
+	unsigned int xResFB, yResFB; 
+	int topDiff, leftDiff, rightDiff, bottomDiff; 
+	unsigned char *lfb_direct;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo, oldscreen;
 	fb_cmap cmap;
@@ -48,10 +56,23 @@
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#if defined(__sh__)  
+//---> "hack" for libeplayer3 fb access
+        int getFD() { return fd; }
+        unsigned char * getLFB_Direct() { return lfb_direct; }
+        int getScreenResX() { return xRes; }
+        int getScreenResY() { return yRes; }
+//---<
+#endif  
 
 	int lock();
 	void unlock();
 	int islocked() { return locked; }
+#if defined(__sh__) 
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 };
 
 #endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gfbdc.cpp enigma2-nightly.patched/lib/gdi/gfbdc.cpp
--- enigma2-nightly.org/lib/gdi/gfbdc.cpp	2011-09-03 18:23:25.400022037 +0200
+++ enigma2-nightly.patched/lib/gdi/gfbdc.cpp	2011-09-03 18:23:47.250032923 +0200
@@ -159,13 +159,37 @@
 
 void gFBDC::setResolution(int xres, int yres)
 {
+#if defined(__sh__) 
+	/* if xres and yres are negative call SetMode with the lates xres and yres  
+	 * we need that to read the new screen dimesnions after a resolution change 
+	 * without changing the frambuffer dimensions
+	 */ 
+	if(xres<0 && yres<0 ){ 
+		fb->SetMode(m_xres, m_yres, 32); 
+		return; 
+	} 
+#else 
 	if ((m_xres == xres) && (m_yres == yres))
 		return;
+#endif
 
 	m_xres = xres; m_yres = yres;
 
 	fb->SetMode(m_xres, m_yres, 32);
 
+#if defined(__sh__) 
+	surface.type = 0; 
+	surface.x = m_xres; 
+	surface.y = m_yres; 
+	surface.bpp = 32; 
+	surface.bypp = 4; 
+	surface.stride = m_xres * 4; 
+	surface.data = fb->lfb; 
+	surface.offset = 0;
+
+	for (int y=0; y<m_yres; y++)    // make whole screen transparent 
+		memset(fb->lfb+ y * m_xres * 4, 0x00, m_xres * 4);
+#else 
 	for (int y=0; y<m_yres; y++)	// make whole screen transparent
 		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
 
@@ -177,6 +201,7 @@
 	surface.stride = fb->Stride();
 	surface.data = fb->lfb;
 	surface.offset = 0;
+#endif
 
 	surface.data_phys = fb->getPhysAddr();
 
@@ -199,12 +224,19 @@
 	} else
 		m_enable_double_buffering = 0;
 
+#ifdef __sh__
+	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size - (1920*1080*4))/1024);
+	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
+
+	if (gAccel::getInstance())
+		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size - (1920*1080*4));
+#else
 	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size)/1024);
 	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size);
-
+#endif
 	if (!surface.clut.data)
 	{
 		surface.clut.colors = 256;
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/gpixmap.cpp enigma2-nightly.patched/lib/gdi/gpixmap.cpp
--- enigma2-nightly.org/lib/gdi/gpixmap.cpp	2011-09-03 18:23:25.420022858 +0200
+++ enigma2-nightly.patched/lib/gdi/gpixmap.cpp	2011-09-03 18:23:47.260032928 +0200
@@ -188,6 +188,9 @@
 			else
 				col=0x10101*color;
 			
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys && gAccel::getInstance())
@@ -220,6 +223,9 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 			if (surface->data_phys && gAccel::getInstance())
@@ -377,7 +383,9 @@
 		if (flag & blitScale)
 		{
 			eWarning("unimplemented: scale on non-accel surfaces");
+#if not defined (__sh__) //if accel blit fails, do direkt blit
 			continue;
+#endif
 		}
 
 		if ((surface->bpp == 8) && (src.surface->bpp==8))
@@ -481,6 +489,9 @@
 					pal[i]=(src.surface->clut.data[i].a<<24)|(src.surface->clut.data[i].r<<16)|(src.surface->clut.data[i].g<<8)|(src.surface->clut.data[i].b);
 				else
 					pal[i]=0x010101*i;
+#if defined(__sh__) 
+if((pal[i]&0xFF000000) >= 0xE0000000) pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/grc.cpp enigma2-nightly.patched/lib/gdi/grc.cpp
--- enigma2-nightly.org/lib/gdi/grc.cpp	2011-09-03 18:23:25.430022322 +0200
+++ enigma2-nightly.patched/lib/gdi/grc.cpp	2011-09-03 18:23:47.260032928 +0200
@@ -4,6 +4,11 @@
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 
+#if defined(__sh__)
+#include "include/shmE2.h"
+extern char *shm;
+#endif
+
 #ifndef SYNC_PAINT
 void *gRC::thread_wrapper(void *ptr)
 {
@@ -125,7 +130,12 @@
 				m_compositing->Release();
 			} else if(o.dc)
 			{
+#if defined(__sh__)
+				if(checkshmentry(shm, "stopGUI=") != 1)
+					o.dc->exec(&o);
+#else
 				o.dc->exec(&o);
+#endif
 				// o.dc is a gDC* filled with grabref... so we must release it here
 				o.dc->Release();
 			}
@@ -175,9 +185,19 @@
 
 				if (!idle)
 				{
+#if defined(__sh__)
+					if(checkshmentry(shm, "stopSpinner=") != 1)
+					{
+						if (!m_spinner_enabled)
+							eDebug("main thread is non-idle! display spinner!");
+						enableSpinner();
+					} else
+						disableSpinner();
+#else
 					if (!m_spinner_enabled)
 						eDebug("main thread is non-idle! display spinner!");
 					enableSpinner();
+#endif
 				} else
 					disableSpinner();
 			}
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/Makefile.am enigma2-nightly.patched/lib/gdi/Makefile.am
--- enigma2-nightly.org/lib/gdi/Makefile.am	2011-09-03 18:23:25.340022052 +0200
+++ enigma2-nightly.patched/lib/gdi/Makefile.am	2011-09-03 18:23:47.270034502 +0200
@@ -26,7 +26,8 @@
 	lcd.cpp \
 	picexif.cpp \
 	picload.cpp \
-	region.cpp
+	region.cpp \
+	stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/picload.cpp enigma2-nightly.patched/lib/gdi/picload.cpp
--- enigma2-nightly.org/lib/gdi/picload.cpp	2011-09-03 18:23:25.460022367 +0200
+++ enigma2-nightly.patched/lib/gdi/picload.cpp	2011-09-03 18:23:47.280032953 +0200
@@ -4,6 +4,7 @@
 
 #include <lib/gdi/picload.h>
 #include <lib/gdi/picexif.h>
+#include "../../../misc/tools/libmmeimage/libmmeimage.h"
 
 extern "C" {
 #include <jpeglib.h>
@@ -280,7 +281,11 @@
 		return NULL;
 	}
 
+#if (PNG_LIBPNG_VER < 10500)
 	if (setjmp(png_ptr->jmpbuf))
+#else
+	if (setjmp(png_jmpbuf(png_ptr)))
+#endif
 	{
 		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
 		fclose(fh);
@@ -595,8 +600,46 @@
 
 void ePicLoad::decodePic()
 {
-	eDebug("[Picload] decode picture... %s",m_filepara->file);
+	if(m_filepara->id == F_JPEG)
+	{
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
+
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if(get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+
+			if((m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox) <= m_filepara->max_y)
+			{
+				imx = m_filepara->max_x;
+				imy = (int)(m_conf.aspect_ratio * m_filepara->oy * m_filepara->max_x / m_filepara->ox);
+			}
+			else
+			{
+				imx = (int)((1.0/m_conf.aspect_ratio) * m_filepara->ox * m_filepara->max_y / m_filepara->oy);
+				imy = m_filepara->max_y;
+			}
+			
+			if(decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				return;
+			}
+		}
+		
+		eDebug("hardware decode error");
+		
+		fclose(fp);
+	}
 	
+	eDebug("[Picload] software decode picture... %s",m_filepara->file);
+
 	switch(m_filepara->id)
 	{
 		case F_PNG:	m_filepara->pic_buffer = png_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, &m_filepara->bypp);	break;
@@ -679,13 +722,56 @@
 			}
 		}
 	}
+	int hw_decoded = 0;
+	
+	if(m_filepara->id == F_JPEG)
+	{
+		eDebug("[Picload] hardware decode picture... %s",m_filepara->file);
+		m_filepara->pic_buffer = NULL;
+		FILE *fp;
 
-	switch(m_filepara->id)
+		if (!(fp = fopen(m_filepara->file, "rb")))
+			return; // software decode won't find the file either...
+		
+		if(get_jpeg_img_size(fp, (unsigned int *)&m_filepara->ox, (unsigned int *)&m_filepara->oy) == LIBMMEIMG_SUCCESS)
+		{
+			int imx, imy;
+			if (m_filepara->ox <= m_filepara->oy)
+			{
+				imy = m_conf.thumbnailsize;
+				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+			}
+			else
+			{
+				imx = m_conf.thumbnailsize;
+				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+			}
+			
+			if(decode_jpeg(fp, m_filepara->ox, m_filepara->oy, imx, imy, (char **)&m_filepara->pic_buffer) == LIBMMEIMG_SUCCESS)
+			{
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+				fclose(fp);
+				hw_decoded = 1;
+			}
+		}
+		
+		if(!hw_decoded)
+		{
+			eDebug("hardware decode error");
+		
+			fclose(fp);
+		}
+	}
+	if(!hw_decoded)
 	{
-		case F_PNG:	m_filepara->pic_buffer = png_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, &m_filepara->bypp);	break;
-		case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
-		case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
-		case F_GIF:	m_filepara->pic_buffer = gif_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		switch(m_filepara->id)
+		{
+			case F_PNG:	m_filepara->pic_buffer = png_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy, &m_filepara->bypp);	break;
+			case F_JPEG:	m_filepara->pic_buffer = jpeg_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+			case F_BMP:	m_filepara->pic_buffer = bmp_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+			case F_GIF:	m_filepara->pic_buffer = gif_load(m_filepara->file, &m_filepara->ox, &m_filepara->oy);	break;
+		}
 	}
 	
 	if(exif_thumbnail)
@@ -700,21 +786,25 @@
 				::mkdir(cachedir.c_str(), 0755);
 			
 			//resize for Thumbnail
-			int imx, imy;
-			if (m_filepara->ox <= m_filepara->oy)
+			if(!hw_decoded)
 			{
-				imy = m_conf.thumbnailsize;
-				imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
-			}
-			else
-			{
-				imx = m_conf.thumbnailsize;
-				imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
-			}
+			
+				int imx, imy;
+				if (m_filepara->ox <= m_filepara->oy)
+				{
+					imy = m_conf.thumbnailsize;
+					imx = (int)( (m_conf.thumbnailsize * ((double)m_filepara->ox)) / ((double)m_filepara->oy) );
+				}
+				else
+				{
+					imx = m_conf.thumbnailsize;
+					imy = (int)( (m_conf.thumbnailsize * ((double)m_filepara->oy)) / ((double)m_filepara->ox) );
+				}
 
-			m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy, m_filepara->bypp);
-			m_filepara->ox = imx;
-			m_filepara->oy = imy;
+				m_filepara->pic_buffer = color_resize(m_filepara->pic_buffer, m_filepara->ox, m_filepara->oy, imx, imy, m_filepara->bypp);
+				m_filepara->ox = imx;
+				m_filepara->oy = imy;
+			}
 
 			if(jpeg_save(cachefile.c_str(), m_filepara->ox, m_filepara->oy, m_filepara->pic_buffer))
 				eDebug("[Picload] error saving cachefile");
@@ -1069,3 +1159,65 @@
 
 	return 0;
 }
+
+#if defined(__sh__)
+//---------------------------------------------------------------------------------------------
+
+PyObject *getExif(const char *filename)
+{
+	ePyObject list;
+	Cexif exif;
+	if(exif.DecodeExif(filename))
+	{
+		if(exif.m_exifinfo->IsExif)
+		{
+			int pos=0;
+			char tmp[256];
+			list = PyList_New(22);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Version));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraMake));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->CameraModel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->DateTime));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Comments));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d x %d", exif.m_exifinfo->Width, exif.m_exifinfo->Height));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->Orientation));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->MeteringMode));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ExposureProgram));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->LightSource));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->FlashUsed));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->CompressionLevel));
+			PyList_SET_ITEM(list, pos++,  PyString_FromFormat("%d", exif.m_exifinfo->ISOequivalent));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Xresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Yresolution);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(exif.m_exifinfo->ResolutionUnit));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->Brightness);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f sec.", exif.m_exifinfo->ExposureTime);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->ExposureBias);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->Distance);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.5f", exif.m_exifinfo->CCDWidth);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+			sprintf(tmp, "%.2f", exif.m_exifinfo->ApertureFNumber);
+			PyList_SET_ITEM(list, pos++,  PyString_FromString(tmp));
+		}
+		else
+		{
+			list = PyList_New(1);
+			PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+		}
+		exif.ClearExif();
+	}
+	else
+	{
+		list = PyList_New(1);
+		PyList_SET_ITEM(list, 0, PyString_FromString(exif.m_szLastError));
+	}
+
+	return list ? (PyObject*)list : (PyObject*)PyList_New(0);
+}
+#endif
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/gdi/stmfb.cpp enigma2-nightly.patched/lib/gdi/stmfb.cpp
--- enigma2-nightly.org/lib/gdi/stmfb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/gdi/stmfb.cpp	2011-09-03 18:23:47.280032953 +0200
@@ -0,0 +1,77 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+ bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+ bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Harddisk.py enigma2-nightly.patched/lib/python/Components/Harddisk.py
--- enigma2-nightly.org/lib/python/Components/Harddisk.py	2011-09-03 18:23:25.810022128 +0200
+++ enigma2-nightly.patched/lib/python/Components/Harddisk.py	2011-09-03 18:23:47.290032918 +0200
@@ -1,9 +1,26 @@
-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
-from Tools.Directories import SCOPE_HDD, resolveFilename
+#--->
+#-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
+#-from Tools.Directories import SCOPE_HDD, resolveFilename
+#---<
+#+++>
+from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access, readlink, remove, path as os_path
+from Tools.Directories import SCOPE_HDD, resolveFilename, removeDir
+#+++<
 from Tools.CList import CList
 from SystemInfo import SystemInfo
 import time
 from Components.Console import Console
+#+++>
+from enigma import eConsoleAppContainer, evfd
+import os
+
+def tryOpen(filename):
+	try:
+		procFile = open(filename)
+	except IOError:
+		return ""
+	return procFile
+#+++<
 
 def MajorMinor(path):
 	rdev = stat(path).st_rdev
@@ -17,7 +34,7 @@
 
 DEVTYPE_UDEV = 0
 DEVTYPE_DEVFS = 1
-
+	
 class Harddisk:
 	def __init__(self, device):
 		self.device = device
@@ -181,7 +198,12 @@
                                 continue                                                                    
                         try:                                                                                
                                 if MajorMinor(real_path) == MajorMinor(self.partitionPath(real_path[-1])):
-					cmd = ' ' . join([cmd, parts[1]])
+#--->			
+#-					cmd = ' ' . join([cmd, parts[1]])
+#---<
+#+++>
+					cmd = ' -fl ' . join([cmd, parts[1]])
+#+++<
 					break
 			except OSError:
 				pass
@@ -190,7 +212,7 @@
 		return (res >> 8)
 
 	def createPartition(self):
-		cmd = 'printf "8,\n;0,0\n;0,0\n;0,0\ny\n" | sfdisk -f -uS ' + self.disk_path
+		cmd = 'echo "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
 		res = system(cmd)
 		return (res >> 8)
 
@@ -199,7 +221,18 @@
 		if self.diskSize() > 4 * 1024:
 			cmd += "-T largefile "
 		cmd += "-m0 -O dir_index " + self.partitionPath("1")
-		res = system(cmd)
+#--->
+#-		res = system(cmd)
+#---<
+#+++>
+		print "[Harddisk] mkfs: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
 	def mount(self):
@@ -238,7 +271,18 @@
 		# We autocorrect any failures
 		# TODO: we could check if the fs is actually ext3
 		cmd = "fsck.ext3 -f -p " + self.partitionPath("1")
-		res = system(cmd)
+#--->
+#-		res = system(cmd)
+#---<
+#+++>		
+		print "[Harddisk] fsck: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
 	def killPartition(self, n):
@@ -429,14 +473,11 @@
 	}
 
 DEVICEDB = \
-	{"dm8000":
+	{"ufs910":
 		{
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": _("Front USB Slot"),
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.2/1-1.2:1.0": _("Back, upper USB Slot"),
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.3/1-1.3:1.0": _("Back, lower USB Slot"),
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": _("Front USB Slot"),
-			"/devices/platform/brcm-ehci-1.1/usb2/2-1/2-1:1.0/": _("Internal USB Slot"),
-			"/devices/platform/brcm-ohci-1.1/usb4/4-1/4-1:1.0/": _("Internal USB Slot"),
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.4/1-1.4:1.0": "Front USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0": "Back, upper USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0": "Back, lower USB Slot",
 		},
 	"dm800":
 	{
@@ -446,7 +487,13 @@
 	"dm7025":
 	{
 		"/devices/pci0000:00/0000:00:14.1/ide1/1.0": "CF Card Slot", #hdc
-		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk"
+		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk",
+	},
+	"UFS922":
+	{
+		"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.1/1-1.1:1.0/": "Back, upper USB Slot",
+		"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0/": "Back, lower USB Slot",
+		"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0/": "Front USB Slot",
 	}
 	}
 
@@ -489,7 +536,12 @@
 		try:
 			removable = bool(int(readFile(devpath + "/removable")))
 			dev = int(readFile(devpath + "/dev").split(':')[0])
-			if dev in (7, 31): # loop, mtdblock
+#--->
+#-			if dev in (7, 31): # loop, mtdblock
+#---<
+#+++>
+			if dev in [1, 7, 31, 253]: # ram, loop, mtdblock, ramzswap
+#+++<
 				blacklisted = True
 			if blockdev[0:2] == 'sr':
 				is_cdrom = True
@@ -548,6 +600,13 @@
 			except OSError:
 				physdev = dev
 				print "couldn't determine blockdev physdev for device", device
+#+++>		
+		else:
+			dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start automount"
+			#Automount(device,"mount")
+#+++<		
 
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		print "found block device '%s':" % device,
@@ -594,6 +653,12 @@
 					self.hdd.remove(hdd)
 					break
 			SystemInfo["Harddisk"] = len(self.hdd) > 0
+#+++>
+		dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start auto umount"
+			#Automount(device,"umount")
+#+++<
 
 	def HDDCount(self):
 		return len(self.hdd)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/NimManager.py enigma2-nightly.patched/lib/python/Components/NimManager.py
--- enigma2-nightly.org/lib/python/Components/NimManager.py	2011-09-03 18:23:25.860022078 +0200
+++ enigma2-nightly.patched/lib/python/Components/NimManager.py	2011-09-03 18:23:47.300033012 +0200
@@ -20,6 +20,10 @@
 import xml.etree.cElementTree
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/Renderer/Progress.py enigma2-nightly.patched/lib/python/Components/Renderer/Progress.py
--- enigma2-nightly.org/lib/python/Components/Renderer/Progress.py	2011-09-03 18:23:25.950023578 +0200
+++ enigma2-nightly.patched/lib/python/Components/Renderer/Progress.py	2011-09-03 18:23:47.310033093 +0200
@@ -13,26 +13,60 @@
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
-
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+#--->
+#-		if what[0] == self.CHANGED_CLEAR:
+#-			(self.range, self.value) = ((0, 1), 0)
+#-			return
+#-
+#-		range = self.source.range or 100
+#-		value = self.source.value
+#-		if value is None:
+#-			value = 0
+#-		(self.range, self.value) = ((0, range), value)
+#---<
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
+
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	GUI_WIDGET = eSlider
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
-
+#--->
+#-		instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
-
+#--->
+#-		(self.__start, self.__end) = range
+#-		if self.instance is not None:
+#-			self.instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def getRange(self):
 		return (self.__start, self.__end)
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/TunerInfo.py enigma2-nightly.patched/lib/python/Components/TunerInfo.py
--- enigma2-nightly.org/lib/python/Components/TunerInfo.py	2011-09-03 18:23:26.060022097 +0200
+++ enigma2-nightly.patched/lib/python/Components/TunerInfo.py	2011-09-03 18:23:47.310033093 +0200
@@ -60,8 +60,17 @@
 			value = self.getValue(self.LOCK)
 
 		if self.type == self.SNR_DB:
-			if value != 0x12345678:
-				self.setText("%3.02f dB" % (value / 100.0))
+#--->   CAUSE OF CRASH!
+#-			if value != 0x12345678:
+#-				self.setText("%3.02f dB" % (value / 100.0))
+#---<
+#+++>   CAUSE OF CRASH!
+			if value is not None:
+				if value != 0x12345678:
+					self.setText("%3.02f dB" % (value / 100.0))
+				else:
+					self.setText("")
+#+++>   CAUSE OF CRASH!		
 			else:
 				self.setText("")
 		elif self.type == self.SNR_PERCENTAGE or self.type == self.AGC_PERCENTAGE:
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Components/VolumeControl.py enigma2-nightly.patched/lib/python/Components/VolumeControl.py
--- enigma2-nightly.org/lib/python/Components/VolumeControl.py	2011-09-03 18:23:26.080022078 +0200
+++ enigma2-nightly.patched/lib/python/Components/VolumeControl.py	2011-09-03 18:23:47.320033093 +0200
@@ -71,13 +71,27 @@
 		self.volumeDialog.hide()
 
 	def volMute(self, showMuteSymbol=True, force=False):
-		vol = self.volctrl.getVolume()
+#--->
+#-		vol = self.volctrl.getVolume()
+#---<
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/enigma_python.i enigma2-nightly.patched/lib/python/enigma_python.i
--- enigma2-nightly.org/lib/python/enigma_python.i	2011-09-03 18:23:27.910023398 +0200
+++ enigma2-nightly.patched/lib/python/enigma_python.i	2011-09-03 18:23:47.320033093 +0200
@@ -99,6 +99,7 @@
 #include <lib/dvb_ci/dvbci_ui.h>
 #include <lib/python/python.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -216,6 +217,7 @@
 %include <lib/dvb/db.h>
 %include <lib/python/python.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h> 
 /**************  eptr  **************/
 
 /**************  signals  **************/
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Makefile.am enigma2-nightly.patched/lib/python/Makefile.am
--- enigma2-nightly.org/lib/python/Makefile.am	2011-09-03 18:23:26.100022393 +0200
+++ enigma2-nightly.patched/lib/python/Makefile.am	2011-09-03 18:23:47.330033302 +0200
@@ -30,7 +30,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)$(PYTHON) $(srcdir)/enigma_py_patcher.py
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	2011-09-03 18:23:47.340033053 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	2011-09-03 18:23:47.340033053 +0200
@@ -0,0 +1,7 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	2011-10-07 19:51:24.620979351 +0200
@@ -0,0 +1,355 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+#---- Civer start ----#
+#- from enigma import iPlayableService, eServiceCenter, iServiceInformation
+#- from enigma import evfd
+from enigma import *
+#----- Civer end ----#
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+
+import os
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+#config.plugins.CuberevoVFD.setDaylight = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.timeMode = ConfigSelection(default = "24h", choices = [("12h"),("24h")])
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+		
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+#		self.list.append(getConfigListEntry(_("Daylight"), config.plugins.CuberevoVFD.setDaylight))
+		self.list.append(getConfigListEntry(_("Time mode"), config.plugins.CuberevoVFD.timeMode))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+		self["key_red"] = Button(_("Cancel"))
+		self["key_green"] = Button(_("Save"))
+
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+#		if config.plugins.CuberevoVFD.setDaylight.getValue():
+#			cubeVfd.enableDaylight()
+#		else:
+#			cubeVfd.disableDaylight()
+
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			cubeVfd.enableTimeMode()
+		else:
+			cubeVfd.disableTimeMode()
+
+		# enable/disable fan activity
+		if config.plugins.CuberevoVFD.setFan.getValue():
+			cubeVfd.enableFan()
+		else:
+			cubeVfd.disableFan()
+
+		# enable/disable led activity
+		if config.plugins.CuberevoVFD.setLed.getValue():
+			cubeVfd.enableLed()
+		else:
+			cubeVfd.disableLed()
+
+	# set the brightness
+		brightness = 3
+		if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+			brightness = 1
+		elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+			brightness = 7
+		evfd.getInstance().vfd_set_brightness(brightness)
+
+		configfile.save()
+
+		self.close()
+
+	def cancel(self):
+		for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+#---- CIVER start ----#
+		global showmenuorpanel
+		showmenuorpanel = False
+		self.showtimer = eTimer()
+#---- CIVER end ----#
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		self.Console = Console()
+		self.tsEnabled = False
+#---- CIVER start ----#
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+#---- CIVER end ----#
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+#		self.daylightEnabled = config.plugins.CuberevoVFD.setDaylight.getValue()
+		if config.plugins.CuberevoVFD.timeMode.value == "24h":
+			self.timeModeEnabled = 1
+		else:
+			self.timeModeEnabled = 0
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+
+#---- CIVER start---workaround to show servicename again after menues ----#
+	def handleTimer(self):
+		global showmenuorpanel
+		try:
+			from Plugins.Extensions.Aafpanel.plugin import inAAFPanel
+			showPanel = inAAFPanel
+		except:
+			#print '[CuberevoVFD] Error showPanel'
+			showPanel = None
+		try:
+			from Screens.Menu import inMenu
+			showMenu = inMenu
+		except:
+			#print '[CuberevoVFD] Error showMenu'
+			showMenu = None
+		if showMenu or showPanel:
+			self.showtimer.start(4000, True)
+		self.showtimer.callback.append(self.setshowmenuorpanel)
+		if not showMenu and not showPanel and showmenuorpanel is True:
+			showmenuorpanel = False
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename =subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+				evfd.getInstance().vfd_write_string(servicename[0:17])
+
+	def setshowmenuorpanel(self):
+		global showmenuorpanel
+		showmenuorpanel = True
+		self.showtimer.stop()
+#---- CIVER end ----#
+
+	def enableClock(self):
+		self.clockEnabled = True
+		try:
+			os.popen("/bin/fp_control -dt 1")
+		except OSError:
+			print "no memory"
+
+	def disableClock(self):
+		self.clockEnabled = False
+		try:
+			os.popen("/bin/fp_control -dt 0")
+		except OSError:
+			print "no memory"
+
+	def enableTimeMode(self):
+		self.timeModeEnabled = 1
+		try:
+			os.popen("/bin/fp_control -tm 1")
+		except OSError:
+			print "no memory"
+
+	def disableTimeMode(self):
+		self.timeModeEnabled = 0
+		try:
+			os.popen("/bin/fp_control -tm 0")
+		except OSError:
+			print "no memory"
+
+# konfetti: what that?
+#	def enableDaylight(self):
+#		self.daylightEnabled = True
+#		try:
+#			os.popen("/bin/cubefpctl --setdaylight 1")
+#		except OSError:
+#			print "no memory"
+#		try:
+#			os.popen("/bin/cubefpctl --syncfptime")
+#		except OSError:
+#			print "no memory"
+
+#	def disableDaylight(self):
+#		self.daylightEnabled = False
+#		try:
+#			os.popen("/bin/cubefpctl --setdaylight 0")
+#		except OSError:
+#			print "no memory"
+#		try:
+#			os.popen("/bin/cubefpctl --syncfptime")
+#		except OSError:
+#			print "no memory"
+
+	def enableLed(self):
+		self.ledEnabled = True
+		try:
+			os.popen("/bin/fp_control -l 0 1")
+		except OSError:
+			print "no memory"
+
+	def disableLed(self):
+		self.ledEnabled = False
+		try:
+			os.popen("/bin/fp_control -l 0 0")
+		except OSError:
+			print "no memory"
+
+	def enableFan(self):
+		self.fanEnabled = True
+		try:
+			os.popen("/bin/fp_control -sf 1")
+		except OSError:
+			print "no memory"
+
+	def disableFan(self):
+		self.fanEnabled = False
+		try:
+			os.popen("/bin/fp_control -sf 0")
+		except OSError:
+			print "no memory"
+
+	def regExpMatch(self, pattern, string):
+		if string is None:
+			return None
+		try:
+			return pattern.search(string).group()
+		except AttributeError:
+			None
+	
+	def __evStart(self):
+		self.__evSeekableStatusChanged()
+	
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+			return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+		tmp = self.getTimeshiftState()
+		if tmp == self.tsEnabled:
+			return
+		if tmp:
+			print "[Timeshift enabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,True)
+		else:
+			print "[Timeshift disabled]"
+			evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+		global my_global_session
+		mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am	2011-09-03 18:23:26.480022162 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/Makefile.am	2011-09-03 18:23:47.350032808 +0200
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn Modem
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
+ 
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	2011-09-03 18:23:47.350032808 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	2011-09-03 18:23:47.350032808 +0200
@@ -0,0 +1,7 @@
+installdir = $(pkglibdir)/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	2011-09-03 18:23:47.360032932 +0200
@@ -0,0 +1,464 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+from Components.UsageConfig import defaultMoviePath
+from os import statvfs
+import array
+
+my_global_session = None
+debug = False
+
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 10, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioBootReason = 0x40003a0b
+ioOffFlush = struct.pack('LLB', 0x2, 0x0, 0x6)
+ioRec1Flush = struct.pack('LLB', 0x1000, 0x0, 0x6)
+ioRec2Flush = struct.pack('LLB', 0x2000, 0x0, 0x6)
+ioRecBothFlush = struct.pack('LLB', 0x3000, 0x0, 0x6)
+ioClockFlush = struct.pack('LLB', 0x20, 0x0, 0x6)
+ioClockOff = struct.pack('LLB', 0x20, 0x0, 0x0)
+ioHddClear =    struct.pack('LLB', 0x0, 0xff8000,0x0)
+ioHddUsage = (  struct.pack('LLB', 0x0, 0x006000,0xf),  # HDD empty
+                struct.pack('LLB', 0x0, 0x00e000,0xf),
+                struct.pack('LLB', 0x0, 0x01e000,0xf),
+                struct.pack('LLB', 0x0, 0x03e000,0xf),
+                struct.pack('LLB', 0x0, 0x07e000,0xf),
+                struct.pack('LLB', 0x0, 0x0fe000,0xf),
+                struct.pack('LLB', 0x0, 0x1fe000,0xf),
+                struct.pack('LLB', 0x0, 0x3fe000,0xf),
+                struct.pack('LLB', 0x0, 0x7fe000,0xf))  # HDD full
+ioHddFull = struct.pack('LLB', 0x0, 0x800000,0x6)       # "HDD full" flashing
+hddCheckPeriod = 60 # check every 60 seconds
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+        skin = """
+                <screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+                <widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+                <ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+                <ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+                <widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+                <widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+                </screen>"""
+
+
+        def __init__(self, session, args = None):
+                Screen.__init__(self, session)
+                self.onClose.append(self.abort)
+
+                # create elements for the menu list
+                self.list = [ ]
+                self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+                self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+                self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+                self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+                self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+                self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+                self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+                self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+                self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+                self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+                ConfigListScreen.__init__(self, self.list)
+
+                self.Console = Console()
+                self["key_red"] = Button(_("Cancel"))
+                self["key_green"] = Button(_("Save"))
+
+                # DO NOT ASK.
+                self["setupActions"] = ActionMap(["SetupActions"],
+                {
+                        "save": self.save,
+                        "cancel": self.cancel,
+                        "ok": self.save,
+                }, -2)
+
+        def abort(self):
+                print "aborting"
+
+        def save(self):
+                # save all settings
+                for x in self["config"].list:
+                        x[1].save()
+                tfVfd.setValues()
+                self.close()
+
+        def cancel(self):
+                for x in self["config"].list:
+                        x[1].cancel()
+                self.close()
+
+
+class TopfieldVFD:
+        def __init__(self, session):
+                #print "TopfieldVFD initializing"
+                self.session = session
+                self.service = None
+                self.onClose = [ ]
+                self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+                        {
+                                iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+                                iPlayableService.evStart: self.__evStart,
+                        })
+                session.nav.record_event.append(self.gotRecordEvent)
+                self.Console = Console()
+                self.tsEnabled = False
+                self.recNum = 0
+                self.timer = eTimer()
+                self.timer.callback.append(self.handleTimer)
+                self.timer.start(1000, False)
+                self.txCount = 0
+                self.clock = 0
+                self.valuesSet = 0
+                self.hddUsed = 10 # initialize with an invalid value
+                self.hddCheckCounter = hddCheckPeriod
+                self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+                self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+                self.setValues()
+
+        def setValues(self):
+                #print "\nTopfiledVFD.setValues()\n"
+                if config.plugins.TopfieldVFD.showClock.value:
+                        self.enableClock()
+                else:
+                        self.disableClock()
+
+                # enable/disable displaying Ethernet activity
+                if config.plugins.TopfieldVFD.showEthernet.getValue():
+                        self.enableEthernet()
+                else:
+                        self.disableEthernet()
+
+                try:
+                        fd = open("/dev/fpc")
+
+                        # set the brightness
+                        brightness = 3
+                        if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+                                brightness = 1
+                        elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+                                brightness = 5
+                        fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+
+                        # set the the scroll mode
+                        if config.plugins.TopfieldVFD.scroll.value == "once":
+                                scrollMode = 1
+                        elif config.plugins.TopfieldVFD.scroll.value == "always":
+                                scrollMode = 2
+                        else: # set to never by default
+                                scrollMode = 0
+                        scrollOpts = struct.pack('BBB', scrollMode,
+                                                int(config.plugins.TopfieldVFD.scrollPause.value),
+                                                int(config.plugins.TopfieldVFD.scrollDelay.value))
+                        fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+
+                        # set the typematic values
+                        tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+                        fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+                        tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+                        fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+
+                        # set the IR filters
+                        if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+                        elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+                        else: # enable both by default
+                                fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+                                fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+                        # set the allcaps parameter
+                        if config.plugins.TopfieldVFD.allCaps.value:
+                                fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+                        else:
+                                fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+#---- Topfi start ----#
+                        buf = array.array('h', [0])
+                        fcntl.ioctl(fd.fileno(),ioBootReason,buf,1)
+                        if buf[0] == 2:
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioOffFlush)
+#---- Topfi end ----#
+
+                        fd.close()
+                        self.valuesSet = 1
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: setValues ", e
+
+        def enableEthernet(self):
+                self.ethEnabled = True
+
+        def disableEthernet(self):
+                self.ethEnabled = False
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: disableEthernet ", e
+
+        def enableClock(self):
+                self.clockEnabled = True
+                self.clock = " "
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: enableClock ", e
+
+        def disableClock(self):
+                self.clockEnabled = False
+                self.clock = " "
+                try:
+                        fd = open("/dev/fpc")
+                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+                        fd.close()
+                        open("/dev/fpsmall", "w").write("     ")
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: disableClock ", e
+
+        def regExpMatch(self, pattern, string):
+                if string is None:
+                        return None
+                try:
+                        return pattern.search(string).group()
+                except AttributeError:
+                        None
+
+        def displayHddUsed(self):
+
+                if debug:
+                        print "TopfieldVFD: determine HDD usage"
+
+                # determine the HDD usage
+                used = 0;
+                try:
+                        f = statvfs(defaultMoviePath())
+                        # there are 8 HDD segments in the VFD
+                        used = (f.f_blocks - f.f_bavail) * 8 / f.f_blocks
+                except:
+                        used = 0;
+
+                if self.hddUsed != used:
+                        try:
+                                fd = open("/dev/fpc")
+                                if self.hddUsed > used:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddClear)
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddUsage[used])
+                                if used == 8:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioHddFull)
+                                fd.close();
+                        except IOError,e:
+                                self.hddUsed = used # dummy operation
+                        self.hddUsed = used
+
+        def handleTimer(self):
+                #print "[ TopfieldVFD timer ]"
+                if self.valuesSet == 0:
+                        self.setValues()
+
+                if self.clockEnabled:
+                        clock = strftime("%k%M",localtime(time()))
+                        if clock != self.clock:
+                                self.clock = clock
+                                try:
+                                        open("/dev/fpsmall", "w").write(clock + "\0")
+                                except IOError,e:
+                                        if debug:
+                                                print "TopfieldVFD: handleTimer (clock) ", e
+
+                # check HDD periodically
+                if self.hddCheckCounter < hddCheckPeriod:
+                        self.hddCheckCounter += 1
+                else:
+                        self.hddCheckCounter = 0
+                        self.displayHddUsed()
+
+                if self.ethEnabled == False:
+                        return
+
+                result = open("/proc/net/dev").readlines()
+                numRegExp = "[0-9]+"
+                numPattern = re_compile(numRegExp)
+                txPattern = re_compile("eth0:[ ]*" + numRegExp)
+                for item in result:
+                        tmp = self.regExpMatch(txPattern, item)
+                        if tmp != None:
+                                tmp = tmp[5:].lstrip()
+                                try:
+                                        fd = open("/dev/fpc")
+                                        if self.txCount != tmp:
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+                                                self.txCount = tmp
+                                        else:
+                                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+                                        fd.close()
+                                except IOError,e:
+                                        if debug:
+                                                print "TopfieldVFD: handleTimer (Ethernet) ", e
+                                break
+
+        def __evStart(self):
+                self.__evSeekableStatusChanged()
+
+        def getTimeshiftState(self):
+                service = self.session.nav.getCurrentService()
+                if service is None:
+                        return False
+                timeshift = service.timeshift()
+                if timeshift is None:
+                        return False
+                return True
+
+        def __evSeekableStatusChanged(self):
+                tmp = self.getTimeshiftState()
+                if tmp == self.tsEnabled:
+                        return
+                try:
+                        fd = open("/dev/fpc")
+                        if tmp:
+                                print "[Timeshift enabled]"
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+                        else:
+                                print "[Timeshift disabled]"
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: __evSeekableStatusChanged ", e
+                self.tsEnabled = tmp
+
+        def gotRecordEvent(self, service, event):
+                recs = self.session.nav.getRecordings()
+                nrecs = len(recs)
+                if nrecs == self.recNum:
+                        return
+                try:
+                        fd = open("/dev/fpc")
+                        if config.usage.blinking_display_clock_during_recording.value:
+                                if nrecs > 1: # set rec 1+2 symbols
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothFlush)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+                                elif nrecs > 0: # set rec 1 symbol
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockFlush)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1Flush)
+                                else:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                        else:
+                                fcntl.ioctl(fd.fileno(), ioIconCmd, ioClockOff)
+                                if nrecs > 1: # set rec 1+2 symbols
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+                                elif nrecs > 0: # set rec 1 symbol
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+                                else:
+                                        fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+
+                        fd.close()
+                except IOError,e:
+                        if debug:
+                                print "TopfieldVFD: gotRecordEvent ", e
+                self.recNum = nrecs
+
+        def shutdown(self):
+                self.abort()
+
+        def abort(self):
+                print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+        session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+        global tfVfd
+        global gReason
+        global mySession
+
+        if gReason == 0 and mySession != None and tfVfd == None:
+                print "Starting TopfieldVFD"
+                tfVfd = TopfieldVFD(mySession)
+        elif gReason == 1 and tfVfd != None:
+                print "Stopping TopfieldVFD"
+                tfVfd.disableClock()
+                tfVfd = None
+
+def autostart(reason, **kwargs):
+        global tfVfd
+        global gReason
+        global mySession
+
+        if kwargs.has_key("session"):
+                global my_global_session
+                mySession = kwargs["session"]
+        else:
+                gReason = reason
+        controlTfVfd()
+
+def Plugins(**kwargs):
+        return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+                PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/Makefile.am enigma2-nightly.patched/lib/python/Plugins/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Makefile.am	2011-09-03 18:23:26.680022978 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/Makefile.am	2011-09-03 18:23:47.360032932 +0200
@@ -1,6 +1,6 @@
 installdir = $(pkglibdir)/python/Plugins
 
-SUBDIRS = Extensions SystemPlugins DemoPlugins
+SUBDIRS = Extensions SystemPlugins
 
 install_PYTHON =	\
 	__init__.py Plugin.py 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/plugin.py	2011-09-03 18:23:26.830022718 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/CrashlogAutoSubmit/plugin.py	2011-09-03 18:23:47.370033968 +0200
@@ -8,13 +8,20 @@
 from Screens.VirtualKeyBoard import VirtualKeyBoard
 from Screens.ChoiceBox import ChoiceBox
 from Screens.MessageBox import MessageBox
-from enigma import ePoint, eTPM
+#--->
+#- from enigma import ePoint, eTPM
+#---<
+#+++>
+from enigma import ePoint
+#+++<
 from Tools import Notifications
 
 import os
 from twisted.mail import smtp, relaymanager
 import MimeWriter, mimetools, StringIO
-from __init__ import bin2long, long2bin, rsa_pub1024, decrypt_block, validate_cert, read_random
+#--->
+#- from __init__ import bin2long, long2bin, rsa_pub1024, decrypt_block, validate_cert, read_random
+#---<
 
 config.plugins.crashlogautosubmit = ConfigSubsection()
 config.plugins.crashlogautosubmit.sendmail = ConfigSelection(default = "send", choices = [
@@ -377,31 +384,37 @@
 
 def autostart(reason, **kwargs):
 	print "[CrashlogAutoSubmit] - autostart"
-	try:
-		device = open("/proc/stb/info/model", "r").readline().strip()
-	except:
-		device = ""	
-	if device != "dm7025":
-		rootkey = ['\x9f', '|', '\xe4', 'G', '\xc9', '\xb4', '\xf4', '#', '&', '\xce', '\xb3', '\xfe', '\xda', '\xc9', 'U', '`', '\xd8', '\x8c', 's', 'o', '\x90', '\x9b', '\\', 'b', '\xc0', '\x89', '\xd1', '\x8c', '\x9e', 'J', 'T', '\xc5', 'X', '\xa1', '\xb8', '\x13', '5', 'E', '\x02', '\xc9', '\xb2', '\xe6', 't', '\x89', '\xde', '\xcd', '\x9d', '\x11', '\xdd', '\xc7', '\xf4', '\xe4', '\xe4', '\xbc', '\xdb', '\x9c', '\xea', '}', '\xad', '\xda', 't', 'r', '\x9b', '\xdc', '\xbc', '\x18', '3', '\xe7', '\xaf', '|', '\xae', '\x0c', '\xe3', '\xb5', '\x84', '\x8d', '\r', '\x8d', '\x9d', '2', '\xd0', '\xce', '\xd5', 'q', '\t', '\x84', 'c', '\xa8', ')', '\x99', '\xdc', '<', '"', 'x', '\xe8', '\x87', '\x8f', '\x02', ';', 'S', 'm', '\xd5', '\xf0', '\xa3', '_', '\xb7', 'T', '\t', '\xde', '\xa7', '\xf1', '\xc9', '\xae', '\x8a', '\xd7', '\xd2', '\xcf', '\xb2', '.', '\x13', '\xfb', '\xac', 'j', '\xdf', '\xb1', '\x1d', ':', '?']
-		etpm = eTPM()
-		l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
-		if l2cert is None:
-			return
-		l2key = validate_cert(l2cert, rootkey)
-		if l2key is None:
-			return
-		l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
-		if l3cert is None:
-			return
-		l3key = validate_cert(l3cert, l2key)
-		if l3key is None:
-			return
-		rnd = read_random()
-		if rnd is None:
-			return
-		val = etpm.challenge(rnd)
-		result = decrypt_block(val, l3key)
-	if device == "dm7025" or result[80:88] == rnd:
+#--->
+#- 	try:
+#- 		device = open("/proc/stb/info/model", "r").readline().strip()
+#- 	except:
+#- 		device = ""	
+#- 	if device != "dm7025":
+#- 		rootkey = ['\x9f', '|', '\xe4', 'G', '\xc9', '\xb4', '\xf4', '#', '&', '\xce', '\xb3', '\xfe', '\xda', '\xc9', 'U', '`', '\xd8', '\x8c', 's', 'o', '\x90', '\x9b', '\\', 'b', '\xc0', '\x89', '\xd1', '\x8c', '\x9e', 'J', 'T', '\xc5', 'X', '\xa1', '\xb8', '\x13', '5', 'E', '\x02', '\xc9', '\xb2', '\xe6', 't', '\x89', '\xde', '\xcd', '\x9d', '\x11', '\xdd', '\xc7', '\xf4', '\xe4', '\xe4', '\xbc', '\xdb', '\x9c', '\xea', '}', '\xad', '\xda', 't', 'r', '\x9b', '\xdc', '\xbc', '\x18', '3', '\xe7', '\xaf', '|', '\xae', '\x0c', '\xe3', '\xb5', '\x84', '\x8d', '\r', '\x8d', '\x9d', '2', '\xd0', '\xce', '\xd5', 'q', '\t', '\x84', 'c', '\xa8', ')', '\x99', '\xdc', '<', '"', 'x', '\xe8', '\x87', '\x8f', '\x02', ';', 'S', 'm', '\xd5', '\xf0', '\xa3', '_', '\xb7', 'T', '\t', '\xde', '\xa7', '\xf1', '\xc9', '\xae', '\x8a', '\xd7', '\xd2', '\xcf', '\xb2', '.', '\x13', '\xfb', '\xac', 'j', '\xdf', '\xb1', '\x1d', ':', '?']
+#- 		etpm = eTPM()
+#- 		l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
+#- 		if l2cert is None:
+#- 			return
+#- 		l2key = validate_cert(l2cert, rootkey)
+#- 		if l2key is None:
+#- 			return
+#- 		l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
+#- 		if l3cert is None:
+#- 			return
+#- 		l3key = validate_cert(l3cert, l2key)
+#- 		if l3key is None:
+#- 			return
+#- 		rnd = read_random()
+#- 		if rnd is None:
+#- 			return
+#- 		val = etpm.challenge(rnd)
+#- 		result = decrypt_block(val, l3key)
+#-	if device == "dm7025" or result[80:88] == rnd:
+#---<
+#+++> hack my day
+	device = "dm7025"
+#+++<
+	if True:
 		if "session" in kwargs:
 			try:
 				startMailer(kwargs["session"])
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am	2011-09-03 18:23:26.930022982 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Makefile.am	2011-09-03 18:23:47.380033063 +0200
@@ -1,10 +1,10 @@
 installdir = $(pkglibdir)/python/Plugins/SystemPlugins
 
-SUBDIRS = SoftwareManager FrontprocessorUpgrade PositionerSetup Satfinder \
+SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner NFIFlash DiseqcTester CommonInterfaceAssignment \
-	CrashlogAutoSubmit CleanupWizard VideoEnhancement WirelessLan NetworkWizard \
-	TempFanControl
+	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	CrashlogAutoSubmit CleanupWizard VideoEnhancement NetworkWizard \
+	TempFanControl VFD-Icons Tuxtxt
 
 install_PYTHON =	\
 	__init__.py
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py	2011-09-03 18:23:27.250023288 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/SoftwareManager/SoftwareTools.py	2011-09-03 18:23:47.380033063 +0200
@@ -1,5 +1,11 @@
 # -*- coding: iso-8859-1 -*-
-from enigma import eConsoleAppContainer,eTPM
+# -*- coding: iso-8859-1 -*-
+#--->
+#- from enigma import eConsoleAppContainer,eTPM
+#---<
+#+++>
+from enigma import eConsoleAppContainer
+#+++<
 from Components.Console import Console
 from Components.About import about
 from Components.DreamInfoHandler import DreamInfoHandler
@@ -13,48 +19,48 @@
 from time import time
 from os import urandom
 
-rootkey = ['\x9f', '|', '\xe4', 'G', '\xc9', '\xb4', '\xf4', '#', '&', '\xce', '\xb3', '\xfe', '\xda', '\xc9', 'U', '`', '\xd8', '\x8c', 's', 'o', '\x90', '\x9b', '\\', 'b', '\xc0', '\x89', '\xd1', '\x8c', '\x9e', 'J', 'T', '\xc5', 'X', '\xa1', '\xb8', '\x13', '5', 'E', '\x02', '\xc9', '\xb2', '\xe6', 't', '\x89', '\xde', '\xcd', '\x9d', '\x11', '\xdd', '\xc7', '\xf4', '\xe4', '\xe4', '\xbc', '\xdb', '\x9c', '\xea', '}', '\xad', '\xda', 't', 'r', '\x9b', '\xdc', '\xbc', '\x18', '3', '\xe7', '\xaf', '|', '\xae', '\x0c', '\xe3', '\xb5', '\x84', '\x8d', '\r', '\x8d', '\x9d', '2', '\xd0', '\xce', '\xd5', 'q', '\t', '\x84', 'c', '\xa8', ')', '\x99', '\xdc', '<', '"', 'x', '\xe8', '\x87', '\x8f', '\x02', ';', 'S', 'm', '\xd5', '\xf0', '\xa3', '_', '\xb7', 'T', '\t', '\xde', '\xa7', '\xf1', '\xc9', '\xae', '\x8a', '\xd7', '\xd2', '\xcf', '\xb2', '.', '\x13', '\xfb', '\xac', 'j', '\xdf', '\xb1', '\x1d', ':', '?']
-
-def bin2long(s):
-	return reduce( lambda x,y:(x<<8L)+y, map(ord, s))
-
-def long2bin(l):
-	res = ""
-	for byte in range(128):
-		res += chr((l >> (1024 - (byte + 1) * 8)) & 0xff)
-	return res
-
-def rsa_pub1024(src, mod):
-	return long2bin(pow(bin2long(src), 65537, bin2long(mod)))
-	
-def decrypt_block(src, mod):
-	if len(src) != 128 and len(src) != 202:
-		return None
-	dest = rsa_pub1024(src[:128], mod)
-	hash = hashlib.sha1(dest[1:107])
-	if len(src) == 202:
-		hash.update(src[131:192])	
-	result = hash.digest()
-	if result == dest[107:127]:
-		return dest
-	return None
-
-def validate_cert(cert, key):
-	buf = decrypt_block(cert[8:], key) 
-	if buf is None:
-		return None
-	return buf[36:107] + cert[139:196]
-
-def read_random():
-	try:
-		xor = lambda a,b: ''.join(chr(ord(c)^ord(d)) for c,d in zip(a,b*100))
-		random = urandom(8)
-		x = str(time())[-8:]
-		result = xor(random, x)
-				
-		return result
-	except:
-		return None
+# rootkey = ['\x9f', '|', '\xe4', 'G', '\xc9', '\xb4', '\xf4', '#', '&', '\xce', '\xb3', '\xfe', '\xda', '\xc9', 'U', '`', '\xd8', '\x8c', 's', 'o', '\x90', '\x9b', '\\', 'b', '\xc0', '\x89', '\xd1', '\x8c', '\x9e', 'J', 'T', '\xc5', 'X', '\xa1', '\xb8', '\x13', '5', 'E', '\x02', '\xc9', '\xb2', '\xe6', 't', '\x89', '\xde', '\xcd', '\x9d', '\x11', '\xdd', '\xc7', '\xf4', '\xe4', '\xe4', '\xbc', '\xdb', '\x9c', '\xea', '}', '\xad', '\xda', 't', 'r', '\x9b', '\xdc', '\xbc', '\x18', '3', '\xe7', '\xaf', '|', '\xae', '\x0c', '\xe3', '\xb5', '\x84', '\x8d', '\r', '\x8d', '\x9d', '2', '\xd0', '\xce', '\xd5', 'q', '\t', '\x84', 'c', '\xa8', ')', '\x99', '\xdc', '<', '"', 'x', '\xe8', '\x87', '\x8f', '\x02', ';', 'S', 'm', '\xd5', '\xf0', '\xa3', '_', '\xb7', 'T', '\t', '\xde', '\xa7', '\xf1', '\xc9', '\xae', '\x8a', '\xd7', '\xd2', '\xcf', '\xb2', '.', '\x13', '\xfb', '\xac', 'j', '\xdf', '\xb1', '\x1d', ':', '?']
+# 
+# def bin2long(s):
+# 	return reduce( lambda x,y:(x<<8L)+y, map(ord, s))
+# 
+# def long2bin(l):
+# 	res = ""
+# 	for byte in range(128):
+# 		res += chr((l >> (1024 - (byte + 1) * 8)) & 0xff)
+# 	return res
+# 
+# def rsa_pub1024(src, mod):
+# 	return long2bin(pow(bin2long(src), 65537, bin2long(mod)))
+# 	
+# def decrypt_block(src, mod):
+# 	if len(src) != 128 and len(src) != 202:
+# 		return None
+# 	dest = rsa_pub1024(src[:128], mod)
+# 	hash = hashlib.sha1(dest[1:107])
+# 	if len(src) == 202:
+# 		hash.update(src[131:192])	
+# 	result = hash.digest()
+# 	if result == dest[107:127]:
+# 		return dest
+# 	return None
+# 
+# def validate_cert(cert, key):
+# 	buf = decrypt_block(cert[8:], key) 
+# 	if buf is None:
+# 		return None
+# 	return buf[36:107] + cert[139:196]
+# 
+# def read_random():
+# 	try:
+# 		xor = lambda a,b: ''.join(chr(ord(c)^ord(d)) for c,d in zip(a,b*100))
+# 		random = urandom(8)
+# 		x = str(time())[-8:]
+# 		result = xor(random, x)
+# 				
+# 		return result
+# 	except:
+# 		return None
 
 class SoftwareTools(DreamInfoHandler):
 	lastDownloadDate = None
@@ -104,26 +110,31 @@
 
 	def getUpdates(self, callback = None):
 		if self.lastDownloadDate is None:
-			if  self.hardware_info.device_name != "dm7025":
-				etpm = eTPM()
-				l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
-				if l2cert is None:
-					return
-				l2key = validate_cert(l2cert, rootkey)
-				if l2key is None:
-					return
-				l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
-				if l3cert is None:
-					return
-				l3key = validate_cert(l3cert, l2key)
-				if l3key is None:
-					return
-				rnd = read_random()
-				if rnd is None:
-					return
-				val = etpm.challenge(rnd)
-				result = decrypt_block(val, l3key)
-			if self.hardware_info.device_name == "dm7025" or result[80:88] == rnd:
+#--->
+#- 			if  self.hardware_info.device_name != "dm7025":
+#- 				etpm = eTPM()
+#- 				l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
+#- 				if l2cert is None:
+#- 					return
+#- 				l2key = validate_cert(l2cert, rootkey)
+#- 				if l2key is None:
+#- 					return
+#- 				l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
+#- 				if l3cert is None:
+#- 					return
+#- 				l3key = validate_cert(l3cert, l2key)
+#- 				if l3key is None:
+#- 					return
+#- 				rnd = read_random()
+#- 				if rnd is None:
+#- 					return
+#- 				val = etpm.challenge(rnd)
+#- 				result = decrypt_block(val, l3key)
+#- 			if self.hardware_info.device_name == "dm7025" or result[80:88] == rnd:
+#---<
+#+++>
+			if True:
+#+++<
 				if self.NetworkConnectionAvailable == True:
 					self.lastDownloadDate = time()
 					if self.list_updating is False and callback is None:
@@ -162,26 +173,31 @@
 					self.NotifierCallback = callback
 			else:
 				if self.list_updating and callback is not None:
-					if  self.hardware_info.device_name != "dm7025":
-						etpm = eTPM()
-						l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
-						if l2cert is None:
-							return
-						l2key = validate_cert(l2cert, rootkey)
-						if l2key is None:
-							return
-						l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
-						if l3cert is None:
-							return
-						l3key = validate_cert(l3cert, l2key)
-						if l3key is None:
-							return
-						rnd = read_random()
-						if rnd is None:
-							return
-						val = etpm.challenge(rnd)
-						result = decrypt_block(val, l3key)
-					if self.hardware_info.device_name == "dm7025" or result[80:88] == rnd:
+#--->
+#- 					if  self.hardware_info.device_name != "dm7025":
+#- 						etpm = eTPM()
+#- 						l2cert = etpm.getCert(eTPM.TPMD_DT_LEVEL2_CERT)
+#- 						if l2cert is None:
+#- 							return
+#- 						l2key = validate_cert(l2cert, rootkey)
+#- 						if l2key is None:
+#- 							return
+#- 						l3cert = etpm.getCert(eTPM.TPMD_DT_LEVEL3_CERT)
+#- 						if l3cert is None:
+#- 							return
+#- 						l3key = validate_cert(l3cert, l2key)
+#- 						if l3key is None:
+#- 							return
+#- 						rnd = read_random()
+#- 						if rnd is None:
+#- 							return
+#- 						val = etpm.challenge(rnd)
+#- 						result = decrypt_block(val, l3key)
+#- 					if self.hardware_info.device_name == "dm7025" or result[80:88] == rnd:
+#---<
+#+++>
+					if True:
+#+++<
 						self.NotifierCallback = callback
 						self.startIpkgListAvailable()
 				else:	
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	2011-09-03 18:23:47.390032997 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	2011-09-03 18:23:47.390032997 +0200
@@ -0,0 +1,8 @@
+SUBDIRS = tuxtxt
+
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/Tuxtxt
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	2011-09-03 18:23:47.390032997 +0200
@@ -0,0 +1,82 @@
+from enigma import *
+from Screens.Screen import Screen
+from Plugins.Plugin import PluginDescriptor
+from Components.Sources.FrontendStatus import FrontendStatus
+from Components.TunerInfo import TunerInfo
+import os
+
+class ShellStarter(Screen):
+	skin = """
+		<screen position="0,0" size="720,576" title="TuxTXT" >
+		</screen>"""
+
+	def __init__(self, session, args = None):
+		print "__init"
+		self.skin = ShellStarter.skin
+		Screen.__init__(self, session)
+		#self.container=eConsoleAppContainer()
+		#self.container.appClosed.get().append(self.finished)
+		self.runapp()
+		
+	def runapp(self):
+		print "runappt"
+		service = self.session.nav.getCurrentService()
+		if service is not None:
+			self.info = service.info()
+		else:
+			self.info = None
+
+		#eDBoxLCD.getInstance().lock()
+		#eRCInput.getInstance().lock()
+		#fbClass.getInstance().lock()
+		#if self.container.execute("/usr/bin/tuxtxt "+self.getValue(iServiceInformation.sTXTPID)):
+		s="/usr/bin/tuxtxt "
+		s+=self.getValue(iServiceInformation.sTXTPID)
+		feInfo = service and service.frontendInfo()
+		feNumber = feInfo and feInfo.getFrontendInfo(iFrontendInformation.frontendNumber)
+		if feNumber is not None:
+			s+= " "
+			s+=str(feNumber)
+			s+=" &"
+			print s
+			try:
+				os.popen(s)
+			except OSError, e: 
+				print "OSError: ", e
+				#print "OSError"
+				#Why cant i use openWithCallback?
+				#from Screens.MessageBox import MessageBox
+				#def msgClosed(ret):
+				#	return
+				#self.session.openWithCallback(msgClosed, MessageBox, _("Swap needed"), MessageBox.TYPE_INFO)
+
+				self.finished(-1)
+			self.finished(-1)
+		else:
+			print "tuxtxt: No frontend detected!"
+			self.finished(-1)
+			
+	def finished(self,retval):
+		print "finished"
+		#fbClass.getInstance().unlock()
+		#eRCInput.getInstance().unlock()
+		#eDBoxLCD.getInstance().unlock()
+		self.close()
+
+	def getValue(self, what):
+		print "getValue"
+		if self.info is None:
+			return ""
+		
+		v = "%d" % (self.info.getInfo(what))
+
+		return v
+
+
+def main(session, **kwargs):
+	print "main"
+	session.open(ShellStarter)
+
+def Plugins(**kwargs):
+	print "Plugins"
+	return PluginDescriptor(name="TuxTXT", description="Videotext", where = PluginDescriptor.WHERE_TELETEXT, fnc=main)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	2011-09-03 18:23:47.400033228 +0200
@@ -0,0 +1,2 @@
+
+
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	2011-09-03 18:23:47.410034608 +0200
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	2011-09-03 18:23:47.410034608 +0200
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	2011-09-03 18:23:47.420033287 +0200
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	2011-09-03 18:23:47.430033098 +0200
@@ -0,0 +1,20 @@
+<default>
+	  <prerequisites>
+                    <hardware type="dm8000" />
+                    <tag type="System" />
+	  </prerequisites>
+          <info>
+                    <author>Team Ducktales</author>
+                    <name>VFD-Icons</name>
+                    <packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		    <packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+                    <shortdescription>Displays text on vfd</shortdescription>
+                    <description>Displays text on vfd.
+                    </description>
+	  </info>
+
+	  <files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	2011-09-03 18:23:47.430033098 +0200
@@ -0,0 +1,154 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+				
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()	
+		
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+		
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+		
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+		
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+	
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+	
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+		
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+		
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+		
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+		
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+		
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+		
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+		
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+ 	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2011-09-03 18:23:27.500022987 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2011-09-03 18:23:47.440033378 +0200
@@ -64,6 +64,7 @@
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value]))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh Rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value]))
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -85,7 +86,16 @@
 		elif config.av.aspect.value == "4_3":
 			self.list.append(getConfigListEntry(_("Display 16:9 content as"), config.av.policy_169))
 
-#		if config.av.videoport.value == "DVI":
+#--->
+#-#		if config.av.videoport.value == "DVI":
+#---<
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat))
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2011-09-03 18:23:27.450022648 +0200
+++ enigma2-nightly.patched/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2011-09-03 18:23:47.450033927 +0200
@@ -13,52 +13,40 @@
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":		{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+#+++> To many changes, hole table exchanged
+	rates["PAL"] =			{ "50Hz":		{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz": 	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
+	rates["576p"] =			{ "50Hz": 	{ 50: "576p50" } }
 
 	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+					  "60Hz": 	{ 60: "720p60" } }
+
+	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
+					  "60Hz":	{ 60: "1080i60" } }
 
-	rates["1080i"] =		{ "50Hz":		{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+					  "24Hz":	{ 60: "1080p24" },
+					  "25Hz":	{ 60: "1080p25" },
+					  "29Hz":	{ 60: "1080p29" },
+					  "30Hz":	{ 60: "1080p30" } }
 
 	rates["PC"] = { 
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768": 		{ 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : 		{ 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200": 		{ 60: "1600x1200_60" }, #60 66 76
+
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
 
-	widescreen_modes = set(["720p", "1080i"])
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI"]  = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI-PC"] = ["PC"]
+
+	widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
+#+++<
 
 	def getOutputAspect(self):
 		ret = (16,9)
@@ -112,11 +100,22 @@
 		config.av.tvsystem.notifiers = [ ]
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
-
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+#		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF"), "8ch": _("8Ch"), "none": _("None")}, default="pcm")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+#+++<
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
 		config.av.policy_43.addNotifier(self.updateAspect)
+		
 
 		# until we have the hotplug poll socket
 #		self.timer = eTimer()
@@ -150,7 +149,13 @@
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
 			# DVI modes must be in "modes_preferred"
-#			if port == "DVI":
+#--->
+#- #			if port == "DVI":
+#---<
+#+++>
+			if port == "HDMI-PC":
+				return True
+#+++<
 #				if mode not in self.modes_preferred and not config.av.edid_override.value:
 #					print "no, not preferred"
 #					return False
@@ -189,8 +194,15 @@
 			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
-
+#+++>
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
+#+++<
 		self.updateAspect(None)
+#+++>
+		self.updateColor(port)
+#+++<
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -208,7 +220,12 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#--->
+#- 		if port == "DVI":
+#---<
+#+++>
+		if port == "HDMI":
+#+++<
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -331,6 +348,34 @@
 		except IOError:
 			pass
 
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+#+++>
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/AudioSelectionExtended.py enigma2-nightly.patched/lib/python/Screens/AudioSelectionExtended.py
--- enigma2-nightly.org/lib/python/Screens/AudioSelectionExtended.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly.patched/lib/python/Screens/AudioSelectionExtended.py	2011-09-03 18:23:47.450033927 +0200
@@ -0,0 +1,314 @@
+from Screen import Screen
+from Components.ServiceEventTracker import ServiceEventTracker
+from Components.ActionMap import ActionMap
+from Components.ConfigList import ConfigListScreen
+from Components.ChoiceList import ChoiceList, ChoiceEntryComponent
+from Components.config import config, ConfigSubsection, getConfigListEntry, ConfigNothing, ConfigSelection, ConfigOnOff
+from Components.MultiContent import MultiContentEntryText
+from Components.Sources.List import List
+from Components.Sources.Boolean import Boolean
+from Components.SystemInfo import SystemInfo
+
+from enigma import iPlayableService
+
+from Tools.ISO639 import LanguageCodes
+from Tools.BoundFunction import boundFunction
+FOCUS_CONFIG, FOCUS_STREAMS = range(2)
+[PAGE_AUDIO, PAGE_SUBTITLES] = ["audio", "subtitles"]
+
+class AudioSelection(Screen, ConfigListScreen):
+	def __init__(self, session, infobar=None, page=PAGE_AUDIO):
+		Screen.__init__(self, session)
+
+		self["streams"] = List([])
+		self["key_red"] = Boolean(False)
+		self["key_green"] = Boolean(False)
+		self["key_yellow"] = Boolean(True)
+		self["key_blue"] = Boolean(False)
+		
+		ConfigListScreen.__init__(self, [])
+		self.infobar = infobar or self.session.infobar
+
+		self.__event_tracker = ServiceEventTracker(screen=self, eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__updatedInfo
+			})
+		self.cached_subtitle_checked = False
+		self.__selected_subtitle = None
+        
+		self["actions"] = ActionMap(["ColorActions", "SetupActions", "DirectionActions"],
+		{
+			"red": self.keyRed,
+			"green": self.keyGreen,
+			"yellow": self.keyYellow,
+			"blue": self.keyBlue,
+			"ok": self.keyOk,
+			"cancel": self.cancel,
+			"up": self.keyUp,
+			"down": self.keyDown,
+		}, -3)
+
+		self.settings = ConfigSubsection()
+		choicelist = [(PAGE_AUDIO,_("audio tracks")), (PAGE_SUBTITLES,_("Subtitles"))]
+		self.settings.menupage = ConfigSelection(choices = choicelist, default=page)
+		self.onLayoutFinish.append(self.__layoutFinished)
+
+	def __layoutFinished(self):
+		self["config"].instance.setSelectionEnable(False)
+		self.focus = FOCUS_STREAMS
+		self.settings.menupage.addNotifier(self.fillList)
+
+	def fillList(self, arg=None):
+		streams = []
+		conflist = []
+		selectedidx = 0
+		
+		service = self.session.nav.getCurrentService()
+		self.audioTracks = audio = service and service.audioTracks()
+		n = audio and audio.getNumberOfTracks() or 0
+		
+		if self.settings.menupage.getValue() == PAGE_AUDIO:
+			self.setTitle(_("Select audio track"))
+			if SystemInfo["CanDownmixAC3"]:
+				self.settings.downmix = ConfigOnOff(default=config.av.downmix_ac3.value)
+				self.settings.downmix.addNotifier(self.changeAC3Downmix, initial_call = False)
+				conflist.append(getConfigListEntry(_("AC3 downmix"), self.settings.downmix))
+				self["key_red"].setBoolean(True)
+
+			if n > 0:
+				self.audioChannel = service.audioChannel()
+				choicelist = [("0",_("left")), ("1",_("stereo")), ("2", _("right"))]
+				self.settings.channelmode = ConfigSelection(choices = choicelist, default = str(self.audioChannel.getCurrentChannel()))
+				self.settings.channelmode.addNotifier(self.changeMode, initial_call = False)
+				conflist.append(getConfigListEntry(_("Channel"), self.settings.channelmode))
+				self["key_green"].setBoolean(True)
+				selectedAudio = self.audioTracks.getCurrentTrack()
+				for x in range(n):
+					number = str(x)
+					i = audio.getTrackInfo(x)
+					languages = i.getLanguage().split('/')
+					description = i.getDescription() or _("<unknown>")
+					selected = ""
+					language = ""
+
+					if selectedAudio == x:
+						selected = _("Running")
+						selectedidx = x
+
+					cnt = 0
+					for lang in languages:
+						if cnt:
+							language += ' / '
+						if LanguageCodes.has_key(lang):
+							language += LanguageCodes[lang][0]
+						elif lang == "und":
+							_("<unknown>")
+						else:
+							language += lang
+						cnt += 1
+
+					streams.append((x, "", number, description, language, selected))
+
+			else:
+				streams = []
+				conflist.append(('',))
+				self["key_green"].setBoolean(False)
+
+		elif self.settings.menupage.getValue() == PAGE_SUBTITLES:
+			self.setTitle(_("Subtitle selection"))
+			conflist.append(('',))
+			conflist.append(('',))
+			self["key_red"].setBoolean(False)
+			self["key_green"].setBoolean(False)
+
+			if self.subtitlesEnabled():
+				sel = self.infobar.selected_subtitle
+			else:
+				sel = None
+
+			idx = 0
+			
+			subtitlelist = self.getSubtitleList()
+
+			if len(subtitlelist):
+				for x in subtitlelist:
+					number = str(x[1])
+					description = "?"
+					language = _("<unknown>")
+					selected = ""
+
+					if sel and x[:4] == sel[:4]:
+						selected = _("Running")
+						selectedidx = idx
+					
+					if x[4] != "und":
+						if LanguageCodes.has_key(x[4]):
+							language = LanguageCodes[x[4]][0]
+						else:
+							language = x[4]
+
+					if x[0] == 0:
+						description = "DVB"
+						number = "%x" % (x[1])
+
+					elif x[0] == 1:
+						description = "TTX"
+						number = "%x%02x" % (x[3],x[2])
+
+					elif x[0] == 2:
+						types = ("UTF-8 text","SSA / AAS",".SRT file")
+						description = types[x[2]]
+
+					streams.append((x, "", number, description, language, selected))
+					idx += 1
+			
+			else:
+				streams = []
+
+		conflist.append(getConfigListEntry(_("Menu"), self.settings.menupage))
+		
+		from Components.PluginComponent import plugins
+		from Plugins.Plugin import PluginDescriptor
+		
+		if hasattr(self.infobar, "runPlugin"):
+			class PluginCaller:
+				def __init__(self, fnc, *args):
+					self.fnc = fnc
+					self.args = args
+				def __call__(self, *args, **kwargs):
+					self.fnc(*self.args)
+
+			Plugins = [ (p.name, PluginCaller(self.infobar.runPlugin, p)) for p in plugins.getPlugins(where = PluginDescriptor.WHERE_AUDIOMENU) ]
+
+			if len(Plugins):
+				self["key_blue"].setBoolean(True)
+				conflist.append(getConfigListEntry(Plugins[0][0], ConfigNothing()))
+				self.plugincallfunc = Plugins[0][1]
+			if len(Plugins) > 1:
+				print "these plugins are installed but not displayed in the dialog box:", Plugins[1:]
+
+		self["config"].list = conflist
+		self["config"].l.setList(conflist)
+
+		self["streams"].list = streams
+		self["streams"].setIndex(selectedidx)
+
+	def __updatedInfo(self):
+		self.fillList()
+
+	def getSubtitleList(self):
+		s = self.infobar and self.infobar.getCurrentServiceSubtitle()
+		l = s and s.getSubtitleList() or [ ]
+		return l
+
+	def subtitlesEnabled(self):
+		return self.infobar.subtitles_enabled
+
+	def enableSubtitle(self, subtitles):
+		if self.infobar.selected_subtitle != subtitles:
+			self.infobar.subtitles_enabled = False
+			self.infobar.selected_subtitle = subtitles
+			if subtitles:
+				self.infobar.subtitles_enabled = True
+
+	def changeAC3Downmix(self, downmix):
+		if downmix.getValue() == True:
+			config.av.downmix_ac3.value = True
+		else:
+			config.av.downmix_ac3.value = False
+		config.av.downmix_ac3.save()
+
+	def changeMode(self, mode):
+		if mode is not None:
+			self.audioChannel.selectChannel(int(mode.getValue()))
+
+	def changeAudio(self, audio):
+		track = int(audio)
+		if isinstance(track, int):
+			if self.session.nav.getCurrentService().audioTracks().getNumberOfTracks() > track:
+				self.audioTracks.selectTrack(track)
+
+	def keyLeft(self):
+		if self.focus == FOCUS_CONFIG:
+			ConfigListScreen.keyLeft(self)
+		elif self.focus == FOCUS_STREAMS:
+			self["streams"].setIndex(0)
+
+	def keyRight(self, config = False):
+		if config or self.focus == FOCUS_CONFIG:
+			if self["config"].getCurrentIndex() < 3:
+				ConfigListScreen.keyRight(self)
+			elif hasattr(self, "plugincallfunc"):
+				self.plugincallfunc()
+		if self.focus == FOCUS_STREAMS and self["streams"].count() and config == False:
+			self["streams"].setIndex(self["streams"].count()-1)
+
+	def keyRed(self):
+		if self["key_red"].getBoolean():
+			self.colorkey(0)
+
+	def keyGreen(self):
+		if self["key_green"].getBoolean():
+			self.colorkey(1)
+
+	def keyYellow(self):
+		if self["key_yellow"].getBoolean():
+			self.colorkey(2)
+
+	def keyBlue(self):
+		if self["key_blue"].getBoolean():
+			self.colorkey(3)
+
+	def colorkey(self, idx):
+		self["config"].setCurrentIndex(idx)
+		self.keyRight(True)
+
+	def keyUp(self):
+		if self.focus == FOCUS_CONFIG:
+			self["config"].instance.moveSelection(self["config"].instance.moveUp)
+		elif self.focus == FOCUS_STREAMS:
+			if self["streams"].getIndex() == 0:
+				self["config"].instance.setSelectionEnable(True)
+				self["streams"].style = "notselected"
+				self["config"].setCurrentIndex(len(self["config"].getList())-1)
+				self.focus = FOCUS_CONFIG
+			else:
+				self["streams"].selectPrevious()
+
+	def keyDown(self):
+		if self.focus == FOCUS_CONFIG:
+			if self["config"].getCurrentIndex() < len(self["config"].getList())-1:
+				self["config"].instance.moveSelection(self["config"].instance.moveDown)
+			else:
+				self["config"].instance.setSelectionEnable(False)
+				self["streams"].style = "default"
+				self.focus = FOCUS_STREAMS
+		elif self.focus == FOCUS_STREAMS:
+			self["streams"].selectNext()
+
+	def keyOk(self):
+		if self.focus == FOCUS_STREAMS and self["streams"].list:
+			cur = self["streams"].getCurrent()
+			if self.settings.menupage.getValue() == PAGE_AUDIO and cur[0] is not None:
+				self.changeAudio(cur[2])
+				self.__updatedInfo()
+			if self.settings.menupage.getValue() == PAGE_SUBTITLES and cur[0] is not None:
+				if self.infobar.selected_subtitle == cur[0]:
+					self.enableSubtitle(None)
+					selectedidx = self["streams"].getIndex()
+					self.__updatedInfo()
+					self["streams"].setIndex(selectedidx)
+				else:
+					self.enableSubtitle(cur[0])
+					self.__updatedInfo()
+			self.close(0)
+		elif self.focus == FOCUS_CONFIG:
+			self.keyRight()
+
+	def cancel(self):
+		self.close(0)
+
+class SubtitleSelection(AudioSelection):
+	def __init__(self, session, infobar=None):
+		AudioSelection.__init__(self, session, infobar, page=PAGE_SUBTITLES)
+		self.skinName = ["AudioSelection"]
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/DefaultWizard.py enigma2-nightly.patched/lib/python/Screens/DefaultWizard.py
--- enigma2-nightly.org/lib/python/Screens/DefaultWizard.py	2011-09-03 18:23:27.590023172 +0200
+++ enigma2-nightly.patched/lib/python/Screens/DefaultWizard.py	2011-09-03 18:23:47.460033783 +0200
@@ -25,10 +25,10 @@
 		self["arrowup2"] = MovingPixmap()
 	
 	def setDirectory(self):
-		self.directory = resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)
+		self.directory = resolveFilename(SCOPE_DEFAULTDIR)
 		self.xmlfile = "defaultwizard.xml"
-		if self.directory:
-			os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), self.directory))
+#		if self.directory:
+#			os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), self.directory))
         
 	def markDone(self):
 		config.misc.defaultchosen.value = 0
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py enigma2-nightly.patched/lib/python/Screens/InfoBarGenerics.py
--- enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py	2011-09-03 18:23:27.630023023 +0200
+++ enigma2-nightly.patched/lib/python/Screens/InfoBarGenerics.py	2011-09-03 18:23:47.480033822 +0200
@@ -44,6 +44,10 @@
 # hack alert!
 from Menu import MainMenu, mdom
 
+#+++>
+txtIsStarting = False
+#+++<
+
 class InfoBarDish:
 	def __init__(self):
 		self.dishDialog = self.session.instantiateDialog(Dish)
@@ -88,6 +92,9 @@
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+#+++>
+	STATE_EPG = 4
+#+++<
 
 	def __init__(self):
 		self["ShowHideActions"] = ActionMap( ["InfobarShowHideActions"] ,
@@ -138,12 +145,34 @@
 		if self.__state == self.STATE_SHOWN:
 			self.hide()
 
+#+++>
+	def epg(self): 
+		self.__state = self.STATE_EPG 
+		self.hide() 
+		self.hideTimer.stop() 
+		self.openEventView() 
+#+++<
+
 	def toggleShow(self):
-		if self.__state == self.STATE_SHOWN:
-			self.hide()
-			self.hideTimer.stop()
-		elif self.__state == self.STATE_HIDDEN:
-			self.show()
+#--->
+#-		if self.__state == self.STATE_SHOWN:
+#-			self.hide()
+#-			self.hideTimer.stop()
+#-		elif self.__state == self.STATE_HIDDEN:
+#-			self.show()
+#---<
+#+++>
+		if self.__state == self.STATE_SHOWN: 
+			print "self.STATE_SHOWN" 
+			self.epg() 
+		elif self.__state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.show() 
+		elif self.__state == self.STATE_EPG: 
+			print "self.STATE_EPG" 
+			self.hide() 
+			self.hideTimer.stop() 
+#+++<
 
 	def lockShow(self):
 		self.__locked = self.__locked + 1
@@ -1338,7 +1367,12 @@
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#--->
+#-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#---<
+#+++>
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
+#+++<
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -1773,16 +1807,43 @@
 				idx += 1
 
 			if self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#--->
+#-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#---<
+#+++>
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#+++<
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
 				else:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
+#--->
+#-				selection += 3
+#---<
+#+++>
+				selection += 4
+#+++<
+			else:
+#--->
+#-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
+#-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#-				selection += 2
+#---<
+#+++>
+				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				selection += 3
-			else:
-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
+#+++<
 
 			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a subservice..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
 
@@ -2155,7 +2216,22 @@
 			print "no teletext plugin found!"
 
 	def startTeletext(self):
-		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#--->
+#		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#---<
+#+++>
+		global txtIsStarting
+		if txtIsStarting is False:
+			self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+			txtIsStarting = True
+			self.txtIsStartingTimer = eTimer()
+			self.txtIsStartingTimer.callback.append(self.txtIsStartingEnd)
+			self.txtIsStartingTimer.start(10000, True)
+
+	def txtIsStartingEnd(self):
+		global txtIsStarting
+		txtIsStarting = False
+#+++<
 
 class InfoBarSubtitleSupport(object):
 	def __init__(self):
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/InfoBar.py enigma2-nightly.patched/lib/python/Screens/InfoBar.py
--- enigma2-nightly.org/lib/python/Screens/InfoBar.py	2011-09-03 18:23:27.620023282 +0200
+++ enigma2-nightly.patched/lib/python/Screens/InfoBar.py	2011-09-03 18:23:47.480033822 +0200
@@ -6,7 +6,12 @@
 from Screen import Screen
 
 profile("LOAD:enigma")
-from enigma import iPlayableService
+#--->
+#-from enigma import iPlayableService
+#---<
+#+++>
+from enigma import iServiceInformation, iPlayableService 
+#+++<
 
 profile("LOAD:InfoBarGenerics")
 from Screens.InfoBarGenerics import InfoBarShowHide, \
@@ -45,6 +50,11 @@
 				"showMovies": (self.showMovies, _("Play recorded movies...")),
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+#+++>
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")), 
+				"volumeUp": (self._volUp, _("...")), 
+				"volumeDown": (self._volDown, _("...")), 
+#+++<
 			}, prio=2)
 		
 		self.allowPiP = True
@@ -71,6 +81,41 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+#+++>
+		# I know that this is not nice but i dont know how to directly access VolumneControl
+		from Screens.Volume import Volume
+		self.volumeDialog = session.instantiateDialog(Volume)
+		from enigma import eTimer
+		self.hideVolTimer = eTimer()
+		self.hideVolTimer.callback.append(self.volHide)
+		from Components.config import config, ConfigSubsection, ConfigInteger
+		config.audio = ConfigSubsection()
+		config.audio.volume = ConfigInteger(default = 100, limits = (0, 100))
+		
+	def volHide(self):
+		self.volumeDialog.hide()
+
+	def _volUp(self):
+		print "_volUp"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeUp()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+
+	def _volDown(self):
+		print "_volDown"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeDown()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+#+++<
+
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -89,6 +134,24 @@
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+#+++>
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService() 
+		info = service.info() 
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID) 
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID) 
+
+		print "sAudioPID", AudioPID 
+		print "sVideoPID", VideoPID 
+               
+		if VideoPID == -1: 
+			print "radio->tv" 
+			self.showTv2() 
+		else: 
+			print "tv->radio" 
+			self.showRadio2() 
+#+++<
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -112,6 +175,19 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+#+++>
+	def showTv2(self):
+		self.showTvChannelList(False)
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+ 		else:
+ 			self.rds_display.hide() # in InfoBarRdsDecoder
+ 			from Screens.ChannelSelection import ChannelSelectionRadio
+ 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+#+++<
+
 	def ChannelSelectionRadioClosed(self, *arg):
 		self.rds_display.show()  # in InfoBarRdsDecoder
 
@@ -212,12 +288,22 @@
 					return
 
 		if answer in ("quit", "quitanddeleteconfirmed"):
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.close()
 		elif answer == "movielist":
 			ref = self.session.nav.getCurrentlyPlayingServiceReference()
 			self.returning = True
 			from Screens.MovieSelection import MovieSelection
 			self.session.openWithCallback(self.movieSelected, MovieSelection, ref)
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.session.nav.stopService()
 		elif answer == "restart":
 			self.doSeek(0)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Screens/Wizard.py enigma2-nightly.patched/lib/python/Screens/Wizard.py
--- enigma2-nightly.org/lib/python/Screens/Wizard.py	2011-09-03 18:23:27.830023367 +0200
+++ enigma2-nightly.patched/lib/python/Screens/Wizard.py	2011-09-03 18:23:47.490034113 +0200
@@ -14,6 +14,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	skin = """
@@ -360,6 +363,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -452,6 +458,9 @@
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 		
 	def resetCounter(self):
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/python/Tools/KeyBindings.py enigma2-nightly.patched/lib/python/Tools/KeyBindings.py
--- enigma2-nightly.org/lib/python/Tools/KeyBindings.py	2011-09-03 18:23:27.870023888 +0200
+++ enigma2-nightly.patched/lib/python/Tools/KeyBindings.py	2011-09-03 18:23:47.500035403 +0200
@@ -44,7 +44,15 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RECORD",)
+#--->
+#- 		KEYIDS["KEY_RECORD"]: ("RECORD",)
+#---<
+#+++>
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
+#+++<
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
@@ -86,7 +94,15 @@
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
+#--->
+#- 		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
+#---<
+#+++>
+		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT"),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
+#+++<
 	}
 ]
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicedvb.cpp enigma2-nightly.patched/lib/service/servicedvb.cpp
--- enigma2-nightly.org/lib/service/servicedvb.cpp	2011-09-03 18:23:27.960023238 +0200
+++ enigma2-nightly.patched/lib/service/servicedvb.cpp	2011-09-03 18:23:47.520033288 +0200
@@ -537,6 +537,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
@@ -1458,6 +1461,10 @@
 
 RESULT eDVBServicePlay::isCurrentlySeekable()
 {
+// __sh__: fix seekable problem with .ts files if .ts.meta not exists (see e2 git from 02.01.2010 10:54:57)
+#ifdef __sh__
+	return m_is_pvr || m_timeshift_active;
+#else
 	int ret = 0;
 	if (m_decoder)
 	{
@@ -1466,6 +1473,7 @@
 			ret &= ~2;
 	}
 	return ret;
+#endif
 }
 
 RESULT eDVBServicePlay::frontendInfo(ePtr<iFrontendInformation> &ptr)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/lib/service/servicedvbrecord.cpp enigma2-nightly.patched/lib/service/servicedvbrecord.cpp
--- enigma2-nightly.org/lib/service/servicedvbrecord.cpp	2011-09-03 18:23:27.970023823 +0200
+++ enigma2-nightly.patched/lib/service/servicedvbrecord.cpp	2011-09-03 18:23:47.520033288 +0200
@@ -12,6 +12,26 @@
 #error no byte order defined!
 #endif
 
+#if defined(__sh__) 
+#include <sys/vfs.h> 
+//this is not available for stlinux :-( 
+//#include <linux/magic.h> 
+ 
+/* and these i dont get included :-( 
+#include <linux/usbdevice_fs.h> 
+#include <linux/smb.h> 
+#include <linux/nfs__fs.h> 
+#include <linux/ext3_fs.h> 
+
+so hack ;-) 
+*/ 
+#define USBDEVICE_SUPER_MAGIC 0x9fa2 
+#define EXT2_SUPER_MAGIC      0xEF53 
+#define EXT3_SUPER_MAGIC      0xEF53 
+#define SMB_SUPER_MAGIC       0x517B 
+#define NFS_SUPER_MAGIC       0x6969 
+#define MSDOS_SUPER_MAGIC     0x4d44            /* MD */ 
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref): m_ref(ref)
@@ -254,9 +274,43 @@
 	
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__) 
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__) 
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0) 
+		{ 
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!"); 
+		} else 
+		{ 
+			if (sbuf.f_type == EXT3_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n"); 
+			else 
+			if (sbuf.f_type == NFS_SUPER_MAGIC) 
+			{ 
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n"); 
+				flags |= O_DIRECT; 
+			} 
+			else 
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - USB Device\n"); 
+			else 
+			if (sbuf.f_type == SMB_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - SMBs Device\n"); 
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - MSDOS Device\n"); 
+		} 
+		fd = ::open(m_filename.c_str(), flags, 0644); 
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/m4/ax_python_devel.m4 enigma2-nightly.patched/m4/ax_python_devel.m4
--- enigma2-nightly.org/m4/ax_python_devel.m4	2011-09-03 18:23:28.020024198 +0200
+++ enigma2-nightly.patched/m4/ax_python_devel.m4	2011-09-03 18:23:47.550033203 +0200
@@ -154,7 +154,7 @@
 		python_path=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_inc ());"`
 		if test -n "${python_path}"; then
-			python_path="-I$python_path"
+			python_path="-I$PY_PATH/include/python2.6"
 		fi
 		PYTHON_CPPFLAGS=$python_path
 	fi
@@ -235,7 +235,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python2.6 -lpython$ac_python_version"
+#			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LDFLAGS"; then
@@ -253,8 +254,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH//lib/python2.6/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/bsod.cpp enigma2-nightly.patched/main/bsod.cpp
--- enigma2-nightly.org/main/bsod.cpp	2011-09-03 18:23:28.040023387 +0200
+++ enigma2-nightly.patched/main/bsod.cpp	2011-09-03 18:23:47.560033163 +0200
@@ -17,8 +17,11 @@
 #include "version_info.h"
 
 /************************************************/
-
+#if defined(__sh__) // dont send mails to dm
+#define CRASH_EMAILADDR "somebody@who.cares" 
+#else 
 #define CRASH_EMAILADDR "crashlog@dream-multimedia-tv.de"
+#endif
 #define INFOFILE "/maintainer.info"
 
 #define RINGBUFFER_SIZE 16384
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/enigma.cpp enigma2-nightly.patched/main/enigma.cpp
--- enigma2-nightly.org/main/enigma.cpp	2011-09-03 18:23:28.060023358 +0200
+++ enigma2-nightly.patched/main/enigma.cpp	2011-09-03 18:23:47.560033163 +0200
@@ -27,6 +27,14 @@
 #include <lib/python/connections.h>
 #include <lib/python/python.h>
 
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>  
+
+#endif  
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly
+#include "include/shmE2.h"
+char *shm = NULL;
+#endif 
 #include "bsod.h"
 #include "version_info.h"
 
@@ -124,6 +132,11 @@
 
 int main(int argc, char **argv)
 {
+#if defined(__sh__) // nits shm hack to behavior of e2 on the fly
+        shm = findshm();
+        if(shm == NULL)
+            shm = createshm();
+#endif
 #ifdef MEMLEAK_CHECK
 	atexit(DumpUnfreed);
 #endif
@@ -227,6 +240,12 @@
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__)  // initialise the vfd class
+	evfd * vfd = new evfd;  
+	vfd->init();  
+	delete vfd;  
+#endif  
 	
 	printf("executing main\n");
 	
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/main/Makefile.am enigma2-nightly.patched/main/Makefile.am
--- enigma2-nightly.org/main/Makefile.am	2011-09-03 18:23:28.030023423 +0200
+++ enigma2-nightly.patched/main/Makefile.am	2011-09-03 18:23:47.570032972 +0200
@@ -9,6 +9,8 @@
 
 bin_PROGRAMS = enigma2
 
+installdir = $(targetprefix)/usr/local/bin
+
 enigma2_SOURCES = \
 	bsod.cpp \
 	bsod.h \
@@ -48,7 +50,8 @@
 	@LIBXINE_LIBS@ \
 	@LIBXMLCCWRAP_LIBS@ \
 	@PTHREAD_LIBS@ \
-	@PYTHON_LDFLAGS@
+	@PYTHON_LDFLAGS@ \
+	-ldl -lpthread -lcrypt -lresolv -lrt -lmmeimage
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/mytest.py enigma2-nightly.patched/mytest.py
--- enigma2-nightly.org/mytest.py	2011-09-03 18:23:28.070023477 +0200
+++ enigma2-nightly.patched/mytest.py	2011-09-03 18:23:47.570032972 +0200
@@ -310,6 +310,10 @@
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+#+++> # If the dialog can not be found return instead of crashing
+		if dlg is None:
+			return
+#+++<
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -514,10 +518,17 @@
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
-			wptime = nowTime + 30  # so switch back on in 30 seconds
-		else:
-			wptime = startTime[0] - 240
+#+++> # Unfortunatly sometimes it takes longer to boot (filesystemcheck, ...) so start earlier
+#-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+#-			wptime = nowTime + 30  # so switch back on in 30 seconds
+#-		else:
+#-			wptime = startTime[0] - 240
+
+	        if (startTime[0] - nowTime) < 330: # no time to switch box back on
+		       wptime = nowTime + 30  # so switch back on in 30 seconds
+	        else:
+		       wptime = startTime[0] - 300
+#+++<
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
diff -Nur '--exclude=.git' '--exclude=tuxtxt' enigma2-nightly.org/RecordTimer.py enigma2-nightly.patched/RecordTimer.py
--- enigma2-nightly.org/RecordTimer.py	2011-09-03 18:23:23.570020972 +0200
+++ enigma2-nightly.patched/RecordTimer.py	2011-09-03 18:23:47.580033303 +0200
@@ -304,6 +304,13 @@
 						RecordTimerEntry.TryQuitMainloop() # start shutdown handling without screen
 					else:
 						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20)
+			# vvv Ensure shutdown after AUTO timer if no key has been pressed
+			elif self.afterEvent == AFTEREVENT.AUTO:
+				if not Screens.Standby.inTryQuitMainloop: # not a shutdown messagebox is open
+					timerStart = open("/proc/stb/fp/was_timer_wakeup").read()
+					if timerStart[:1] == "1":
+						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20) 
+			# ^^^ Ensure shutdown after AUTO timer if no key has been pressed
 			return True
 
 	def setAutoincreaseEnd(self, entry = None):
--- enigma2-nightly.org/lib/driver/vfd.cpp	2010-10-31 00:55:10.717950000 +0200
+++ enigma2-nightly.org/lib/driver/vfd.cpp	2010-11-05 07:27:31.275684176 +0100
@@ -29,8 +29,12 @@
 void * start_loop (void *arg);
 bool blocked = false;
 bool requested = false;
-char chars[64];
+bool VFD_CENTER = false;
+bool scoll_loop = false;
+int VFD_SCROLL = 1;
 
+char chars[64];
+char g_str[64];
 
 struct vfd_ioctl_data {
 	unsigned char start;
@@ -38,7 +42,13 @@
 	unsigned char length;
 };
 
-
+#ifdef PLATFORM_OCTAGON1008
+	#define VFDLENGTH 8
+#elif defined (PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_ATEVIO7500)
+	#define VFDLENGTH 12
+#else
+	#define VFDLENGTH 16
+#endif
 
 evfd* evfd::instance = NULL;
 
@@ -179,7 +189,14 @@
 	vfd.vfd_write_string("AAF DEV-TEAM", true);
 	//run 2 times through all icons 
 	for  (int vloop = 0; vloop < 128; vloop++) {
-		/*if (vloop%14 == 0 )
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008) && !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD)
+		if (vloop%2 == 1) {
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+#else
+		if (vloop%14 == 0 )
 			vfd.vfd_set_brightness(1);
 		else if (vloop%14 == 1 )
 			vfd.vfd_set_brightness(2);
@@ -206,21 +223,17 @@
 		else if (vloop%14 == 12 )
 			vfd.vfd_set_brightness(1);
 		else if (vloop%14 == 13 )
-			vfd.vfd_set_brightness(0);*/
-		if (vloop%2 == 1) {
-			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
-			//usleep(1000);
-			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
-		}
+			vfd.vfd_set_brightness(0);
+#endif		
 		usleep(75000);
 	}
 	vfd.vfd_set_brightness(7);
-	
+#if !defined(PLATFORM_FORTIS_HDBOX) && !defined(PLATFORM_OCTAGON1008)	&& !defined(PLATFORM_ATEVIO7500) && !defined(PLATFORM_CUBEREVO) && !defined(PLATFORM_CUBEREVO_MINI) && !defined(PLATFORM_CUBEREVO_MINI2) && !defined(PLATFORM_CUBEREVO_MINI_FTA) && !defined(PLATFORM_CUBEREVO_250HD) && !defined(PLATFORM_CUBEREVO_2000HD) && !defined(PLATFORM_CUBEREVO_9500HD)
 	//set all blocked icons
 	for (int id = 0x10; id < 0x20; id++) {
 		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);	
 	}
-
+#endif
 	blocked = false;
 	return NULL;
 }
@@ -229,6 +242,106 @@
 
 //////////////////////////////////////////////////////////////////////////////////////
 
+#if defined(PLATFORM_FORTIS_HDBOX) || defined(PLATFORM_OCTAGON1008) || defined(PLATFORM_ATEVIO7500) || defined(PLATFORM_CUBEREVO) || defined(PLATFORM_CUBEREVO_MINI) || defined(PLATFORM_CUBEREVO_MINI2) || defined(PLATFORM_CUBEREVO_MINI_FTA) || defined(PLATFORM_CUBEREVO_250HD) || defined(PLATFORM_CUBEREVO_2000HD) || defined(PLATFORM_CUBEREVO_9500HD)
+void evfd::vfd_write_string_scrollText(char* text) {
+	return;
+}
+
+//we can not use a member function (vfd_write_string_scrollText) in pthread, so we use a second (same content) non member function (vfd_write_string_scrollText1)
+static void *vfd_write_string_scrollText1(void *arg) {
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	bool scoll_loop = true;
+	char out[VFDLENGTH+1];
+	int i, len;
+	evfd vfd;
+	len = strlen((char *) g_str);
+	memset(out, 0, VFDLENGTH+1);
+	while(scoll_loop && (len > VFDLENGTH)) {
+		if (blocked) {
+			usleep(250000);
+		} else {
+			scoll_loop = false;
+		}
+		for (i=0; i<=(len-VFDLENGTH); i++) {
+			if (blocked) {
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+i, VFDLENGTH);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			} else {
+				scoll_loop = false;
+				i = len-VFDLENGTH;
+			}
+		}
+		for (i=1; i < VFDLENGTH; i++) {
+			if (blocked) {
+				memset(out, ' ', VFDLENGTH);
+				memcpy(out, g_str+len+i-VFDLENGTH, VFDLENGTH-i);
+				vfd.vfd_write_string(out,true);
+				usleep(250000);
+			} else {
+				scoll_loop = false;
+				i = VFDLENGTH;
+			}
+		}
+		memcpy(out, g_str, VFDLENGTH);
+		vfd.vfd_write_string(out,true);
+		if (VFD_SCROLL != 2 || !blocked)
+			scoll_loop = false;
+	}
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(char * str)
+{
+	int i = strlen(str);
+	if(blocked)
+	{
+		pthread_cancel(thread_start_loop);
+		pthread_join(thread_start_loop, NULL);
+		blocked=false;
+	}
+	memset(g_str,0,64);
+	strcpy(g_str,str);
+	vfd_write_string(str, false);
+	if(i > VFDLENGTH && VFD_SCROLL)
+	{
+		blocked = true;
+		pthread_create(&thread_start_loop, NULL, vfd_write_string_scrollText1, (void *)str);
+		pthread_detach(thread_start_loop);
+	}
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int ws = 0;
+	int i = strlen(str);
+	if (VFD_CENTER) {
+		if (i < VFDLENGTH)
+			ws=(VFDLENGTH-i)/2;
+		else
+			ws=0;
+	}
+	if (i > VFDLENGTH) i = VFDLENGTH;
+	struct vfd_ioctl_data data;
+	memset(data.data, ' ', VFDLENGTH);
+	if (VFD_CENTER)
+		memcpy(data.data+ws, str, VFDLENGTH-ws);
+	else
+		memcpy(data.data, str, i);
+	data.start = 0;
+	if (VFD_CENTER)
+		data.length = i+ws<=VFDLENGTH?i+ws:VFDLENGTH;
+	else
+		data.length = i;
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		write(file_vfd,data.data,data.length);
+		close (file_vfd);
+	return;
+}
+
+#else
 void evfd::vfd_write_string(char * str)
 {
 	vfd_write_string(str, false);
@@ -290,7 +403,7 @@
 	}
 	return;
 }
-
+#endif
 void evfd::vfd_clear_string()
 {
 	vfd_write_string("                ");
@@ -374,3 +487,13 @@
 	close (file_vfd);
 	return;
 }
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	VFD_SCROLL=id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER=id;
+}
--- enigma2-nightly.org/lib/driver/vfd.h	2010-10-31 00:55:10.717950000 +0200
+++ enigma2-nightly.org/lib/driver/vfd.h	2010-10-30 20:20:10.000000000 +0200
@@ -4,7 +4,12 @@
 #define ICON_ON  1
 #define ICON_OFF 0
 
+#ifndef PLATFORM_HDBOX
 typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+#else
+typedef enum { USB = 0x10, STANDBY, SAT, REC, TIMESHIFT, TIMER, HD, LOCK, DD, MUTE, TUNER1, TUNER2, MP3, REPEAT,
+			   PLAY, PAUSE, TER, FILE, 480i, 480p, 576i, 576p, 720p, 1080i, 1080p } tvfd_icon;
+#endif
 
 class evfd
 {
@@ -23,6 +28,8 @@
 	void init();
 	static evfd* getInstance();
 
+        void vfd_set_SCROLL(int id);
+	void vfd_set_CENTER(bool id);
 	void vfd_set_icon(tvfd_icon id, bool onoff);
 	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
 	void vfd_clear_icons();
 
