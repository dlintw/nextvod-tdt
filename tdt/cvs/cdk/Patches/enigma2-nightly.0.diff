diff -Nur enigma2-nightly.org/acinclude.m4 enigma2-nightly/acinclude.m4
--- enigma2-nightly.org/acinclude.m4	2009-12-12 23:16:22.333099000 +0100
+++ enigma2-nightly/acinclude.m4	2009-12-12 23:18:19.940600635 +0100
@@ -370,7 +370,7 @@
 		
 		# FIXME: yes, this is wrong. sorry about that. (tmbinc)
 		cross_PYTHON_VERSION=$PYTHON_VERSION
-		python_path=
+		python_path=$PY_PATH/include/python2.6 
 		for i in $CPPFLAGS ; do
 			p=`echo $i | sed "s,^-I,,"`
 			p=`echo $p | sed "s,^-isystem,,"`
@@ -387,7 +387,7 @@
 
 		# Check for Python library path
 		AC_MSG_CHECKING([for Python library path])
-		python_path=
+		python_path=$PY_PATH/include/python2.6 
 		for i in $LDFLAGS; do
 			l=`echo $i | sed "s,^-L,,"`
 			python_path=`find $l -type f -name libpython$cross_PYTHON_VERSION.* -print | sed "1q"`
diff -Nur enigma2-nightly.org/configure.ac enigma2-nightly/configure.ac
--- enigma2-nightly.org/configure.ac	2009-12-12 23:16:22.333099000 +0100
+++ enigma2-nightly/configure.ac	2009-12-13 00:08:06.000000000 +0100
@@ -22,6 +22,26 @@
 fi
 AM_CONDITIONAL(HAVE_DDVDLIB, test "$have_ddvdlib" = "yes")
 
+AC_ARG_ENABLE([tf7700],
+        [AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-tf7700]))
+        [case "${enableval}" in
+                yes) enable_tf7700=true ;;
+                no) enable_tf7700=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+        [AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+#	AC_MSG_ERROR([bad value I${enableval}I for --enable-cuberevo]))
+        [case "${enableval}" in
+                yes) enable_cuberevo=true ;;
+                no) enable_cuberevo=false ;;
+                *) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+        esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
 AM_PATH_PYTHON()
 AC_PYTHON_DEVEL
 #AM_PATH_XINE(1.1.0,, AC_MSG_ERROR([*** Please install xine-lib (devel) first ***]))
@@ -117,8 +122,6 @@
 lib/python/Components/Sources/Makefile
 lib/python/Screens/Makefile
 lib/python/Plugins/Makefile
-lib/python/Plugins/DemoPlugins/Makefile
-lib/python/Plugins/DemoPlugins/TestPlugin/Makefile
 lib/python/Plugins/Extensions/CutListEditor/Makefile
 lib/python/Plugins/Extensions/CutListEditor/meta/Makefile
 lib/python/Plugins/Extensions/DVDBurn/Makefile
@@ -133,15 +140,12 @@
 lib/python/Plugins/Extensions/MediaPlayer/meta/Makefile
 lib/python/Plugins/Extensions/MediaScanner/Makefile
 lib/python/Plugins/Extensions/MediaScanner/meta/Makefile
-lib/python/Plugins/Extensions/Modem/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/meta/Makefile
 lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
 lib/python/Plugins/Extensions/SocketMMI/Makefile
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/Makefile
 lib/python/Plugins/SystemPlugins/CleanupWizard/meta/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
@@ -180,6 +184,12 @@
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/Extensions/TopfieldVFD/Makefile
+lib/python/Plugins/Extensions/CuberevoVFD/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile 
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 lib/service/Makefile
 lib/components/Makefile
diff -Nur enigma2-nightly.org/lib/base/filepush.cpp enigma2-nightly/lib/base/filepush.cpp
--- enigma2-nightly.org/lib/base/filepush.cpp	2009-12-12 23:16:22.400599000 +0100
+++ enigma2-nightly/lib/base/filepush.cpp	2009-12-12 23:36:55.000000000 +0100
@@ -49,6 +49,11 @@
 	
 	source_pos = m_raw_source.lseek(0, SEEK_CUR);
 	
+#if defined(__sh__)
+//Changes in this file are cause e2 doesnt tell the player to play reverse
+//No idea how this is handeld in dm drivers
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+#endif
 		/* m_stop must be evaluated after each syscall. */
 	while (!m_stop)
 	{
@@ -137,6 +142,19 @@
 			
 		if (m_sg && !current_span_remaining)
 		{
+#if defined (__sh__)
+#define VIDEO_DISCONTINUITY             _IO('o',  84)
+#define DVB_DISCONTINUITY_SKIP  0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+				//eDebug("VIDEO_DISCONTINUITY (fd %d, rc %d)", fd_video, rc);
+			}
+#endif
 			m_sg->getNextSourceSpan(source_pos, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 
@@ -235,6 +253,9 @@
 //		printf("FILEPUSH: read %d bytes\n", m_buf_end);
 	}
 	fdatasync(m_fd_dest);
+#if defined(__sh__)
+	close(fd_video);
+#endif
 
 	eDebug("FILEPUSH THREAD STOP");
 }
diff -Nur enigma2-nightly.org/lib/base/filepush.h enigma2-nightly/lib/base/filepush.h
--- enigma2-nightly.org/lib/base/filepush.h	2009-12-12 23:16:22.400599000 +0100
+++ enigma2-nightly/lib/base/filepush.h	2009-12-12 23:37:07.000000000 +0100
@@ -13,6 +13,11 @@
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	//No idea how this is handeld in dm drivers
+	virtual int getSkipMode()=0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
@@ -51,7 +56,12 @@
 private:
 	iFilePushScatterGather *m_sg;
 	int m_stop;
-	unsigned char m_buffer[65536];
+#if defined(__sh__)
+        //align buffer to standard blocksize of 188
+        unsigned char m_buffer[348*188];
+#else
+        unsigned char m_buffer[65536];
+#endif
 	int m_buf_start, m_buf_end, m_filter_end;
 	int m_fd_dest;
 	int m_send_pvr_commit;
diff -Nur enigma2-nightly.org/lib/base/ioprio.cpp enigma2-nightly/lib/base/ioprio.cpp
--- enigma2-nightly.org/lib/base/ioprio.cpp	2009-12-12 23:16:22.400599000 +0100
+++ enigma2-nightly/lib/base/ioprio.cpp	2009-12-12 23:37:38.000000000 +0100
@@ -28,6 +28,9 @@
	#elif defined(__mips__)
		#define __NR_ioprio_set		4284
		#define __NR_ioprio_get		4285
+	#elif defined(__sh__) 
+		#define __NR_ioprio_set         288 
+		#define __NR_ioprio_get         289 
	#else
		#error "Unsupported arch"
	#endif
diff -Nur enigma2-nightly.org/lib/base/object.h enigma2-nightly/lib/base/object.h
--- enigma2-nightly.org/lib/base/object.h	2009-12-12 23:16:22.400599000 +0100
+++ enigma2-nightly/lib/base/object.h	2009-12-12 23:37:22.000000000 +0100
@@ -169,6 +169,50 @@
 				if (!ref) \
 					delete this; \
 			}
+	#elif defined(__sh__)
+		#define DECLARE_REF(x)                  \
+			private: oRefCount ref;         \
+			public: void AddRef();          \
+					void Release();
+		#define DEFINE_REF(c) \
+			void c::AddRef() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+       				asm volatile( \
+                		"   .align 2              \n\t" \
+                		"   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+                		"   mov    #-6,   r15     \n\t" \
+                		"   mov.l  @%1,   %0      \n\t" \
+                		"   add     #1,   %0      \n\t" \
+                		"   mov.l   %0,   @%1     \n\t" \
+                		"1: mov     r1,   r15     \n\t" \
+                		: "=&r" (tmp),      \
+                  		  "+r"  (v) \
+				:                   \
+                		: "memory" , "r0", "r1" ); \
+			} \
+			void c::Release() \
+			{ \
+				int tmp; \
+				volatile int* v = &(ref.count);\
+			        asm volatile( \
+                		"   .align 2              \n\t" \
+		                "   mova    1f,   r0      \n\t" \
+                		"   mov    r15,   r1      \n\t" \
+ 		                "   mov    #-6,   r15     \n\t" \
+		                "   mov.l  @%1,   %0      \n\t" \
+		                "   add    #-1,   %0      \n\t" \
+		                "   mov.l   %0,   @%1     \n\t" \
+		                "1: mov     r1,   r15     \n\t" \
+		                : "=&r" (tmp),      \
+		                  "+r"  (v) \
+				:                   \
+		                : "memory" , "r0", "r1" ); \
+				if (!ref) \
+					delete this; \
+			}
 	#else
 		#warning use non optimized implementation of refcounting.
 		#define DECLARE_REF(x) 			\
diff -Nur enigma2-nightly.org/lib/driver/Makefile.am enigma2-nightly/lib/driver/Makefile.am
--- enigma2-nightly.org/lib/driver/Makefile.am	2009-12-12 23:16:22.400599000 +0100
+++ enigma2-nightly/lib/driver/Makefile.am	2009-12-12 23:36:16.000000000 +0100
@@ -4,4 +4,4 @@
 noinst_LIBRARIES = libenigma_driver.a
 
 libenigma_driver_a_SOURCES = \
-	rc.cpp rcinput.cpp rcconsole.cpp avswitch.cpp rfmod.cpp etimezone.cpp misc_options.cpp
+	rc.cpp rcinput.cpp rcconsole.cpp avswitch.cpp rfmod.cpp etimezone.cpp misc_options.cpp vfd.cpp
diff -Nur enigma2-nightly.org/lib/driver/vfd.cpp enigma2-nightly/lib/driver/vfd.cpp
--- enigma2-nightly.org/lib/driver/vfd.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/driver/vfd.cpp	2009-12-11 21:40:17.000000000 +0100
@@ -0,0 +1,376 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h> 
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#ifdef PLATFORM_TF7700
+#include "../../misc/tools/tffpctl/frontpanel.h"
+#endif
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF	0xc0425a0a
+#define	VFDDISPLAYCHARS 	0xc0425a00
+#define VFDBRIGHTNESS           0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF    0xc0425a05
+
+bool startloop_running = false;
+static bool icon_onoff[32];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+char chars[64];
+
+
+struct vfd_ioctl_data {
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	memset ( chars, ' ', 63 );
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);	
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+#ifdef PLATFORM_TF7700
+char * getProgress()
+{
+	int n;
+	static char progress[20] = "0";
+	int fd = open ("/proc/progress", O_RDONLY);
+
+	if(fd < 0)
+		return 0;
+
+	n = read(fd, progress, sizeof(progress));
+	close(fd);
+
+	if(n < 0)
+		n = 0;
+	else if((n > 1) && (progress[n-1] == 0xa))
+		n--;
+
+	progress[n] = 0;
+
+	return progress;
+}
+
+#define MAX_CHARS 8
+
+void * start_loop (void *arg)
+{
+	int fplarge = open ("/dev/fplarge", O_WRONLY);
+	int fpsmall = open ("/dev/fpsmall", O_WRONLY);
+	int fpc = open ("/dev/fpc", O_WRONLY);
+
+	if((fplarge < 0) || (fpsmall < 0) || (fpc < 0))
+	{
+		printf("Failed opening devices (%d, %d, %d)\n",
+					fplarge, fpsmall, fpc);
+		return NULL;
+	}
+
+	blocked = true;
+
+	// set scroll mode
+	//frontpanel_ioctl_scrollmode scrollMode = {2, 10, 15};
+	//ioctl(fpc, FRONTPANELSCROLLMODE, &scrollMode);
+	
+	// display string
+	char str[] = "        TEAM DUCKTALES ENIGMA2";
+	int length = strlen(str);
+	char dispData[MAX_CHARS + 1];
+	int offset = 0;
+	int i;
+
+	frontpanel_ioctl_icons icons = {0, 0, 0xf};
+
+	// start the display loop
+	char * progress = getProgress();
+	int index = 2;
+	while(!requested)
+	{
+		// display the CD segments
+		icons.Icons2 = (((1 << index) - 1)) & 0x1ffe;
+		ioctl(fpc, FRONTPANELICON, &icons);
+		index++;
+		if(index > 13)
+		{
+			index = 2;
+			icons.BlinkMode = (~icons.BlinkMode) & 0xf;
+		}
+
+		// display the visible part of the string
+		for(i = 0; i < MAX_CHARS; i++)
+		{
+			dispData[i] = str[(offset + i) % length];
+		}
+		offset++;
+		write(fplarge, dispData, sizeof(dispData));
+		usleep(200000);
+		if((index % 4) == 0)
+		{
+		  // display progress
+		  progress = getProgress();
+		  write(fpsmall, progress, strlen(progress) + 1);
+		  if(strncmp("100", progress, 3) == 0)
+		    break;
+		}
+	}
+
+	// clear all icons
+	frontpanel_ioctl_icons iconsOff = {0xffffffff, 0xffffffff, 0x0};
+	ioctl(fpc, FRONTPANELICON, &iconsOff);
+
+	// clear display
+	write(fpsmall, "    ", 5);
+	write(fplarge, "        ", MAX_CHARS);
+
+	close(fplarge);
+	close(fpsmall);
+	close(fpc);
+	blocked = false;
+
+	return NULL;
+}
+
+#else
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string(" Team Ducktales ", true);
+	//run 2 times through all icons 
+	for  (int vloop = 0; vloop < 128; vloop++) {
+		/*if (vloop%14 == 0 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 1 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 2 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 3 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 4 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 5 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 6 )
+			vfd.vfd_set_brightness(7);
+		else if (vloop%14 == 7 )
+			vfd.vfd_set_brightness(6);
+		else if (vloop%14 == 8 )
+			vfd.vfd_set_brightness(5);
+		else if (vloop%14 == 9 )
+			vfd.vfd_set_brightness(4);
+		else if (vloop%14 == 10 )
+			vfd.vfd_set_brightness(3);
+		else if (vloop%14 == 11 )
+			vfd.vfd_set_brightness(2);
+		else if (vloop%14 == 12 )
+			vfd.vfd_set_brightness(1);
+		else if (vloop%14 == 13 )
+			vfd.vfd_set_brightness(0);*/
+		if (vloop%2 == 1) {
+			vfd.vfd_set_icon( (tvfd_icon) (((vloop%32)/2)%16), ICON_OFF, true);
+			//usleep(1000);
+			vfd.vfd_set_icon( (tvfd_icon) ((((vloop%32)/2)%16)+1), ICON_ON, true);
+		}
+		usleep(75000);
+	}
+	vfd.vfd_set_brightness(7);
+	
+	//set all blocked icons
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd.vfd_set_icon((tvfd_icon)id, icon_onoff[id]);	
+	}
+
+	blocked = false;
+	return NULL;
+}
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_write_string(char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(char * str, bool force)
+{
+	int i;
+	i = strlen ( str );
+	if ( i > 63 ) i = 63;
+	memset ( chars, ' ', 63 );
+	memcpy ( chars, str, i);	
+
+#ifdef PLATFORM_TF7700
+
+	// request the display to cancel the start loop
+	requested = true;
+	while(blocked) usleep(200000);
+
+	{
+#else
+	if (!blocked || force) {
+#endif
+		struct vfd_ioctl_data data;
+		memset ( data.data, ' ', 63 );
+		memcpy ( data.data, str, i );	
+
+		data.start = 0;
+		data.length = i;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+	return;
+}
+
+void evfd::vfd_write_string_scrollText(char* text) {
+	if (!blocked) {
+		int i, len = strlen(text);
+		char* out = (char *) malloc(16);
+
+		for (i=0; i<=(len-16); i++) { // scroll text till end
+			memset(out, ' ', 16);
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++) { // scroll text with whitespaces from right
+			memset(out, ' ', 16);
+			memcpy(out, text+len+i-16, 16-i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+		free (out);
+	}
+	return;
+}
+
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	vfd_set_icon(id, onoff, false);
+	return;
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+	icon_onoff[id] = onoff;
+
+	if (!blocked || force) {
+		struct vfd_ioctl_data data;
+
+		if (!startloop_running) {
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+			data.start = 0x00;
+    			data.data[0] = id & 0x0f;
+    			data.data[4] = onoff;
+    			data.length = 5;
+
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+    			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+	return;
+}
+
+void evfd::vfd_clear_icons()
+{
+	for (int id = 0x10; id < 0x20; id++) {
+		vfd_set_icon((tvfd_icon)id, false);	
+	}
+	return;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+
+	return;
+}
+
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+    	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+
+    	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
diff -Nur enigma2-nightly.org/lib/driver/vfd.h enigma2-nightly/lib/driver/vfd.h
--- enigma2-nightly.org/lib/driver/vfd.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/driver/vfd.h	2009-12-11 21:40:17.000000000 +0100
@@ -0,0 +1,40 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+typedef enum { USB = 0x10, HD, HDD, LOCK, BT, MP3, MUSIC, DD, MAIL, MUTE, PLAY, PAUSE, FF, FR, REC, CLOCK } tvfd_icon;
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(char * string);
+	void vfd_write_string(char * str, bool force);
+	void vfd_write_string_scrollText(char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+};
+
+
+#endif
diff -Nur enigma2-nightly.org/lib/dvb/decoder.cpp enigma2-nightly/lib/dvb/decoder.cpp
--- enigma2-nightly.org/lib/dvb/decoder.cpp	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/decoder.cpp	2009-12-12 23:25:40.816600405 +0100
@@ -1019,12 +1019,22 @@
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) 
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif 
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__) 
+/* 
+the VIDEO_CONTINUE would reset the FASTFORWARD  command so we 
+execute the FASTFORWARD after the VIDEO_CONTINUE
+*/ 
+			m_video->setSlowMotion(s[1]); 
+			m_video->setFastForward(s[2]); 
+#endif 
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1300,6 +1310,10 @@
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__)  
+			if (m_video_clip_fd >= 0)  
+				finishShowSinglePic();  
+#endif  
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY|O_NONBLOCK);
 			if (m_video_clip_fd >= 0)
@@ -1333,7 +1347,9 @@
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				write(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__) 
 				m_showSinglePicTimer->start(150, true);
+#endif 
 			}
 			close(f);
 		}
diff -Nur enigma2-nightly.org/lib/dvb/demux.cpp enigma2-nightly/lib/dvb/demux.cpp
--- enigma2-nightly.org/lib/dvb/demux.cpp	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/demux.cpp	2009-12-12 23:26:50.201100339 +0100
@@ -526,6 +526,9 @@
 		eDebug("FAILED to open dvr (%s) in ts recoder (%m)", filename);
 		return -3;
 	}
+#if defined(__sh__) 
+	::ioctl(m_source_fd, DMX_SET_BUFFER_SIZE, 256*1024); 
+#endif
 #else
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
 
diff -Nur enigma2-nightly.org/lib/dvb/dvb.cpp enigma2-nightly/lib/dvb/dvb.cpp
--- enigma2-nightly.org/lib/dvb/dvb.cpp	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/dvb.cpp	2009-12-13 11:49:35.249764000 +0100
@@ -96,6 +96,32 @@
 		m_boxtype = DM800;
 	else if (!strncmp(tmp, "dm500hd\n", rd))
 		m_boxtype = DM500HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+#endif
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -540,7 +552,58 @@
 			}
 		}
 	}
+#if defined(__sh__)
+	else if (m_boxtype == UFS910 || m_boxtype == UFS922 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX || m_boxtype == HL101 ||
+		m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || 
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD )
+	{
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter &&
+				    i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
 
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	if (unused)
 	{
 		demux = new eDVBAllocatedDemux(unused);
@@ -1752,8 +1813,15 @@
 #if HAVE_DVB_API_VERSION < 3
 		m_pvr_fd_dst = open("/dev/pvr", O_WRONLY);
 #else
+#if defined(__sh__)
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		m_pvr_fd_dst = open("/dev/misc/pvr", O_WRONLY);
 #endif
+#endif
 		if (m_pvr_fd_dst < 0)
 		{
 			eDebug("can't open /dev/misc/pvr - you need to buy the new(!) $$$ box! (%m)"); // or wait for the driver to be improved.
diff -Nur enigma2-nightly.org/lib/dvb/dvb.h enigma2-nightly/lib/dvb/dvb.h
--- enigma2-nightly.org/lib/dvb/dvb.h	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/dvb.h	2009-12-13 11:43:17.189265000 +0100
@@ -135,7 +135,11 @@
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if defined(__sh__)
+	enum { DM7025, DM800, DM500HD, DM8000, UFS910, UFS922, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD};
+#else
 	enum { DM7025, DM800, DM500HD, DM8000 };
+#endif
 
 	int m_boxtype;

@@ -245,6 +249,10 @@
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__)
+//see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff -Nur enigma2-nightly.org/lib/dvb/epgcache.cpp enigma2-nightly/lib/dvb/epgcache.cpp
--- enigma2-nightly.org/lib/dvb/epgcache.cpp	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/epgcache.cpp	2009-12-13 00:37:45.000000000 +0100
@@ -115,11 +115,25 @@
 	int tmp = ByteSize-10;
 	memcpy(data, EITdata, 10);
 	int descriptors_length=0;
+#ifndef __sh__
 	__u32 *p = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while(tmp>3)
 	{
+#ifndef __sh__
 		descriptorMap::iterator it =
 			descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);			*/
+		descriptorMap::iterator it =
+			descriptors.find(index);
+
+		p += 4;
+#endif
 		if ( it != descriptors.end() )
 		{
 			int b = it->second.second[1]+2;
@@ -128,7 +142,11 @@
 			descriptors_length += b;
 		}
 		else
+#ifndef __sh__
 			eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-1));
+#else
+			eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(p-4));
+#endif
 		tmp-=4;
 	}
 	ASSERT(pos <= 4108);
@@ -142,12 +160,28 @@
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
+
+#ifndef __sh__
 		__u32 *d = (__u32*)(EITdata+10);
+#else
+/* Dagobert: fix not aligned access */
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+/* eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);			*/
+			descriptorMap::iterator it =
+				descriptors.find(index);
+				
+			d += 4;
+#endif
+
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -159,7 +193,15 @@
 				}
 			}
 			else
+			{
+#ifndef __sh__
 				eFatal("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-1));
+#else
+//Dagobert: currently this happens sporadicly on ufs922 (with new skin). Not sure why
+//we must observe this!
+				eDebug("LINE %d descriptor not found in descriptor cache %08x!!!!!!", __LINE__, *(d-4));
+#endif
+			}
 			ByteSize -= 4;
 		}
 		delete [] EITdata;
@@ -954,6 +996,9 @@
 {
 	hasStarted();
 	nice(4);
+#ifdef __sh__ 
+	InitEPGBlock (); 
+#endif 
 	load();
 	cleanLoop();
 	runLoop();
@@ -1414,7 +1459,51 @@
 	pthread_mutex_unlock(&channel_active);
 }
 
-
+#ifdef __sh__
+void eEPGCache::InitEPGBlock ()
+{
+	FILE *fd = NULL;
+	fd = fopen ("/etc/enigma2/epg.blacklist", "r");
+	if (fd)
+	{
+		char line[256];
+		while (fgets (line, sizeof(line), fd))
+		{
+			char* tmp;
+			epg_block_list_t block_item;
+			if (!(tmp = strtok (line, ","))) continue;
+			block_item.service_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.transport_stream_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.original_network_id = atoi (tmp);
+			if (!(tmp = strtok (NULL, ","))) continue;
+			block_item.source = atoi (tmp);
+			block_list.push_back (block_item);
+		}
+		fclose (fd);
+		eDebug ("[EPGC] Blacklist loaded");
+	}
+	else eDebug ("[EPGC] No blacklist found");
+}
+
+bool eEPGCache::CheckEPGBlock (int32_t service_id, uint16_t transport_stream_id, uint16_t original_network_id, int source)
+{
+	std::list<epg_block_list_t>::iterator i;
+	
+	for (i=block_list.begin(); i != block_list.end(); ++i)
+		if ((i->service_id == service_id || service_id == -1) &&
+			i->transport_stream_id == transport_stream_id &&
+			i->original_network_id == original_network_id &&
+			i->source == source)
+	{
+		eDebug ("[EPGC] Blacklist active!");
+		return true;
+	}
+	
+	return false;
+}
+#endif
 void eEPGCache::channel_data::readDataViasat( const __u8 *data)
 {
 	__u8 *d=0;
@@ -1428,6 +1517,47 @@
 	int source;
 	int map;
 	iDVBSectionReader *reader=NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is 
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */ 
+	const __u8 *aligned_data;
+	bool isNotAligned = false;
+	
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+		
+	if (isNotAligned)
+	{
+	
+	   /* see HILO macro and eit.h */
+	   int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+           /*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+	   if ( EIT_SIZE >= len )
+		   return;
+
+	   aligned_data = (const __u8 *) malloc(len);
+
+	   if ((unsigned int)aligned_data % 4 != 0)
+	   {
+		   eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+	   }
+
+           /*eDebug("%p %p\n", aligned_data, data); */
+	   memcpy((void *) aligned_data, (const __u8 *) data, len);
+	   data = aligned_data;	
+	}	
+#endif
+
 	switch(data[0])
 	{
 		case 0x4E ... 0x4F:
@@ -1490,6 +1620,17 @@
 	else
 	{
 		eit_t *eit = (eit_t*) data;
+#ifdef __sh__
+		if (eEPGCache::getInstance()->CheckEPGBlock (eit->service_id_hi << 8 | eit->service_id_lo,
+							eit->transport_stream_id_hi << 8 | eit->transport_stream_id_lo,
+							eit->original_network_id_hi << 8 | eit->original_network_id_lo,
+							source))
+		{
+			if (isNotAligned)
+			   free((void *) aligned_data);
+			return;
+		}
+#endif
 		__u32 sectionNo = data[0] << 24;
 		sectionNo |= data[3] << 16;
 		sectionNo |= data[4] << 8;
@@ -1517,6 +1658,10 @@
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+	   free((void *)aligned_data);
+#endif	
 }
 
 RESULT eEPGCache::lookupEventTime(const eServiceReference &service, time_t t, const eventData *&result, int direction)
@@ -2243,11 +2388,22 @@
 						{
 							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
+#ifndef __sh__
 							__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+							__u8 *p = (__u8*)(data+10);
+#endif
 								// search short and extended event descriptors
 							while(tmp>3)
 							{
+#ifndef __sh__
 								__u32 crc = *p++;
+#else
+/* Dagobert: Alignment fix */
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
@@ -2425,12 +2581,23 @@
 					continue;
 				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
+#ifndef __sh__
 				__u32 *p = (__u32*)(data+10);
+#else
+/* Dagobert: Alignment fix */
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
+#ifndef __sh__
 					__u32 crc32 = *p++;
+#else
+/* Dagobert: Alignment fix */
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
@@ -2562,7 +2729,11 @@
 								{
 									__u8 buffer[10];
 									(*desc)->writeToBuffer(buffer);
+#ifdef __sh__
+									if (!strncmp((const char*)buffer+2, "EPGDATA", 7))
+#else
 									if (!strncmp((unsigned char*)buffer+2, "EPGDATA", 7))
+#endif
 									{
 										eServiceReferenceDVB ref;
 										if (!pmthandler->getServiceReference(ref))
@@ -2571,7 +2742,11 @@
 											messages.send(Message(Message::got_mhw2_channel_pid, ref, pid));
 										}
 									}
+#ifdef __sh__
+									else if(!strncmp((const char*)buffer+2, "FICHAS", 6))
+#else
 									else if(!strncmp((unsigned char*)buffer+2, "FICHAS", 6))
+#endif
 									{
 										eServiceReferenceDVB ref;
 										if (!pmthandler->getServiceReference(ref))
@@ -2580,7 +2755,11 @@
 											messages.send(Message(Message::got_mhw2_summary_pid, ref, pid));
 										}
 									}
+#ifdef __sh__
+									else if(!strncmp((const char*)buffer+2, "GENEROS", 7))
+#else
 									else if(!strncmp((unsigned char*)buffer+2, "GENEROS", 7))
+#endif
 									{
 										eServiceReferenceDVB ref;
 										if (!pmthandler->getServiceReference(ref))
diff -Nur enigma2-nightly.org/lib/dvb/epgcache.h enigma2-nightly/lib/dvb/epgcache.h
--- enigma2-nightly.org/lib/dvb/epgcache.h	2009-12-12 23:16:22.404599000 +0100
+++ enigma2-nightly/lib/dvb/epgcache.h	2009-12-13 00:33:37.000000000 +0100
@@ -2,7 +2,11 @@
 #define __epgcache_h_
 
 #define ENABLE_PRIVATE_EPG 1
+#if defined(__sh__) 
+#define ENABLE_MHW_EPG 1 
+#else
 //#define ENABLE_MHW_EPG 1
+#endif
 
 #ifndef SWIG
 
@@ -291,7 +295,9 @@
 
 // called from epgcache thread
 	void save();
+#ifndef __sh__
 	void load();
+#endif
 #ifdef ENABLE_PRIVATE_EPG
 	void privateSectionRead(const uniqueEPGKey &, const __u8 *);
 #endif
@@ -312,8 +318,24 @@
 	eEPGCache();
 	~eEPGCache();
 #endif // SWIG
+#ifdef __sh__
+	typedef struct epg_block_list_s
+	{
+		uint16_t	service_id;
+		uint16_t	transport_stream_id;
+		uint16_t	original_network_id;
+		int 		source;
+	} epg_block_list_t;
+	std::list<epg_block_list_t> block_list;
+#endif
 public:
 	static eEPGCache *getInstance() { return instance; }
+#ifdef __sh__
+	void load();
+	void InitEPGBlock ();
+	bool CheckEPGBlock (int32_t service_id, uint16_t transport_stream_id, uint16_t original_network_id, int source);
+#endif
+
 #ifndef SWIG
 	eEPGCache();
 	~eEPGCache();
diff -Nur enigma2-nightly.org/lib/dvb/frontend.cpp enigma2-nightly/lib/dvb/frontend.cpp
--- enigma2-nightly.org/lib/dvb/frontend.cpp	2009-12-12 23:16:22.408600000 +0100
+++ enigma2-nightly/lib/dvb/frontend.cpp	2009-12-12 23:22:30.716600097 +0100
@@ -2051,8 +2051,22 @@
 					return -EINVAL;
 			}
 #if HAVE_DVB_API_VERSION < 5
+#if not defined(__sh__)  
 			parm_inversion |= (feparm.rolloff << 2); // Hack.. we use bit 2..3 of inversion param for rolloff
 			parm_inversion |= (feparm.pilot << 4); // Hack.. we use bit 4..5 of inversion param for pilot
+#else 
+//Dagobert: Interesting: I must have misted the fact that someone has removed this since a long time. 
+//So it is needed by the driver (cxNNNNN.c) but it seems not be very important ;) 
+			int hack; 
+
+			hack = (int) parm_inversion; 
+
+			hack |= (int) (feparm.rolloff << 2); // Hack.. we use bit 2..3 of inversion param for rolloff 
+			hack |= (int) (feparm.pilot << 4); // Hack.. we use bit 4..5 of inversion param for pilot 
+
+			parm_inversion = (fe_spectral_inversion_t) hack; 
+#endif 
+
 			if (feparm.modulation == eDVBFrontendParametersSatellite::Modulation_8PSK) 
 			{
 				parm_u_qpsk_fec_inner = (fe_code_rate_t)((int)parm_u_qpsk_fec_inner+9);
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_appmgr.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_appmgr.cpp	2009-12-12 23:38:14.000000000 +0100
@@ -6,17 +6,32 @@
 
 eDVBCIApplicationManagerSession::eDVBCIApplicationManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setAppManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIApplicationManagerSession::~eDVBCIApplicationManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setAppManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIApplicationManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/APP %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -58,11 +73,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIApplicationManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
   switch (state)
   {
   case stateStarted:
@@ -70,6 +91,9 @@
     const unsigned char tag[3]={0x9F, 0x80, 0x20}; // application manager info e    sendAPDU(tag);
 		sendAPDU(tag);
     state=stateFinal;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 1;
   }
   case stateFinal:
@@ -81,19 +105,35 @@
       const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
       sendAPDU(tag);
       wantmenu=0;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
       return 0;
     } else
       return 0;
   default:
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
     return 0;
   }
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIApplicationManagerSession::startMMI()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }

diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_camgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_camgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_camgr.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_camgr.cpp	2009-12-12 23:38:33.000000000 +0100
@@ -5,17 +5,32 @@
 
 eDVBCICAManagerSession::eDVBCICAManagerSession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setCAManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCICAManagerSession::~eDVBCICAManagerSession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot->setCAManager(NULL);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCICAManagerSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/CA %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -41,11 +56,17 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCICAManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -53,21 +74,38 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x30}; // ca info enq
 		sendAPDU(tag);
 		state=stateFinal;
+#ifdef __sh__
+		//Dagobert disable polling
+		slot->setPoll(false);
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCICAManagerSession::sendCAPMT(unsigned char *data, int len)
 {
 	const unsigned char tag[3]={0x9F, 0x80, 0x32}; // ca_pmt
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendAPDU(tag, data, len);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }

diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci.cpp enigma2-nightly/lib/dvb_ci/dvbci.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci.cpp	2009-12-12 23:39:38.000000000 +0100
@@ -16,6 +16,10 @@
 #include <lib/dvb_ci/dvbci_appmgr.h>
 #include <lib/dvb_ci/dvbci_mmi.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+#endif
+
 #include <dvbsi++/ca_program_map_section.h>
 
 //#define CIDEBUG 1
@@ -28,6 +32,175 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+
+#define x_debug
+
+/* ******************************************* */
+/* our module list */
+
+#define module_list "/usr/local/share/enigma2/module.list"
+
+struct module_s
+{
+	char 	name[256];
+	int	polling_time;
+};
+
+static struct module_s* our_modules = NULL;
+static int no_modules = 0;
+
+int getModulePollTimeFromFile(const char* ourModule)
+{
+	eDebug("%s ->%s\n", __func__, ourModule);
+
+	if (ourModule == NULL)
+		return -1;
+		
+	if (our_modules == NULL)
+	{
+		FILE* fd = fopen(module_list, "r");
+		char  buffer[512];
+		
+		if (fd == NULL)
+		{
+			eDebug("error reading module list (%s)\n", module_list);
+			return -1;
+		}
+		
+		while (fgets(buffer, 512, fd) != NULL)
+		{
+			if ((buffer[0] == '#') || (buffer[0] ==  '!'))
+				continue;
+				
+			no_modules++;
+			our_modules = (struct module_s*) realloc(our_modules, sizeof(struct module_s) * no_modules);
+
+			sscanf(buffer, "%s %d", 
+				our_modules[no_modules - 1].name, 
+				&our_modules[no_modules - 1].polling_time);
+
+			eDebug("%d. name = %s - pollTime = %d", no_modules - 1, our_modules[no_modules - 1].name,
+								our_modules[no_modules - 1].polling_time);
+		}
+	}
+
+	for (int vLoop = 0; vLoop < no_modules; vLoop++)
+	{
+		eDebug("%d. %s ->pollTime = %d", vLoop, our_modules[vLoop].name, our_modules[vLoop].polling_time);
+	
+		if (strlen(ourModule) < strlen(our_modules[vLoop].name))		
+			continue;
+			
+		if (strstr(ourModule, our_modules[vLoop].name) != NULL)
+		{
+			eDebug("%d. found module in list (%s) ->pollTime = %d", vLoop, our_modules[vLoop].name, our_modules[vLoop].polling_time);
+			return our_modules[vLoop].polling_time;
+		}
+	}
+	
+	eDebug("Module not found in %s ->default poll time = 100ms", module_list);
+	
+	return 100;
+}
+
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+
+}
+
+void eDVBCISlot::thread()
+{
+	eDebug("eDVBCISlot::%s >\n",__func__); 
+
+	hasStarted();
+	nice(4);
+
+	//I want to sleep a little until all is really read
+	//->we should fix this later and determine while polling
+	//starts to early
+	sleep(2);
+
+	while (1)
+	{
+		int poller = 0;
+		
+		if ((getState() == stateInserted) ||
+		    (getState() == stateResetted))
+		{
+		
+		   std::string appname = eDVBCI_UI::getInstance()->getAppName(getSlotID());
+
+		   //eDebug("appname %s\n", appname.c_str());
+
+		   if (appname.empty())
+		   {
+			poller = 100;	
+		   } else
+		   {
+		   	if (getModulePollTime() == -1)
+			   setModulePollTime(getModulePollTimeFromFile(appname.c_str()));
+		   
+		   	poller = getModulePollTime();
+		   }
+
+		   if (getPoll())
+		   {
+			   struct timeval last = getPollTime();
+			   struct timeval now;
+			   struct timezone dummy;
+
+			   //during menu actions, or if the mmi_sessions is not ready we poll regardless if the
+			   //configuration says us not to poll
+			   if ((poller == 0) && ((mmi_active) || (ca_manager == 0)))
+				   poller = 100;
+
+			   /* dagobert: there maybe a ca_manager but the caids has not yet been
+			    * delivered so lets poll ...
+			    */	
+                           if ((ca_manager != 0) && (ca_manager->getCAIDs().empty() == true))
+			   {	
+				   poller = 100;
+			   	   
+				   //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x, %d\n", poller, mmi_active, ca_manager, ca_manager->getCAIDs().empty());
+			   } else
+                           if (ca_manager != 0)
+			   {
+				   //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x, %d\n", poller, mmi_active, ca_manager, ca_manager->getCAIDs().empty());
+			   }
+			   else		
+			   {	   
+			           //eDebug("pollTime %d, mmi_active = %d, ca_manager = %x\n", poller, mmi_active, ca_manager);
+			   }
+
+			   if (poller != 0)
+
+			   {
+			      gettimeofday(&now, &dummy);
+
+			      if ((difftime(now.tv_sec, last.tv_sec) != 0) ||
+				(now.tv_usec >= last.tv_usec + (poller * 1000)))
+			      {
+				 //send a data last (0xa0) message if there are no messages waiting in the queue
+				 if (checkQueueSize() == false)
+				    send(NULL, 0);
+				 setPollTime(now);
+			      }
+			   }
+		    }
+		}
+
+		if (poller != 0)
+			usleep(poller * 1000);
+		else
+			usleep(1000000);
+		
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -40,10 +213,21 @@
 	{
 		struct stat s;
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (stat(filename, &s))
+#ifdef __sh__
+		{
+			eDebug("stat on %s failed\n", filename);		
+#endif
 			break;
+#ifdef __sh__
+		}
+#endif
 
 		ePtr<eDVBCISlot> cislot;
 
@@ -105,6 +289,9 @@
 int eDVBCIInterfaces::reset(int slotid)
 {
 	eDVBCISlot *slot;
+#ifdef __sh__
+	eDebug("eDVBCIInterfaces::reset %d\n", slotid);
+#endif
 
 	if( (slot = getSlot(slotid)) == 0 )
 		return -1;
@@ -940,9 +1127,80 @@
 	return -1;
 }
 
+#ifdef __sh__
+/* ********************** start of __sh__ ************************* */
+
+
+/* taken from dvb-apps 
+ * todo / fixme: add copyright etc ...
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+#endif
+
+
 int eDVBCISlot::send(const unsigned char *data, size_t len)
 {
 	int res=0;
+#ifdef __sh__
+#ifdef x_debug
+	eDebug("eDVBCISlot::send >\n");
+#endif	
+
+		unsigned char *d = new unsigned char[len + 5];
+		
+		// only poll connection if we are not awaiting an answer
+		pollConnection = false;
+		
+		/* should we send a data last ?
+		 */
+		if (data != NULL)
+		{
+		   if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		   {
+		      memcpy(d, data, len);
+		   } else
+		   {
+		      //send data_last and data
+		      memcpy(d + 5, data, len);
+
+		      d[0] = getSlotID();
+		      d[1] = connection_id;
+		      d[2] = T_DATA_LAST; 	
+		      d[3] = len + 1; 		/* len */
+		      d[4] = connection_id; 	/* transport connection identifier*/
+
+		      len += 5;	
+		   }
+		}
+		else
+		{
+		      //send a data last only
+		      d[0] = getSlotID();
+		      d[1] = connection_id;
+		      d[2] = T_DATA_LAST; 	
+		      d[3] = len + 1; 		/* len */
+		      d[4] = connection_id; 	/* transport connection identifier*/
+
+		      len = 5;	
+		}
+#ifdef x_debug
+		eDebugNoNewLine("write (%d): > ", getSlotID());
+		for(int i=0; i < len; i++)
+			eDebugNoNewLine("%02x ",d[i]);
+#endif
+#else
 	//int i;
 	//eDebugNoNewLine("< ");
 	//for(i=0;i<len;i++)
@@ -956,19 +1214,224 @@
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#endif
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#ifdef __sh__
+#ifdef x_debug
+	eDebug("eDVBCISlot::send <\n");
+#endif
+#else
 	}
+#endif
 
 	return res;
 }
 
+#ifdef __sh__
+/* from dvb-apps
+ * fixme: add copyright and url
+ */
+int asn_1_decode(uint16_t * length, uint8_t * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+void eDVBCISlot::process_tpdu(char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+      switch (tpdu_tag) 
+      {
+	 case T_C_T_C_REPLY:
+	      eDebug("Got CTC Replay (slot %d, con %d)\n", getSlotID(), con_id);
+
+	      //answer with data last (and if we have with data)
+	      send(NULL, 0);
+	      
+	      break;
+	 case T_DELETE_T_C:
+//FIXME: close sessions etc; slot->reset ?
+//we must answer here with t_c_replay
+
+	      eDebug("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+	      
+	      break;
+	 case T_D_T_C_REPLY:
+
+	      eDebug("Got \"Delete Transport Connection Replay\" from module!\n");
+	      break;
+
+	 case T_REQUEST_T_C:
+
+	      eDebug("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+
+	      break;
+	 case T_DATA_MORE:
+	 {
+		int new_data_length = received_len + asn_data_length;
+
+	        eDebug("Got \"Data More\" from Module\n");
+
+		__u8 *new_data_buffer = (__u8*)
+	    		realloc(received_data, new_data_length);
+	
+		received_data = new_data_buffer;
+
+		memcpy(received_data + received_len, data, asn_data_length);
+		
+		received_len = new_data_length;
+					
+	      break;
+	 }
+	 case T_DATA_LAST:
+	 
+	        eDebug("Got \"Data Last\" from Module\n");
+		
+		/* single package */
+	        if (received_data == NULL) 
+		{
+
+	        	eDebug("->single package\n");
+#ifdef x_debug	
+			eDebugNoNewLine("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < asn_data_length; i++)
+				eDebugNoNewLine("%02x ", data[i]);
+#endif
+
+			eDVBCISession::receiveData(this, data, asn_data_length);
+			eDVBCISession::pollAll();
+		} else 
+		{
+			/* chained package */
+			int new_data_length = received_len + asn_data_length;
+
+	        	eDebug("->chained data\n");
+
+			__u8 *new_data_buffer =
+	    			(__u8*) realloc(received_data, new_data_length);
+	
+			received_data = new_data_buffer;
+
+			memcpy(received_data + received_len, data, asn_data_length);
+		
+			received_len = new_data_length;
+					
+			free(received_data);
+			received_data = NULL;
+			received_len = 0;
+
+#ifdef x_debug	
+			eDebugNoNewLine("calling receiveData with data (len %d)> ", asn_data_length);
+			for(int i = 0;i < received_len; i++)
+				eDebugNoNewLine("%02x ", received_data[i]);
+#endif
+
+			eDVBCISession::receiveData(this, received_data, received_len);
+			eDVBCISession::pollAll();
+		}
+	      break;
+	 case T_SB:
+	 {
+	      eDebug("Got \"SB\" from Module\n");
+
+	      if (data[0] & 0x80)
+	      {
+	      	eDebug("->data ready (%d)\n", getSlotID());
+	
+		//we now wait for an answer so dont poll
+		pollConnection = false;
+
+		// send the RCV and ask for the data
+		unsigned char* send_data = new unsigned char[5];
+
+
+		send_data[0] = getSlotID();
+		send_data[1] = connection_id;
+		send_data[2] = T_RCV;
+		send_data[3] = 1;
+		send_data[4] = connection_id;
+
+#ifdef not_direct
+		sendqueue.push( queueData(send_data, 5));
+#else
+		write(fd, send_data, 5);
+		delete send_data;
+#endif
+	      } else
+	      {
+	        //if the queue is not empty we dont need to send
+		//a polling to the module.
+		if (checkQueueSize() == false)
+			pollConnection = true;
+	      }	
+
+	      break;
+	 }
+	 default:
+	      eDebug("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+      }
+}
+#endif
+
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
 	if(what == eSocketNotifier::Priority) {
+#ifdef __sh__
+#ifdef x_debug	
+	eDebug("pollpri\n");
+#endif
+		if ((state == stateInvalid) || (state == stateRemoved))
+		{
+			unsigned char data[5];
+
+			eDebug("ci inserted\n");
+/* doing a hw reset is time wasting because the hw must be initilized. but
+ * the polling mechanism of e2 starts right in the moment where many
+ * other things started. doing no reset here seems to lead in some
+ * missing packages from/to module and so the connection at startup
+ * sometimes does not work.
+ *
+ * I think a proper solution is todo the sending of T_create after a
+ * time offset in the thread?!
+ */
+			reset();
+		} else
+		if((state == stateInserted) || (state == stateResetted))
+		{
+#else
 		if(state != stateRemoved) {
+#endif
 			state = stateRemoved;
+#ifdef __sh__
+			eDebug("ci removed\n");
+			/* kill thread */
+			kill(true);
+#endif	
 			while(sendqueue.size())
 			{
 				delete [] sendqueue.top().data;
@@ -976,12 +1439,17 @@
 			}
 			eDVBCISession::deleteSessions(this);
 			eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#ifdef __sh__
+			notifier->setRequested(eSocketNotifier::Write | eSocketNotifier::Read | eSocketNotifier::Priority);
+#else
 			notifier->setRequested(eSocketNotifier::Read);
+#endif
 			eDVBCI_UI::getInstance()->setState(getSlotID(),0);
 		}
 		return;
 	}
-
+#ifdef __sh__
+#else
 	if (state == stateInvalid)
 		reset();
 
@@ -992,11 +1460,86 @@
 		notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 		/* enable PRI to detect removal or errors */
 	}
+#endif
 
 	if (what & eSocketNotifier::Read) {
+#ifdef __sh__
+		__u8* data = (__u8*) malloc(4096);
+#else
 		__u8 data[4096];
+#endif
 		int r;
+#ifdef __sh__
+		__u8* orig_data = data;
+#ifdef x_debug	
+		eDebug("pollin\n");
+#endif
+		pollConnection = false;
+#endif
 		r = ::read(fd, data, 4096);
+#ifdef __sh__
+		if (r < 0)
+		{
+			eDebug("r = %d, errno = %d\n", r, errno);
+			eDebug("%s", strerror(errno));
+		}
+
+		eDebug("read %d bytes for slot %d\n", r, getSlotID());
+
+#ifdef x_debug	
+		eDebugNoNewLine("read (%d): > ", getSlotID());
+		for(int i = 0; i < r; i++)
+			eDebugNoNewLine("%02x ",data[i]);
+		eDebug("");
+#endif
+
+
+		int s_id = data[0];
+		int c_id = data[1];
+		
+		eDebug("%d: s_id = %d, c_id = %d\n", getSlotID(), s_id, c_id);
+
+		/* taken from the dvb-apps */
+		int data_length = r - 2;
+		data += 2; /* remove leading slot and connection id */
+		while (data_length > 0)
+		{
+			unsigned char tpdu_tag = data[0];
+			unsigned short asn_data_length;
+			int length_field_len;
+		
+			if ((length_field_len = asn_1_decode(&asn_data_length, data + 1, data_length - 1)) < 0) 
+			{
+				eDebug("Received data with invalid asn from module on slot %02x\n", getSlotID());
+				break;
+			}
+
+			if ((asn_data_length < 1) ||
+		    	    (asn_data_length > (data_length - (1 + length_field_len)))) 
+			{
+				eDebug("Received data with invalid length from module on slot %02x\n", getSlotID());
+				break;
+			}
+
+			connection_id = data[1 + length_field_len];
+		
+			//eDebug("Setting connection_id from received data to %d\n", connection_id);
+		
+			data += 1 + length_field_len + 1;
+			data_length -= (1 + length_field_len + 1);
+			asn_data_length--;
+
+			process_tpdu(tpdu_tag, data, asn_data_length, connection_id);
+			
+			// skip over the consumed data
+			data += asn_data_length;
+			data_length -= asn_data_length;
+
+		} // while (data_length)
+	
+		if (orig_data != NULL)
+			free(orig_data);
+#else
 		if(r > 0) {
 //			int i;
 //			eDebugNoNewLine("> ");
@@ -1007,19 +1550,49 @@
 			eDVBCISession::pollAll();
 			return;
 		}
+#endif
 	}
 	else if (what & eSocketNotifier::Write) {
+#ifdef __sh__
+#ifdef x_debug	
+		eDebug("pollout\n");
+#endif
+#endif
 		if (!sendqueue.empty()) {
 			const queueData &qe = sendqueue.top();
+#ifdef __sh__
+#ifdef x_debug	
+			eDebugNoNewLine("sendqueue (%d) > ", getSlotID());
+			for(int i = 0;i < qe.len;i++)
+				eDebugNoNewLine("%02x ", qe.data[i]);
+#endif
+#endif
 			int res = ::write(fd, qe.data, qe.len);
 			if (res >= 0 && (unsigned int)res == qe.len)
 			{
+#ifdef __sh__
+				eDebug("sendqueue: write %d data on fd %d\n", res, fd);
+#endif
 				delete [] qe.data;
 				sendqueue.pop();
 			}
+#ifdef __sh__
+			else
+			{
+				eDebug("r = %d, errno = %d, %s\n", res, errno, strerror(errno));
+			}			
+#endif
 		}
 		else
+#ifdef __sh__
+		{
+		   eDebug("sendqueue emtpy\n");
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
+		   pollConnection = true;
+		}
+#else
+			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority); 
+#endif
 	}
 }
 
@@ -1039,7 +1612,11 @@
 	
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1050,8 +1627,21 @@
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	/* init buffer to NULL (see T_DATA_LAST and MORE) */
+	received_data = NULL;
+	received_len = 0;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+
+		pollConnection = false;
+		last_poll.tv_sec = 0;
+		last_poll.tv_usec = 0;
+		pollTime = -1;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
 	} else
@@ -1063,7 +1653,14 @@
 eDVBCISlot::~eDVBCISlot()
 {
 	eDVBCISession::deleteSessions(this);
-}
+#ifdef __sh__
+	/* kill thread */
+	kill(true);
+#endif	
+}
+#ifdef __sh__
+/* ********************** end of __sh__ ************************* */
+#endif	
 
 void eDVBCISlot::setAppManager( eDVBCIApplicationManagerSession *session )
 {
@@ -1085,10 +1682,25 @@
 	return slotid;
 }
 
+#ifdef __sh__
+/* ********************** start of __sh__ ************************* */
+#endif
 int eDVBCISlot::reset()
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
-
+#ifdef __sh__
+	/* kill thread */
+	kill(true);
+
+	state = stateResetted;
+
+	pollConnection = false;
+	last_poll.tv_sec = 0;
+	last_poll.tv_usec = 0;
+	pollTime = -1;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1096,6 +1708,7 @@
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif	
 
 	while(sendqueue.size())
 	{
@@ -1103,11 +1716,74 @@
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+
+	ca_slot_info_t info;
+
+	info.num = slotid;
+
+	eDebug("waiting on cam on slot %d\n", slotid);
+
+	//we block until we have a connection or failed
+	int count = 0;
+	while (count != 50)
+	{
+		count++;
+	   	if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+			eDebug("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", slotid);
+
+	   	if (info.flags & CA_CI_MODULE_READY)
+			break;
+	   	
+#ifdef later
+		if ((info.flags & CA_CI_MODULE_INVALID) && (count > 5))
+			break;
+#endif			
+		usleep(100000);
+	}
+
+	if (info.flags & CA_CI_MODULE_READY)
+        {
+		unsigned char data[5];
+
+		eDebug("cam present\n");
+
+		eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+		notifier->setRequested(eSocketNotifier::Write | eSocketNotifier::Read | eSocketNotifier::Priority);
+
+		data[0] = getSlotID();
+		data[1] = getSlotID() + 1; 	/* conid */
+		data[2] = T_CREATE_T_C;
+		data[3] = 1;
+		data[4] = getSlotID() + 1 	/*conid*/;
+
+#ifdef x_debug	
+		eDebugNoNewLine("write (%d): > ", getSlotID());
+		for(int i=0; i< 5; i++)
+			eDebugNoNewLine("%02x ",data[i]);
+#endif
+
+		send(data, 5);
+		run();
+	}
+	else
+	{
+		eDebug("cam not present\n");
+		state = stateRemoved;
+	}
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
 
+#ifdef __sh__
+/* ********************** end of __sh__ ************************* */
+#endif
+
 int eDVBCISlot::startMMI()
 {
 	eDebug("CI Slot %d: startMMI()", getSlotID());
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_datetimemgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_datetimemgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_datetimemgr.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_datetimemgr.cpp	2009-12-12 23:39:49.000000000 +0100
@@ -5,6 +5,9 @@
 
 int eDVBCIDateTimeSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIDateTimeSession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/DATETIME %02x %02x %02x: ", session_nb, tag[0],tag[1], tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -16,6 +19,9 @@
 		{
 		case 0x40:
 			state=stateSendDateTime;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		default:
@@ -23,25 +29,43 @@
 			break;
 		}
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIDateTimeSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	case stateSendDateTime:
 	{
 		unsigned char tag[3]={0x9f, 0x84, 0x41}; // date_time_response
 		unsigned char msg[7]={0, 0, 0, 0, 0, 0, 0};
 		sendAPDU(tag, msg, 7);
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFinal:
 		eDebug("stateFinal und action! kann doch garnicht sein ;)");
 	default:
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci.h enigma2-nightly/lib/dvb_ci/dvbci.h
--- enigma2-nightly.org/lib/dvb_ci/dvbci.h	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci.h	2009-12-12 23:40:01.000000000 +0100
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,7 +46,11 @@
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+class eDVBCISlot: public iObject, public Object, public eThread
+#else
 class eDVBCISlot: public iObject, public Object
+#endif
 {
 	friend class eDVBCIInterfaces;
 	DECLARE_REF(eDVBCISlot);
@@ -66,6 +73,17 @@
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char 		connection_id;
+	bool 		pollConnection;
+	struct timeval 	last_poll;
+	int 		pollTime;
+	bool		mmi_active;	
+
+	int		received_len;
+	__u8* 		received_data;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +113,24 @@
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	//Dagobert
+	void setPoll(bool poll) { pollConnection = poll; }
+	bool getPoll() { return pollConnection; }
+
+	void setPollTime(struct timeval t) { last_poll = t; }
+	struct timeval getPollTime() { return last_poll; }
+
+	void setModulePollTime(int t) { pollTime = t; }
+	int getModulePollTime() { return pollTime; }
+	bool checkQueueSize();
+
+	void thread();  // thread function
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+
+	void process_tpdu(char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+#endif	
 };
 
 struct CIPmtHandler
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_mmi.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_mmi.cpp	2009-12-12 23:40:19.000000000 +0100
@@ -19,18 +19,34 @@
 
 eDVBCIMMISession::eDVBCIMMISession(eDVBCISlot *tslot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	slot = tslot;
 	slot->setMMIManager(this);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+	slot->mmiClosed();
+#endif	
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCIMMISession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIMMISession::%s >", __func__);
+#endif
 	eDebugNoNewLine("SESSION(%d)/MMI %02x %02x %02x: ", session_nb, tag[0], tag[1],tag[2]);
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
@@ -40,14 +56,23 @@
 		if (eDVBCI_UI::getInstance()->processMMIData(slot->getSlotID(), tag, data, len) == 1)
 		{
 			state=stateDisplayReply;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 		}
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIMMISession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -76,6 +101,9 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -87,6 +115,9 @@
 	unsigned char data[]={0x00};
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -99,6 +130,9 @@
 	data[0] = answer & 0xff;
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -114,6 +148,9 @@
 	unsigned char tag[]={0x9f, 0x88, 0x08};
 	sendAPDU(tag, data, len+1);
 
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -125,6 +162,9 @@
 	unsigned char data[]={0x00}; // canceled
 	sendAPDU(tag, data, 1);
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_resmgr.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_resmgr.cpp	2009-12-12 23:40:33.000000000 +0100
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
@@ -16,6 +21,9 @@
 		case 0x10:  // profile enquiry
 			eDebug("cam fragt was ich kann.");
 			state=stateProfileEnquiry;
+#ifdef __sh__
+			eDebug("%s <", __func__);
+#endif
 			return 1;
 			break;
 		case 0x11: // Tprofile
@@ -28,6 +36,9 @@
 
 			if (state == stateFirstProfileEnquiry)
 			{
+#ifdef __sh__
+				eDebug("%s <", __func__);
+#endif
 				// profile change
 				return 1;
 			}
@@ -38,11 +49,17 @@
 		}
 	}
 	
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCIResourceManagerSession::doAction()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	switch (state)
 	{
 	case stateStarted:
@@ -50,6 +67,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x10}; // profile enquiry
 		sendAPDU(tag);
 		state = stateFirstProfileEnquiry;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateFirstProfileEnquiry:
@@ -57,6 +77,9 @@
 		const unsigned char tag[3]={0x9F, 0x80, 0x12}; // profile change
 		sendAPDU(tag);
 		state=stateProfileChange;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 0;
 	}
 	case stateProfileChange:
@@ -86,5 +109,8 @@
 	default:
 		break;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp enigma2-nightly/lib/dvb_ci/dvbci_session.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_session.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_session.cpp	2009-12-12 23:41:14.000000000 +0100
@@ -14,6 +14,9 @@
 
 int eDVBCISession::buildLengthField(unsigned char *pkt, int len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	if (len < 127)
 	{
 		*pkt++=len;
@@ -34,14 +37,23 @@
 		eDebug("too big length");
 		exit(0);
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::parseLengthField(const unsigned char *pkt, int &len)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	len=0;
 	if (!(*pkt&0x80)) 
 	{
 		len = *pkt;
+#ifdef __sh__
+		eDebug("%s <", __func__);
+#endif
 		return 1;
 	}
 	for (int i=0; i<(pkt[0]&0x7F); ++i)
@@ -49,6 +61,9 @@
 		len <<= 8;
 		len |= pkt[i + 1];
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return (pkt[0] & 0x7F) + 1;
 }
 
@@ -56,22 +71,37 @@
 {
 	unsigned char pkt[len+3+4];
 	int l;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	memcpy(pkt, tag, 3);
 	l=buildLengthField(pkt+3, len);
 	if (data)
 		memcpy(pkt+3+l, data, len);
 	sendSPDU(0x90, 0, 0, pkt, len+3+l);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(unsigned char tag, const void *data, int len, const void *apdu, int alen)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(slot, tag, data, len, session_nb, apdu, alen);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendSPDU(eDVBCISlot *slot, unsigned char tag, const void *data, int len, unsigned short session_nb, const void *apdu,int alen)
 {
 	unsigned char pkt[4096];
 	unsigned char *ptr=pkt;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	*ptr++=tag;
 	ptr+=buildLengthField(ptr, len+2);
 	if (data)
@@ -85,6 +115,9 @@
 
 	ptr+=alen;
 	slot->send(pkt, ptr - pkt);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::sendOpenSessionResponse(eDVBCISlot *slot, unsigned char session_status, const unsigned char *resource_identifier, unsigned short session_nb)
@@ -94,32 +127,53 @@
 	eDebug("sendOpenSessionResponse");
 	memcpy(pkt + 1, resource_identifier, 4);
 	sendSPDU(slot, 0x92, pkt, 5, session_nb);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCreateSessionResponse(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	status = data[0];
 	state = stateStarted;
 	action = 1;
 	eDebug("create Session Response, status %x", status);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::recvCloseSessionRequest(const unsigned char *data)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	state = stateInDeletion;
 	action = 1;
 	eDebug("close Session Request");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::deleteSessions(const eDVBCISlot *slot)
 {
 	ePtr<eDVBCISession> ptr;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (unsigned short session_nb=0; session_nb < SLMS; ++session_nb)
 	{
 		ptr = sessions[session_nb];
 		if (ptr && ptr->slot == slot)
 			sessions[session_nb]=0;
 	}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status, ePtr<eDVBCISession> &session)
@@ -127,12 +181,21 @@
 	unsigned long tag;
 	unsigned short session_nb;
 
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (session_nb=1; session_nb < SLMS; ++session_nb)
 		if (!sessions[session_nb-1])
 			break;
+#ifdef __sh__		
+	eDebug("use session_nb = %d\n", session_nb);
+#endif		
 	if (session_nb == SLMS)
 	{
 		status=0xF3;
+#ifdef __sh__
+	        eDebug("%s <", __func__);
+#endif
 		return;
 	}
 
@@ -190,16 +253,28 @@
 		status = 0;
 	}
 	session->state = stateInCreation;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCISession::handleClose()
 {
 	unsigned char data[1]={0x00};
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	sendSPDU(0x96, data, 1, 0, 0);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCISession::pollAll()
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	for (int session_nb=1; session_nb < SLMS; ++session_nb)
 		if (sessions[session_nb-1])
 		{
@@ -214,8 +289,18 @@
 				r=sessions[session_nb-1]->poll();
 
 			if (r)
+#ifdef __sh__
+			{
+				eDebug("%s <", __func__);
+#endif
 				return 1;
+#ifdef __sh__
+			}
+#endif
 		}
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
@@ -224,6 +309,9 @@
 	const unsigned char *pkt = (const unsigned char*)ptr;
 	unsigned char tag = *pkt++;
 	int llen, hlen;
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 
 	eDebug("slot: %p",slot);
 
@@ -251,12 +339,22 @@
 	else
 	{
 		unsigned session_nb;
+#ifdef __sh__
+		eDebug("hlen = %d, %d, %d\n", hlen,  pkt[hlen-2], pkt[hlen-1]);
+#endif
 		session_nb=pkt[hlen-2]<<8;
 		session_nb|=pkt[hlen-1]&0xFF;
 		
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset
+			//it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 		
@@ -290,6 +388,10 @@
 	len -= hlen;
 
 	if (session)
+#ifdef __sh__
+	{
+		eDebug("len %d\n", len);
+#endif
 		while (len > 0)
 		{
 			int alen;
@@ -299,6 +401,9 @@
 			hlen=parseLengthField(pkt, alen);
 			pkt+=hlen;
 			len-=hlen;
+#ifdef __sh__
+			eDebug("len = %d, hlen = %d, alen = %d\n", len, hlen, alen);
+#endif
 
 			//if (eDVBCIModule::getInstance()->workarounds_active & eDVBCIModule::workaroundMagicAPDULength)
 			{
@@ -308,14 +413,23 @@
 					alen=len;
 				}
 			}
+#ifdef __sh__
+			eDebug("1. Call receivedAPDU tag = 0x%2x, len = %d\n", tag, alen);
+#endif
 			if (session->receivedAPDU(tag, pkt, alen))
 				session->action = 1;
 			pkt+=alen;
 			len-=alen;
 		}
 		
+#ifdef __sh__
+	}
+#endif
 	if (len)
 		eDebug("PROTOCOL: warning, TL-Data has invalid length");
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCISession::~eDVBCISession()
diff -Nur enigma2-nightly.org/lib/dvb_ci/dvbci_ui.cpp enigma2-nightly/lib/dvb_ci/dvbci_ui.cpp
--- enigma2-nightly.org/lib/dvb_ci/dvbci_ui.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/dvb_ci/dvbci_ui.cpp	2009-12-12 23:41:32.000000000 +0100
@@ -17,8 +17,14 @@
 eDVBCI_UI::eDVBCI_UI()
 	:eMMI_UI(MAX_SLOTS)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	ASSERT(!instance);
 	instance = this;
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 eDVBCI_UI *eDVBCI_UI::getInstance()
@@ -28,51 +34,96 @@
 
 void eDVBCI_UI::setInit(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->initialize(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 void eDVBCI_UI::setReset(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->reset(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 }
 
 int eDVBCI_UI::startMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->startMMI(slot);
 	return 0;
 }
 
 int eDVBCI_UI::stopMMI(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->stopMMI(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerMenu(int slot, int answer)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerText(slot, answer);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::answerEnq(int slot, char *value)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->answerEnq(slot, value);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::cancelEnq(int slot)
 {
+#ifdef __sh__
+	eDebug("%s >", __func__);
+#endif
 	eDVBCIInterfaces::getInstance()->cancelEnq(slot);
+#ifdef __sh__
+	eDebug("%s <", __func__);
+#endif
 	return 0;
 }
 
 int eDVBCI_UI::getMMIState(int slot)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->getMMIState(slot);
 }
 
 int eDVBCI_UI::setClockRate(int slot, int rate)
 {
+#ifdef __sh__
+	eDebug("%s ><", __func__);
+#endif
 	return eDVBCIInterfaces::getInstance()->setCIClockRate(slot, rate);
 }

diff -Nur enigma2-nightly.org/lib/gdi/accel.cpp enigma2-nightly/lib/gdi/accel.cpp
--- enigma2-nightly.org/lib/gdi/accel.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/accel.cpp	2009-12-12 23:44:09.000000000 +0100
@@ -9,8 +9,25 @@
 #include <lib/gdi/gpixmap.h>
 
 gAccel *gAccel::instance;
+#if not defined(__sh__) 
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -47,6 +64,9 @@
 	m_accel_allocation = 0;
 	instance = this;
 
+#ifdef STMFB_ACCEL	
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL	
 	ati_accel_init();
 #endif
@@ -57,6 +77,9 @@
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL	
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -87,6 +110,77 @@
 
 int gAccel::blit(gSurface *dst, const gSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	//eDebug( "src: %4d %4d %4d %4d\tdst: %4d %4d %4d %4d\n"
+	//		"area: %4d %4d %4d %4d\tp: %4d %4d %4d %4d\n",
+	//		src->data_phys, src->x, src->y, src->stride,
+	//		dst->data_phys, dst->x, dst->y, dst->stride, 
+	//		area.left(), area.top(), area.width(), area.height(),
+	//		p.x(), p.y(), p.width(), p.height());
+
+	int src_format = 0;
+	void *data = 0;
+     	int data_phys = 0;
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+        	if(accelAlloc(data, data_phys, area.height() * area.width() * 4))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if(data_phys)
+			accelFree(data_phys);
+		return -1;
+	}
+
+	if(data_phys)
+	{
+		stmfb_accel_blit(
+			data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(data_phys);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
diff -Nur enigma2-nightly.org/lib/gdi/fb.cpp enigma2-nightly/lib/gdi/fb.cpp
--- enigma2-nightly.org/lib/gdi/fb.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/fb.cpp	2009-12-12 23:42:48.000000000 +0100
@@ -70,6 +70,15 @@
 		perror("mmap");
 		goto nolfb;
 	}
+#if defined(__sh__) 
+	//we use 2MB at the end of the buffer, the rest does the blitter 
+	lfb_direct = lfb;     
+	lfb += 1920*1080*4;     
+	topDiff = 0;
+	leftDiff = 0;
+	rightDiff = 0;
+	bottomDiff = 0;
+#endif 
 
 	showConsole(0);

@@ -83,6 +92,9 @@
 
 int fbClass::showConsole(int state)
 {
+#if defined(__sh__) 
+	int fd=open("/dev/ttyAS1", O_RDWR); 
+#else 
 	int fd=open("/dev/vc/0", O_RDWR);
 	if(fd>=0)
 	{
@@ -92,13 +104,18 @@
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(unsigned int nxRes, unsigned int nyRes, unsigned int nbpp)
 {
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
+#if defined(__sh__) 
+	screeninfo.yres_virtual=screeninfo.yres=nyRes; 
+#else 
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
+#endif
 	screeninfo.height=0;
 	screeninfo.width=0;
 	screeninfo.xoffset=screeninfo.yoffset=0;
@@ -129,6 +146,7 @@
 		break;
 	}
 
+#if not defined(__sh__) 
 	if (ioctl(fd, FBIOPUT_VSCREENINFO, &screeninfo)<0)
 	{
 		// try single buffering
@@ -143,6 +161,7 @@
 		eDebug(" - double buffering not available.");
 	} else
 		eDebug(" - double buffering available!");
+#endif
 	
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 	
@@ -154,6 +173,10 @@
 			nxRes, nyRes, nbpp,
 			screeninfo.xres, screeninfo.yres, screeninfo.bits_per_pixel);
 	}
+#if defined(__sh__) 
+	xResFB=nxRes; 
+	yResFB=nyRes; 
+#endif 
 	xRes=screeninfo.xres;
 	yRes=screeninfo.yres;
 	bpp=screeninfo.bits_per_pixel;
@@ -164,7 +187,9 @@
 		printf("fb failed\n");
 	}
 	stride=fix.line_length;
+#if not defined(__sh__) 
 	memset(lfb, 0, stride*yRes);
+#endif
 	return 0;
 }
 
@@ -183,10 +208,32 @@
 
 void fbClass::blit()
 {
+#if defined(__sh__) 
+	STMFBIO_BLT_DATA  bltData; 
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA)); 
+	bltData.operation  = BLT_OP_COPY; 
+	bltData.srcOffset  = 1920*1080*4; 
+	bltData.srcPitch   = xResFB * 4; 
+	bltData.dstOffset  = 0; 
+	bltData.dstPitch   = xRes*4; 
+	bltData.src_top    = 0; 
+	bltData.src_left   = 0; 
+	bltData.src_right  = xResFB; 
+	bltData.src_bottom = yResFB; 
+	bltData.dst_top    = 0 + topDiff; 
+	bltData.dst_left   = 0 + leftDiff; 
+	bltData.dst_right  = xRes + rightDiff; 
+	bltData.dst_bottom = yRes + bottomDiff;
+	if (ioctl(fd, STMFBIO_BLT, &bltData ) < 0) 
+	{ 
+		perror("FBIO_BLIT"); 
+	} 
+#else 
 	if (m_manual_blit == 1) {
 		if (ioctl(fd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -231,19 +278,62 @@
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 1;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__) 
 	unsigned char tmp = 0;
 	if (ioctl(fd,FBIO_SET_MANUAL_BLIT, &tmp)<0) 
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
 }
 
+#if defined(__sh__) 
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+	memset(lfb_direct, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
+
+}
+
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
diff -Nur enigma2-nightly.org/lib/gdi/fb.h enigma2-nightly/lib/gdi/fb.h
--- enigma2-nightly.org/lib/gdi/fb.h	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/fb.h	2009-12-12 23:42:58.000000000 +0100
@@ -4,10 +4,18 @@
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
 
+#if defined(__sh__) 
+	#include <linux/stmfb.h> 
+#endif
 class fbClass
 {
 	int fd;
 	unsigned int xRes, yRes, stride, bpp;
+#if defined(__sh__) 
+	unsigned int xResFB, yResFB; 
+	int topDiff, leftDiff, rightDiff, bottomDiff; 
+	unsigned char *lfb_direct;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo, oldscreen;
 	fb_cmap cmap;
@@ -19,7 +27,11 @@
 	int m_number_of_pages;
 	int m_phys_mem;
 #ifdef SWIG
+#if defined(__sh__) 
+	fbClass(const char *fb="/dev/fb0"); 
+#else 
 	fbClass(const char *fb="/dev/fb/0");
+#endif
 	~fbClass();
 public:
 #else
@@ -41,7 +53,11 @@
 	unsigned int Stride() { return stride; }
 	fb_cmap *CMAP() { return &cmap; }
 
+#if defined(__sh__) 
+	fbClass(const char *fb="/dev/fb0"); 
+#else 
 	fbClass(const char *fb="/dev/fb/0");
+#endif
 	~fbClass();
 	
 			// low level gfx stuff
@@ -52,6 +68,11 @@
 	int lock();
 	void unlock();
 	int islocked() { return locked; }
+#if defined(__sh__) 
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 };
 
 #endif
diff -Nur enigma2-nightly.org/lib/gdi/gfbdc.cpp enigma2-nightly/lib/gdi/gfbdc.cpp
--- enigma2-nightly.org/lib/gdi/gfbdc.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/gfbdc.cpp	2009-12-12 23:43:11.000000000 +0100
@@ -170,13 +170,37 @@
 
 void gFBDC::setResolution(int xres, int yres)
 {
+#if defined(__sh__) 
+	/* if xres and yres are negative call SetMode with the lates xres and yres  
+	 * we need that to read the new screen dimesnions after a resolution change 
+	 * without changing the frambuffer dimensions
+	 */ 
+	if(xres<0 && yres<0 ){ 
+		fb->SetMode(m_xres, m_yres, 32); 
+		return; 
+	} 
+#else 
 	if ((m_xres == xres) && (m_yres == yres))
 		return;
+#endif
 
 	m_xres = xres; m_yres = yres;
 
 	fb->SetMode(m_xres, m_yres, 32);
 
+#if defined(__sh__) 
+	surface.type = 0; 
+	surface.x = m_xres; 
+	surface.y = m_yres; 
+	surface.bpp = 32; 
+	surface.bypp = 4; 
+	surface.stride = m_xres * 4; 
+	surface.data = fb->lfb; 
+	surface.offset = 0;
+
+	for (int y=0; y<m_yres; y++)    // make whole screen transparent 
+		memset(fb->lfb+ y * m_xres * 4, 0x00, m_xres * 4);
+#else 
 	for (int y=0; y<m_yres; y++)	// make whole screen transparent
 		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
 
@@ -188,6 +212,7 @@
 	surface.stride = fb->Stride();
 	surface.data = fb->lfb;
 	surface.offset = 0;
+#endif
 
 	surface.data_phys = fb->getPhysAddr();
 
@@ -210,12 +235,19 @@
 	} else
 		m_enable_double_buffering = 0;
 
+#ifdef __sh__
+	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size - (1920*1080*4))/1024);
+	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
+
+	if (gAccel::getInstance())
+		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size - (1920*1080*4));
+#else
 	eDebug("%dkB available for acceleration surfaces.", (fb->Available() - fb_size)/1024);
 	eDebug("resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, fb->Stride());
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->setAccelMemorySpace(fb->lfb + fb_size, surface.data_phys + fb_size, fb->Available() - fb_size);
-
+#endif
 	if (!surface.clut.data)
 	{
 		surface.clut.colors = 256;
diff -Nur enigma2-nightly.org/lib/gdi/gpixmap.cpp enigma2-nightly/lib/gdi/gpixmap.cpp
--- enigma2-nightly.org/lib/gdi/gpixmap.cpp	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/gpixmap.cpp	2009-12-12 23:43:28.000000000 +0100
@@ -163,6 +163,10 @@
 			else
 				col=0x10101*color;
 			
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000)
+col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 			
 			if (surface->data_phys && gAccel::getInstance())
@@ -195,6 +199,10 @@
 			__u32 col;
 
 			col = color.argb();
+#if defined(__sh__) 
+if((col&0xFF000000) == 0xFF000000)
+col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 			if (surface->data_phys && gAccel::getInstance())
@@ -422,6 +430,10 @@
 					pal[i]=(src.surface->clut.data[i].a<<24)|(src.surface->clut.data[i].r<<16)|(src.surface->clut.data[i].g<<8)|(src.surface->clut.data[i].b);
 				else
 					pal[i]=0x010101*i;
+#if defined(__sh__) 
+if((pal[i]&0xFF000000) >= 0xE0000000)
+pal[i] = 0xFF000000;
+#endif
 				pal[i]^=0xFF000000;
 			}
 
diff -Nur enigma2-nightly.org/lib/gdi/Makefile.am enigma2-nightly/lib/gdi/Makefile.am
--- enigma2-nightly.org/lib/gdi/Makefile.am	2009-12-12 23:16:22.412600000 +0100
+++ enigma2-nightly/lib/gdi/Makefile.am	2009-12-12 23:43:37.000000000 +0100
@@ -6,7 +6,7 @@
 libenigma_gdi_a_SOURCES = \
 	region.cpp grc.cpp epng.cpp erect.cpp fb.cpp font.cpp font_arabic.cpp gfbdc.cpp  \
 	glcddc.cpp gpixmap.cpp lcd.cpp gfont.cpp accel.cpp picload.cpp picexif.cpp \
-	compositing.cpp bcm.cpp
+	compositing.cpp bcm.cpp stmfb.cpp
 
 if WITH_SDL
 libenigma_gdi_a_SOURCES += sdl.cpp
diff -Nur enigma2-nightly.org/lib/gdi/stmfb.cpp enigma2-nightly/lib/gdi/stmfb.cpp
--- enigma2-nightly.org/lib/gdi/stmfb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/gdi/stmfb.cpp	2009-12-11 21:40:17.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
+
diff -Nur enigma2-nightly.org/lib/python/Components/NimManager.py enigma2-nightly/lib/python/Components/NimManager.py
--- enigma2-nightly.org/lib/python/Components/NimManager.py	2009-12-12 23:16:22.424599000 +0100
+++ enigma2-nightly/lib/python/Components/NimManager.py	2009-12-12 23:45:45.000000000 +0100
@@ -15,6 +15,10 @@
 from datetime import datetime
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
@@ -353,6 +357,9 @@
 
 					if currLnb.diseqcMode.value == "1_0":
 						currCO = currLnb.commandOrder1_0.value
+#+++>  WHY ???
+						sec.setRepeats(0)
+#+++<
 					else:
 						currCO = currLnb.commandOrder.value
 
diff -Nur enigma2-nightly.org/lib/python/Components/TunerInfo.py enigma2-nightly/lib/python/Components/TunerInfo.py
--- enigma2-nightly.org/lib/python/Components/TunerInfo.py	2009-12-12 23:16:22.428599000 +0100
+++ enigma2-nightly/lib/python/Components/TunerInfo.py	2009-12-12 23:48:36.000000000 +0100
@@ -60,8 +60,17 @@
 			value = self.getValue(self.LOCK)
 
 		if self.type == self.SNR_DB:
-			if value != 0x12345678:
-				self.setText("%3.02f dB" % (value / 100.0))
+#--->   CAUSE OF CRASH!
+#-			if value != 0x12345678:
+#-				self.setText("%3.02f dB" % (value / 100.0))
+#---<
+#+++>   CAUSE OF CRASH!
+			if value is not None:
+				if value != 0x12345678:
+					self.setText("%3.02f dB" % (value / 100.0))
+				else:
+					self.setText("")
+#+++>   CAUSE OF CRASH!		
 			else:
 				self.setText("")
 		elif self.type == self.SNR_PERCENTAGE or self.type == self.AGC_PERCENTAGE:
diff -Nur enigma2-nightly.org/lib/python/enigma_python.i enigma2-nightly/lib/python/enigma_python.i
--- enigma2-nightly.org/lib/python/enigma_python.i	2009-12-12 23:16:22.496600000 +0100
+++ enigma2-nightly/lib/python/enigma_python.i	2009-12-13 10:30:25.000000000 +0100
@@ -97,6 +97,7 @@
 #include <lib/dvb_ci/dvbci_ui.h>
 #include <lib/python/python.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -212,6 +213,7 @@
 %include <lib/dvb/db.h>
 %include <lib/python/python.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h> 
 /**************  eptr  **************/
 
 /**************  signals  **************/
diff -Nur enigma2-nightly.org/lib/python/Makefile.am enigma2-nightly/lib/python/Makefile.am
--- enigma2-nightly.org/lib/python/Makefile.am	2009-12-12 23:16:22.428599000 +0100
+++ enigma2-nightly/lib/python/Makefile.am	2009-12-12 23:44:30.000000000 +0100
@@ -10,7 +10,7 @@
 	python.cpp enigma_python_wrap.cxx connections.cpp
 
 enigma_python_wrap.cxx: enigma_python.i
-	swig -I$(top_srcdir)/ -c++ -python -O -nortti -nothreads enigma_python.i
+	swig -I$(top_srcdir)/ -c++ -python -D__sh__ -O -nortti -nothreads enigma_python.i
 	python enigma_py_patcher.py
 
 enigma.py: enigma_python_wrap.cxx
diff -Nur enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/Makefile.am	2009-12-12 23:16:22.452629000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/Makefile.am	2009-12-12 23:57:20.000000000 +0100
@@ -1,6 +1,14 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDPlayer DVDBurn Modem
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDPlayer DVDBurn
 
+if ENABLE_TF7700
+SUBDIRS += TopfieldVFD
+endif
+
+if ENABLE_CUBEREVO
+SUBDIRS += CuberevoVFD
+endif
+
 install_PYTHON =	\
 	__init__.py
diff -Nur enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py	2009-12-13 10:15:06.057264790 +0100
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/Makefile.am	2009-12-11 21:40:03.000000000 +0100
@@ -0,0 +1,7 @@
+installdir = $(LIBDIR)/enigma2/python/Plugins/Extensions/TopfieldVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
diff -Nur enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/plugin.py	2009-12-11 21:40:03.000000000 +0100
@@ -0,0 +1,384 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time, fcntl, struct
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from enigma import eTimer
+from re import compile as re_compile, search as re_search
+from time import time, localtime, strftime
+
+my_global_session = None
+debug = False
+
+
+config.plugins.TopfieldVFD = ConfigSubsection()
+config.plugins.TopfieldVFD.allCaps = ConfigEnableDisable(default = False)
+config.plugins.TopfieldVFD.scroll = ConfigSelection(choices = [("never"), ("once"), ("always")])
+config.plugins.TopfieldVFD.brightness = ConfigSelection(default = "medium", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.TopfieldVFD.scrollPause = ConfigInteger(default = 100, limits = (1, 255))
+config.plugins.TopfieldVFD.scrollDelay = ConfigInteger(default = 10, limits = (1, 255))
+config.plugins.TopfieldVFD.typematicDelay = ConfigInteger(default = 3, limits = (0, 255))
+config.plugins.TopfieldVFD.typematicRate = ConfigInteger(default = 1, limits = (0, 255))
+config.plugins.TopfieldVFD.rcCommandSet = ConfigSelection(default = "TF7700 & Masterpiece", choices = [("TF7700"), ("Masterpiece"), ("TF7700 & Masterpiece")])
+config.plugins.TopfieldVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.TopfieldVFD.showEthernet = ConfigEnableDisable(default = True)
+
+# ioctl definitions for the VFD
+ioIconCmd = 0x400b3a20
+ioTimeshiftOn = struct.pack('LLB', 0x80, 0x0, 0xf)
+ioTimeshiftOff = struct.pack('LLB', 0x80, 0x0, 0x0)
+ioRec1On = struct.pack('LLB', 0x1000, 0x0, 0xf)
+ioRec1Off = struct.pack('LLB', 0x1000, 0x0, 0x0)
+ioRec2On = struct.pack('LLB', 0x2000, 0x0, 0xf)
+ioRec2Off = struct.pack('LLB', 0x2000, 0x0, 0x0)
+ioRecBothOn = struct.pack('LLB', 0x3000, 0x0, 0xf)
+ioRecBothOff = struct.pack('LLB', 0x3000, 0x0, 0x0)
+ioEthBothOff = struct.pack('LLB', 0x0c000000, 0x0, 0x0)
+ioEthLeftOn = struct.pack('LLB', 0x08000000, 0x0, 0xe)
+ioEthRightOn = struct.pack('LLB', 0x04000000, 0x0,0xb)
+ioColonOn = struct.pack('LLB', 0x4, 0x0,0x3)
+ioColonOff = struct.pack('LLB', 0x4, 0x0,0x0)
+ioBrightnessCmd = 0x40013a05
+ioIrFilter1Cmd = 0x40003a06
+ioIrFilter4Cmd = 0x40003a09
+ioTypematicDelayCmd = 0x40013a0d
+ioTypematicRateCmd = 0x40013a0e
+ioScrollModeCmd = 0x40033a15
+ioAllcapsCmd = 0x40013a14
+
+class TopfieldVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="TopfieldVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+		
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.TopfieldVFD.showClock))
+		self.list.append(getConfigListEntry(_("Show Ethernet activity"), config.plugins.TopfieldVFD.showEthernet))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.TopfieldVFD.brightness))
+		self.list.append(getConfigListEntry(_("All caps"), config.plugins.TopfieldVFD.allCaps))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.TopfieldVFD.scroll))
+		self.list.append(getConfigListEntry(_("Scroll pause"), config.plugins.TopfieldVFD.scrollPause))
+		self.list.append(getConfigListEntry(_("Scroll delay"), config.plugins.TopfieldVFD.scrollDelay))
+		self.list.append(getConfigListEntry(_("Typematic delay"), config.plugins.TopfieldVFD.typematicDelay))
+		self.list.append(getConfigListEntry(_("Typematic rate"), config.plugins.TopfieldVFD.typematicRate))
+		self.list.append(getConfigListEntry(_("RC command set"), config.plugins.TopfieldVFD.rcCommandSet))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+                self["key_red"] = Button(_("Cancel"))
+                self["key_green"] = Button(_("Save"))
+                                
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+		tfVfd.setValues()
+		self.close()
+
+	def cancel(self):
+                for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+
+class TopfieldVFD:
+	def __init__(self, session):
+		#print "TopfieldVFD initializing"
+	        self.session = session
+	        self.service = None
+	        self.onClose = [ ]
+	        self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+	                {
+                                iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+                                iPlayableService.evStart: self.__evStart,
+	                })
+	        session.nav.record_event.append(self.gotRecordEvent)
+		self.Console = Console()
+		self.tsEnabled = False
+		self.recNum = 0
+		self.timer = eTimer()
+		self.timer.callback.append(self.handleTimer)
+		self.timer.start(1000, False)
+		self.txCount = 0
+		self.clock = 0
+		self.valuesSet = 0
+		self.ethEnabled = config.plugins.TopfieldVFD.showEthernet.getValue()
+		self.clockEnabled = config.plugins.TopfieldVFD.showClock.getValue()
+		self.setValues()
+
+	def setValues(self):
+		#print "\nTopfiledVFD.setValues()\n"
+		if config.plugins.TopfieldVFD.showClock.value:
+			self.enableClock()
+		else:
+			self.disableClock()
+
+		# enable/disable displaying Ethernet activity
+                if config.plugins.TopfieldVFD.showEthernet.getValue():
+                	self.enableEthernet()
+                else:
+                	self.disableEthernet()
+
+		try:
+			fd = open("/dev/fpc")
+			
+			# set the brightness
+			brightness = 3
+			if config.plugins.TopfieldVFD.brightness.getValue() == "dark":
+				brightness = 1
+			elif config.plugins.TopfieldVFD.brightness.getValue() == "bright":
+				brightness = 5
+			fcntl.ioctl(fd.fileno(), ioBrightnessCmd, struct.pack('B', brightness))
+			
+			# set the the scroll mode
+			if config.plugins.TopfieldVFD.scroll.value == "once":
+				scrollMode = 1
+			elif config.plugins.TopfieldVFD.scroll.value == "always":
+				scrollMode = 2
+			else: # set to never by default
+				scrollMode = 0
+			scrollOpts = struct.pack('BBB', scrollMode,
+						int(config.plugins.TopfieldVFD.scrollPause.value),
+						int(config.plugins.TopfieldVFD.scrollDelay.value))
+			fcntl.ioctl(fd.fileno(), ioScrollModeCmd, scrollOpts)
+		 
+			# set the typematic values
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicRate.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicRateCmd, tmp)
+			tmp = struct.pack('B', int(config.plugins.TopfieldVFD.typematicDelay.value))
+			fcntl.ioctl(fd.fileno(), ioTypematicDelayCmd, tmp)
+		 
+			# set the IR filters
+			if config.plugins.TopfieldVFD.rcCommandSet.getValue() == "Masterpiece":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 0))
+			elif config.plugins.TopfieldVFD.rcCommandSet.getValue() == "TF7700":
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 0))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+			else: # enable both by default
+				fcntl.ioctl(fd.fileno(), ioIrFilter1Cmd, struct.pack('B', 1))
+				fcntl.ioctl(fd.fileno(), ioIrFilter4Cmd, struct.pack('B', 1))
+
+			# set the allcaps parameter
+			if config.plugins.TopfieldVFD.allCaps.value:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 1))
+			else:
+				fcntl.ioctl(fd.fileno(), ioAllcapsCmd, struct.pack('B', 0))
+
+			fd.close()
+			self.valuesSet = 1
+                except IOError,e:
+			if debug:
+				print "TopfieldVFD: setValues ", e
+
+	def enableEthernet(self):
+		self.ethEnabled = True
+		
+	def disableEthernet(self):
+		self.ethEnabled = False	
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+			fd.close()
+                except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableEthernet ", e
+
+	def enableClock(self):
+		self.clockEnabled = True
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOn)
+			fd.close()
+                except IOError,e:
+			if debug:
+				print "TopfieldVFD: enableClock ", e
+	        
+	def disableClock(self):
+		self.clockEnabled = False
+		self.clock = " "
+		try:
+			fd = open("/dev/fpc")
+			fcntl.ioctl(fd.fileno(), ioIconCmd, ioColonOff)
+			fd.close()
+			open("/dev/fpsmall", "w").write("     ")
+                except IOError,e:
+			if debug:
+				print "TopfieldVFD: disableClock ", e
+
+        def regExpMatch(self, pattern, string):
+                if string is None:
+                        return None
+                try:
+                        return pattern.search(string).group()
+                except AttributeError:
+                        None
+
+	def handleTimer(self):
+		#print "[ TopfieldVFD timer ]"
+		if self.valuesSet == 0:
+			self.setValues()
+
+		if self.clockEnabled:
+			clock = strftime("%k%M",localtime(time()))
+			if clock != self.clock:
+				self.clock = clock
+				try:
+					open("/dev/fpsmall", "w").write(clock + "\0")
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (clock) ", e
+			
+		if self.ethEnabled == False:
+			return
+			
+		result = open("/proc/net/dev").readlines()
+		numRegExp = "[0-9]+"
+		numPattern = re_compile(numRegExp)
+		txPattern = re_compile("eth0:[ ]*" + numRegExp)
+		for item in result:
+			tmp = self.regExpMatch(txPattern, item)
+			if tmp != None:
+				tmp = tmp[5:].lstrip()
+				try:
+					fd = open("/dev/fpc")
+					if self.txCount != tmp:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthLeftOn)
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthRightOn)
+						self.txCount = tmp
+					else:
+						fcntl.ioctl(fd.fileno(), ioIconCmd, ioEthBothOff)
+					fd.close()
+				except IOError,e:
+					if debug:
+						print "TopfieldVFD: handleTimer (Ethernet) ", e
+				break
+		
+	def __evStart(self):
+	        self.__evSeekableStatusChanged()
+	
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+		        return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+		        return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+	        tmp = self.getTimeshiftState()
+	        if tmp == self.tsEnabled:
+	        	return
+		try:
+			fd = open("/dev/fpc")
+			if tmp:
+				print "[Timeshift enabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOn)
+			else:
+				print "[Timeshift disabled]"
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioTimeshiftOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: __evSeekableStatusChanged ", e
+		self.tsEnabled = tmp
+	
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs == self.recNum:
+			return
+		try:
+			fd = open("/dev/fpc")
+			if nrecs > 1: # set rec 1+2 symbols
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOn)
+			elif nrecs > 0: # set rec 1 symbol
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioRec1On)
+			else:
+				fcntl.ioctl(fd.fileno(), ioIconCmd, ioRecBothOff)
+			fd.close()
+		except IOError,e:
+			if debug:
+				print "TopfieldVFD: gotRecordEvent ", e
+		self.recNum = nrecs
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "TopfieldVFD aborting"
+
+def main(session, **kwargs):
+	session.open(TopfieldVFDSetup)
+
+tfVfd = None
+gReason = -1
+mySession = None
+
+def controlTfVfd():
+	global tfVfd
+	global gReason
+	global mySession
+
+        if gReason == 0 and mySession != None and tfVfd == None:
+		print "Starting TopfieldVFD"
+		tfVfd = TopfieldVFD(mySession)
+	elif gReason == 1 and tfVfd != None:
+		print "Stopping TopfieldVFD"
+		tfVfd.disableClock()
+		tfVfd = None
+
+def autostart(reason, **kwargs):
+	global tfVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+                global my_global_session
+                mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlTfVfd()
+
+def Plugins(**kwargs):
+ 	return [ PluginDescriptor(name="TopfieldVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+ 		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
diff -Nur enigma2-nightly.org/lib/python/Plugins/Makefile.am enigma2-nightly/lib/python/Plugins/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Makefile.am	2009-12-12 23:16:22.460599000 +0100
+++ enigma2-nightly/lib/python/Plugins/Makefile.am	2009-12-12 23:53:28.000000000 +0100
@@ -1,6 +1,6 @@
 installdir = $(pkglibdir)/python/Plugins
 
-SUBDIRS = Extensions SystemPlugins DemoPlugins
+SUBDIRS = Extensions SystemPlugins
 
 install_PYTHON =	\
 	__init__.py Plugin.py 
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Makefile.am    2009-12-12 23:16:22.464599000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Makefile.am        2009-12-12 23:56:42.000000000 +0100
@@ -1,9 +1,9 @@
 installdir = $(pkglibdir)/python/Plugins/SystemPlugins
 
-SUBDIRS = SoftwareManager FrontprocessorUpgrade PositionerSetup Satfinder \
+SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner NFIFlash DiseqcTester CommonInterfaceAssignment \
-	CrashlogAutoSubmit CleanupWizard VideoEnhancement WirelessLan NetworkWizard \
+	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	CrashlogAutoSubmit CleanupWizard VideoEnhancement VFD-Icons Tuxtxt NetworkWizard \
 	TempFanControl
 
 install_PYTHON =	\
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/__init__.py	2009-12-13 10:14:22.053264741 +0100
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/Makefile.am	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,8 @@
+SUBDIRS = tuxtxt
+
+installdir = $(LIBDIR)/enigma2/python/Plugins/SystemPlugins/Tuxtxt
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/plugin.py	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,72 @@
+from enigma import *
+from Screens.Screen import Screen
+from Plugins.Plugin import PluginDescriptor
+import os
+
+class ShellStarter(Screen):
+	skin = """
+		<screen position="0,0" size="720,576" title="TuxTXT" >
+                </screen>"""
+
+        def __init__(self, session, args = None):
+		print "__init"
+        	self.skin = ShellStarter.skin
+		Screen.__init__(self, session)
+		#self.container=eConsoleAppContainer()
+		#self.container.appClosed.get().append(self.finished)
+		self.runapp()
+		
+	def runapp(self):
+		print "runappt"
+		service = self.session.nav.getCurrentService()
+		if service is not None:
+			self.info = service.info()
+		else:
+			self.info = None
+
+		#eDBoxLCD.getInstance().lock()
+		#eRCInput.getInstance().lock()
+		#fbClass.getInstance().lock()
+		#if self.container.execute("/usr/bin/tuxtxt "+self.getValue(iServiceInformation.sTXTPID)):
+		s="/usr/bin/tuxtxt "
+		s+=self.getValue(iServiceInformation.sTXTPID)
+		s+=" &"
+		print s
+		try:
+			os.popen(s)
+		except OSError, e: 
+			print "OSError: ", e
+			#print "OSError"
+			#Why cant i use openWithCallback?
+			#from Screens.MessageBox import MessageBox
+			#def msgClosed(ret):
+			#	return
+			#self.session.openWithCallback(msgClosed, MessageBox, _("Swap needed"), MessageBox.TYPE_INFO)
+
+			self.finished(-1)
+		self.finished(-1)
+
+	def finished(self,retval):
+		print "finished"
+		#fbClass.getInstance().unlock()
+		#eRCInput.getInstance().unlock()
+		#eDBoxLCD.getInstance().unlock()
+		self.close()
+
+	def getValue(self, what):
+		print "getValue"
+		if self.info is None:
+			return ""
+		
+		v = "%d" % (self.info.getInfo(what))
+
+		return v
+
+
+def main(session, **kwargs):
+	print "main"
+	session.open(ShellStarter)
+
+def Plugins(**kwargs):
+	print "Plugins"
+	return PluginDescriptor(name="TuxTXT", description="Videotext", where = PluginDescriptor.WHERE_TELETEXT, fnc=main)
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/Makefile.am	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,13 @@
+bin_PROGRAMS = tuxtxt
+
+tuxtxt_SOURCES = tuxtxt.c
+tuxtxt_LDFLAGS = -lfreetype -lpthread
+AM_CFLAGS = -Wall
+
+installdir = $(targetprefix)/usr/bin
+
+install_PYTHON =	\
+	tuxtxt
+
+
+
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/plugin.h enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/plugin.h
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/plugin.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/plugin.h	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,46 @@
+
+#ifndef TPLUGIN_H
+#define TPLUGIN_H
+
+typedef struct _PluginParam
+{
+	const char          * id;
+	char                * val;
+	struct _PluginParam * next;
+
+} PluginParam;
+
+typedef int	(*PluginExec)( PluginParam *par );
+/* das dlsym kann auf PluginExec gecastet werden */
+
+/* NOTE : alle Plugins haben uebergangs-weise neue und alte schnittstelle */
+/* neues Symbol : plugin_exec */
+/* es muessen nur benutzte ids gesetzt werden : nicht genannt = nicht benutzt */
+
+/* fixed ID definitions */
+#define	P_ID_FBUFFER	"fd_framebuffer"
+#define	P_ID_RCINPUT	"fd_rcinput"
+#define	P_ID_LCD		"fd_lcd"
+#define	P_ID_NOPIG		"no_pig"		// 1: plugin dont show internal pig
+#define P_ID_VTXTPID	"pid_vtxt"
+#define P_ID_PROXY		"proxy"			// set proxy for save into highscore
+#define P_ID_PROXY_USER	"proxy_user"	// format "user:pass"
+#define P_ID_HSCORE		"hscore"		// highscore-server (as url)
+#define P_ID_VFORMAT	"video_format"	// videoformat (0 = auto, 1 = 16:9, 2 = 4:3)
+#define P_ID_OFF_X		"off_x"			// screen-top-offset x
+#define P_ID_OFF_Y		"off_y"			// screen-top-offset y
+#define P_ID_END_X		"end_x"			// screen-end-offset x
+#define P_ID_END_Y		"end_y"			// screen-end-offset y
+#define	P_ID_RCBLK_ANF	"rcblk_anf"		// Key-Repeatblocker Anfang
+#define	P_ID_RCBLK_REP	"rcblk_rep"     // Key-Repeatblocker Wiederholung
+
+typedef enum plugin_type
+{
+	PLUGIN_TYPE_DISABLED = 0,
+	PLUGIN_TYPE_GAME     = 1,
+	PLUGIN_TYPE_TOOL     = 2,
+	PLUGIN_TYPE_SCRIPT   = 3,
+}
+plugin_type_t;
+
+#endif
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.c enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.c
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.c	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.c	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,6730 @@
+/******************************************************************************
+ *                      <<< TuxTxt - Teletext Plugin >>>                      *
+ *                                                                            *
+ *             (c) Thomas "LazyT" Loewe 2002-2003 (LazyT@gmx.net)             *
+ *                                                                            *
+ *    continued 2004-2005 by Roland Meier <RolandMeier@Siemens.com>           *
+ *                       and DBLuelle <dbluelle@blau-weissoedingen.de>        *
+ *                                                                            *
+ *              ported 2006 to Dreambox 7025 / 32Bit framebuffer              *
+ *                   by Seddi <seddi@i-have-a-dreambox.com>                   *
+ *                                                                            *
+ ******************************************************************************/
+
+
+#include "tuxtxt.h"
+#include <linux/stmfb.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+
+//aktivate or deaktivate Menu Key
+#define CONFIG_MENU
+
+int log_level = 0;
+
+#define debugf(i, arg...) \
+	if (i < log_level) \
+		fprintf(stderr, arg);
+		
+/* rc blocking an/aus */
+int blocking = 0;
+int newKey = 0;
+pthread_t self;
+int die = 0;
+/*  BLITTING  */
+
+/* current pig settings */
+int left, top, width, height;
+char aspect[16];
+
+int stride;
+
+void blit()
+{
+	debugf(100, "%s: >\n", __func__);
+	
+	STMFBIO_BLT_DATA  bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	if (zoommode == 0)
+	{
+	   bltData.operation  = BLT_OP_COPY;
+	   bltData.srcOffset  = 1920*1080*4;
+	   bltData.srcPitch   = 720 * 4;
+	   bltData.src_top    = 0;
+	   bltData.src_left   = 0;
+	   bltData.src_right  = 720;
+	   bltData.src_bottom = 576;
+
+	   bltData.dstOffset  = 0;
+	   bltData.dstPitch   = stride;
+	   bltData.dst_top    = 0;
+	   bltData.dst_left   = 0;
+	   bltData.dst_right  = var_screeninfo.xres;
+	   bltData.dst_bottom = var_screeninfo.yres;
+	} else
+	if (zoommode == 1)
+	{
+	   bltData.operation  = BLT_OP_COPY;
+
+	   bltData.srcOffset  = 1920*1080*4;
+	   bltData.srcPitch   = 720 * 4;
+	   bltData.src_top    = 0;
+	   bltData.src_left   = 0;
+	   bltData.src_right  = 720;
+	   bltData.src_bottom = 576 / 2;
+
+	   bltData.dstOffset  = 0;
+	   bltData.dstPitch   = stride;
+	   bltData.dst_top    = 0;
+	   bltData.dst_left   = 0;
+	   bltData.dst_right  = var_screeninfo.xres;
+	   bltData.dst_bottom = var_screeninfo.yres;
+	} else
+	if (zoommode == 2)
+	{
+	   bltData.operation  = BLT_OP_COPY;
+
+	   bltData.srcOffset  = 1920*1080*4;
+	   bltData.srcPitch   = 720 * 4;
+	   bltData.src_top    = 576 / 2;
+	   bltData.src_left   = 0;
+	   bltData.src_right  = 720;
+	   bltData.src_bottom = 576;
+
+	   bltData.dstOffset  = 0;
+	   bltData.dstPitch   = stride;
+	   bltData.dst_top    = 0;
+	   bltData.dst_left   = 0;
+	   bltData.dst_right  = var_screeninfo.xres;
+	   bltData.dst_bottom = var_screeninfo.yres;
+	} else
+		return;
+	
+#ifdef xdebug		
+debugf(1, "srcOffset=%d, srcPitch=%d\n"
+	"src_top=%d, src_left=%d, src_right=%d, src_bottom=%d\n"
+	"dstOffset=%d, dstPitch=%d\n"
+	"dst_top=%d, dst_left=%d, dst_right=%d, dst_bottom=%d\n",
+	bltData.srcOffset, bltData.srcPitch,
+	bltData.src_top, bltData.src_left, bltData.src_right, bltData.src_bottom,
+	bltData.dstOffset, bltData.dstPitch,
+	bltData.dst_top, bltData.dst_left , bltData.dst_right, bltData.dst_bottom);
+#endif
+
+	if ( ioctl(fb, STMFBIO_BLT, &bltData ) < 0)
+	{
+#if TUXTXT_DEBUG
+		printf("errno = %d, ioctl = %d\n", errno, STMFBIO_BLT); 
+#endif
+		perror("FBIO_BLIT");
+	}
+
+	debugf(100, "%s: <\n", __func__);
+}
+
+
+#define use_func
+#ifndef use_func
+
+#define setPixel(my_x, my_y, my_color) \
+{ \
+	unsigned char *my_local_private_pointer = lfb + (my_x) * 4 + (my_y) * 2880; \
+	if (((my_x) > 720) || ((my_x) < 0)) \
+	{ \
+		debugf(1, "%s: X out of bounds %d !!!!!!!!!!\n", __func__, (my_x)); \
+		break; \
+	} \
+	if (((my_y) > 576) || ((my_y) < 0)) \
+	{ \
+		debugf(1, "%s: Y out of bounds %d !!!!!!!!!!\n", __func__,  (my_y)); \
+		break; \
+	} \
+	if ((my_color) >= SIZECOLTABLE) \
+	{ \
+		debugf(1, "%s: color out of bounds %d !!!!!!!!!!\n", __func__,  (my_color)); \
+		break; \
+	} \
+	memcpy(my_local_private_pointer, bgra[(my_color)] , 4); \
+}
+
+#else
+static inline void setPixel(int x, int y, int color)
+{
+	unsigned char *p = lfb + x*4 + y * 2880;
+
+	debugf(100, "%s: >\n", __func__);
+
+	if ((x > 720) || (x < 0))
+	{
+		debugf(1, "X out of bounds %d !!!!!!!!!!\n", x);
+		return;
+	}
+
+	if ((y > 576) || (y < 0))
+	{
+		debugf(1, "Y out of bounds %d !!!!!!!!!!\n", y);
+		return;
+	}
+
+	if (color >= SIZECOLTABLE)
+	{
+		debugf(1, "color out of bounds %d !!!!!!!!!!\n", color);
+		return;
+	}
+
+	memcpy(p, bgra[color] , 4);
+
+	debugf(100, "%s: <\n", __func__);
+}
+#endif
+
+void FillRect(int x, int y, int w, int h, int color)
+{
+	int xtmp, ytmp;
+
+	debugf(100, "%s: >\n", __func__);
+
+	if (w > 0)
+	{
+		for (ytmp = 0 ; ytmp < h ; ytmp++)
+		{
+			for (xtmp = 0; xtmp < w; xtmp++)
+			{
+				setPixel(xtmp + x, ytmp + y, color);
+			}
+		}
+	}
+
+	debugf(100, "%s: <\n", __func__);
+}
+
+void FillBorder(int color)
+{
+	int ys =  0;
+
+	debugf(20, "%s: >\n", __func__);
+
+	FillRect(0     , ys                     ,StartX      ,576                       ,color);
+	FillRect(StartX, ys                     ,displaywidth,StartY                    ,color);
+	FillRect(StartX, ys+StartY+25*fontheight,displaywidth,576-(StartY+25*fontheight),color);
+
+	if (screenmode == 0 )
+		FillRect(StartX+displaywidth, ys,720-(StartX+displaywidth),576   ,color);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+int getIndexOfPageInHotlist()
+{
+	int i;
+	
+	debugf(10, "%s: >\n", __func__);
+	
+	for (i = 0; i <= maxhotlist; i++)
+	{
+		if (tuxtxt_cache.page == hotlist[i])
+			return i;
+	}
+
+	debugf(10, "%s: <\n", __func__);
+	return -1;
+}
+
+void gethotlist()
+{
+	FILE *hl;
+	char line[100];
+
+	debugf(2, "%s: >\n", __func__);
+
+	hotlistchanged = 0;
+	maxhotlist = -1;
+	sprintf(line, CONFIGDIR "/tuxtxt/hotlist%d.conf", tuxtxt_cache.vtxtpid);
+#if TUXTXT_DEBUG
+	printf("TuxTxt <gethotlist %s", line);
+#endif
+	if ((hl = fopen(line, "rb")) != 0)
+	{
+		do {
+			if (!fgets(line, sizeof(line), hl))
+				break;
+
+			if (1 == sscanf(line, "%x", &hotlist[maxhotlist+1]))
+			{
+				if (hotlist[maxhotlist+1] >= 0x100 && hotlist[maxhotlist+1] <= 0x899)
+				{
+#if TUXTXT_DEBUG
+					//printf(" %03x", hotlist[maxhotlist+1]);
+#endif
+					maxhotlist++;
+					continue;
+				}
+			}
+#if TUXTXT_DEBUG
+			//else
+				//printf(" ?%s?", line);
+#endif
+		} while (maxhotlist < (sizeof(hotlist)/sizeof(hotlist[0])-1));
+		fclose(hl);
+	}
+#if TUXTXT_DEBUG
+	printf(">\n");
+#endif
+	if (maxhotlist < 0) /* hotlist incorrect or not found */
+	{
+		hotlist[0] = 0x100; /* create one */
+		hotlist[1] = 0x303;
+		maxhotlist = 1;
+	}
+
+	debugf(2, "%s: <\n", __func__);
+}
+
+void savehotlist()
+{
+	FILE *hl;
+	char line[100];
+	int i;
+
+	debugf(2, "%s: >\n", __func__);
+
+	hotlistchanged = 0;
+	sprintf(line, CONFIGDIR "/tuxtxt/hotlist%d.conf", tuxtxt_cache.vtxtpid);
+#if TUXTXT_DEBUG
+	printf("TuxTxt <savehotlist %s", line);
+#endif
+	if (maxhotlist != 1 || hotlist[0] != 0x100 || hotlist[1] != 0x303)
+	{
+		if ((hl = fopen(line, "wb")) != 0)
+		{
+			for (i = 0; i <= maxhotlist; i++)
+			{
+				fprintf(hl, "%03x\n", hotlist[i]);
+#if TUXTXT_DEBUG
+				//printf(" %03x", hotlist[i]);
+#endif
+			}
+			fclose(hl);
+		}
+	}
+	else
+	{
+		unlink(line); /* remove current hotlist file */
+#if TUXTXT_DEBUG
+		printf(" (default - just deleted)");
+#endif
+	}
+#if TUXTXT_DEBUG
+	printf(">\n");
+#endif
+
+	debugf(2, "%s: <\n", __func__);
+}
+
+#define number2char(c) ((c) + (((c) <= 9) ? '0' : ('A' - 10)))
+/* print hex-number into string, s points to last digit, caller has to provide enough space, no termination */
+void hex2str(char *s, unsigned int n)
+{
+
+	debugf(20, "%s: >\n", __func__);
+
+	do {
+		char c = (n & 0xF);
+		*s-- = number2char(c);
+		n >>= 4;
+	} while (n);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+
+int toptext_getnext(int startpage, int up, int findgroup)
+{
+	int current, nextgrp, nextblk;
+
+	int stoppage =  (tuxtxt_is_dec(startpage) ? startpage : startpage & 0xF00); // avoid endless loop in hexmode
+
+	debugf(2, "%s: >\n", __func__);
+
+	nextgrp = nextblk = 0;
+	current = startpage;
+
+	do {
+		if (up)
+			tuxtxt_next_dec(&current);
+		else
+			tuxtxt_prev_dec(&current);
+
+		if (!tuxtxt_cache.bttok || tuxtxt_cache.basictop[current]) /* only if existent */
+		{
+			if (findgroup)
+			{
+				if (tuxtxt_cache.basictop[current] >= 6 && tuxtxt_cache.basictop[current] <= 7)
+					return current;
+				if (!nextgrp && (current&0x00F) == 0)
+					nextgrp = current;
+			}
+			if (tuxtxt_cache.basictop[current] >= 2 && tuxtxt_cache.basictop[current] <= 5) /* always find block */
+				return current;
+
+			if (!nextblk && (current&0x0FF) == 0)
+				nextblk = current;
+		}
+	} while (current != stoppage);
+
+	debugf(2, "%s: <\n", __func__);
+
+	if (nextgrp)
+		return nextgrp;
+	else if (nextblk)
+		return nextblk;
+	else
+		return startpage;
+
+}
+
+void RenderClearMenuLineBB(char *p, tstPageAttr *attrcol, tstPageAttr *attr)
+{
+	int col;
+
+	debugf(10, "%s: >\n", __func__);
+
+	PosX = TOPMENUSTARTX;
+	RenderCharBB(' ', attrcol); /* indicator for navigation keys */
+#if 0
+	RenderCharBB(' ', attr); /* separator */
+#endif
+	for(col = 0; col < TOPMENUCHARS; col++)
+	{
+		RenderCharBB(*p++, attr);
+	}
+	PosY += fontheight;
+	memset(p-TOPMENUCHARS, ' ', TOPMENUCHARS); /* init with spaces */
+
+	debugf(10, "%s: <\n", __func__);
+}
+
+void ClearBB(int color)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	FillRect(0,  0, 720, 576, color);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void ClearFB(int color)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	FillRect(0, 0, 720, 576, color);
+
+	debugf(20, "%s: >\n", __func__);
+}
+
+void ClearB(int color)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	FillRect(0, 0, 720, 576, color);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+
+int  GetCurFontWidth()
+{
+	int mx = (displaywidth)%(40-nofirst); // # of unused pixels
+	int abx = (mx == 0 ? displaywidth+1 : (displaywidth)/(mx+1));// distance between 'inserted' pixels
+	int nx= abx+1-((PosX-sx) % (abx+1)); // # of pixels to next insert
+
+	debugf(20, "%s: <>\n", __func__);
+
+	return fontwidth+(((PosX+fontwidth+1-sx) <= displaywidth && nx <= fontwidth+1) ? 1 : 0);
+}
+
+void SetPosX(int column)
+{
+		PosX = StartX;
+		int i;
+
+		debugf(20, "%s: >\n", __func__);
+
+		for (i = 0; i < column-nofirst; i++)
+			PosX += GetCurFontWidth();
+
+		debugf(20, "%s: <\n", __func__);
+}
+
+void setfontwidth(int newwidth)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	if (fontwidth != newwidth)
+	{
+		int i;
+		fontwidth = newwidth;
+		if (usettf)
+			typettf.width  = (FT_UShort) fontwidth * TTFWidthFactor16 / 16;
+		else
+		{
+			if (newwidth < 11)
+				newwidth = 21;
+			else if (newwidth < 14)
+				newwidth = 22;
+			else
+				newwidth = 23;
+			typettf.width  = typettf.height = (FT_UShort) newwidth;
+		}
+		for (i = 0; i <= 12; i++)
+			axdrcs[i] = (fontwidth * i + 6) / 12;
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+
+void setcolors(unsigned short *pcolormap, int offset, int number)
+{
+	int i,trans_tmp;
+	int j = offset; /* index in global color table */
+
+	debugf(20, "%s: >\n", __func__);
+
+	trans_tmp=25-trans_mode;
+
+	bgra[transp2][3]=((trans_tmp+7)<<11 | 0x7FF)>>8;
+
+	for (i = 0; i < number; i++)
+	{
+		int r = (pcolormap[i] << 12 & 0xF000) >> 8;
+		int g = (pcolormap[i] << 8 & 0xF000) >> 8;
+		int b = (pcolormap[i] << 4 & 0xF000) >> 8;
+
+		r = (r * (0x3f+(color_mode<<3))) >> 8;
+		g = (g * (0x3f+(color_mode<<3))) >> 8;
+		b = (b * (0x3f+(color_mode<<3))) >> 8;
+
+		bgra[j][2]=r;
+		bgra[j][1]=g;
+		bgra[j][0]=b;
+		
+		j++;
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+
+/* hexdump of page contents to stdout for debugging */
+void dump_page()
+{
+	/*int r, c;
+	char *p;
+	unsigned char pagedata[23*40];
+
+	if (!tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage])
+		return;
+	tuxtxt_decompress_page(tuxtxt_cache.page,tuxtxt_cache.subpage,pagedata);
+	for (r=1; r < 24; r++)
+	{
+		p = pagedata+40*(r-1);
+		for (c=0; c < 40; c++)
+			printf(" %02x", *p++);
+		printf("\n");
+		p = page_char + 40*r;
+		for (c=0; c < 40; c++)
+			printf("  %c", *p++);
+		printf("\n");
+	}*/
+}
+
+
+/* get object data */
+/* in: absolute triplet number (0..506, start at packet 3 byte 1) */
+/* in: pointer to cache struct of page data */
+/* out: 18 bit triplet data, <0 if invalid number, not cached, or hamming error */
+int iTripletNumber2Data(int iONr, tstCachedPage *pstCachedPage, unsigned char* pagedata)
+{
+	if (iONr > 506 || 0 == pstCachedPage)
+		return -1;
+
+	unsigned char *p;
+	int packet = (iONr / 13) + 3;
+	int packetoffset = 3 * (iONr % 13);
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (packet <= 23)
+		p = pagedata + 40*(packet-1) + packetoffset + 1;
+	else if (packet <= 25)
+	{
+		if (0 == pstCachedPage->pageinfo.p24)
+			return -1;
+		p = pstCachedPage->pageinfo.p24 + 40*(packet-24) + packetoffset + 1;
+	}
+	else
+	{
+		int descode = packet - 26;
+		if (0 == pstCachedPage->pageinfo.ext)
+			return -1;
+		if (0 == pstCachedPage->pageinfo.ext->p26[descode])
+			return -1;
+		p = pstCachedPage->pageinfo.ext->p26[descode] + packetoffset;	/* first byte (=designation code) is not cached */
+	}
+
+	debugf(20, "%s: <\n", __func__);
+
+	return deh24(p);
+}
+
+#define RowAddress2Row(row) ((row == 40) ? 24 : (row - 40))
+
+/* dump interpreted object data to stdout */
+/* in: 18 bit object data */
+/* out: termination info, >0 if end of object */
+void eval_object(int iONr, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  tObjType ObjType, unsigned char* pagedata)
+{
+	int iOData;
+	int iONr1 = iONr + 1; /* don't terminate after first triplet */
+	unsigned char drcssubp=0, gdrcssubp=0;
+	signed char endcol = -1; /* last column to which to extend attribute changes */
+	tstPageAttr attrPassive = atrtable[ATR_PassiveDefault]; /* current attribute for passive objects */
+
+	debugf(20, "%s: >\n", __func__);
+
+	do
+	{
+		iOData = iTripletNumber2Data(iONr, pstCachedPage,pagedata);	/* get triplet data, next triplet */
+		if (iOData < 0) /* invalid number, not cached, or hamming error: terminate */
+			break;
+#if TUXTXT_DEBUG
+		//if (dumpl25)
+		//	printf("  t%03d ", iONr);
+#endif
+		if (endcol < 0)
+		{
+			if (ObjType == OBJ_ACTIVE)
+			{
+				endcol = 40;
+			}
+			else if (ObjType == OBJ_ADAPTIVE) /* search end of line */
+			{
+				int i;
+				for (i = iONr; i <= 506; i++)
+				{
+					int iTempOData = iTripletNumber2Data(i, pstCachedPage,pagedata); /* get triplet data, next triplet */
+					int iAddress = (iTempOData      ) & 0x3f;
+					int iMode    = (iTempOData >>  6) & 0x1f;
+					//int iData    = (iTempOData >> 11) & 0x7f;
+					if (iTempOData < 0 || /* invalid number, not cached, or hamming error: terminate */
+						 (iAddress >= 40	/* new row: row address and */
+						 && (iMode == 0x01 || /* Full Row Color or */
+							  iMode == 0x04 || /* Set Active Position */
+							  (iMode >= 0x15 && iMode <= 0x17) || /* Object Definition */
+							  iMode == 0x17))) /* Object Termination */
+						break;
+					if (iAddress < 40 && iMode != 0x06)
+						endcol = iAddress;
+				}
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  endcol %02d", endcol);
+#endif
+			}
+		}
+		iONr++;
+	}
+	while (0 == eval_triplet(iOData, pstCachedPage, pAPx, pAPy, pAPx0, pAPy0, &drcssubp, &gdrcssubp, &endcol, &attrPassive, pagedata)
+			 || iONr1 == iONr); /* repeat until termination reached */
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void eval_NumberedObject(int p, int s, int packet, int triplet, int high,
+								 unsigned char *pAPx, unsigned char *pAPy,
+								 unsigned char *pAPx0, unsigned char *pAPy0)
+{
+	if (!packet || 0 == tuxtxt_cache.astCachetable[p][s])
+		return;
+
+	unsigned char pagedata[23*40];
+	tuxtxt_decompress_page(p, s,pagedata);
+	int idata = deh24(pagedata + 40*(packet-1) + 1 + 3*triplet);
+	int iONr;
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (idata < 0)	/* hamming error: ignore triplet */
+		return;
+	if (high)
+		iONr = idata >> 9; /* triplet number of odd object data */
+	else
+		iONr = idata & 0x1ff; /* triplet number of even object data */
+	if (iONr <= 506)
+	{
+#if TUXTXT_DEBUG
+		//if (dumpl25)
+		//	printf("P%xT%x%c %8s %c#%03d@%03d\n", packet, triplet, "LH"[!!high],	/* pointer pos, type, number, data pos */
+		//			 ObjectType[triplet % 3], "PCD"[triplet % 3], 8*packet + 2*(triplet-1)/3, iONr);
+
+#endif
+		eval_object(iONr, tuxtxt_cache.astCachetable[p][s], pAPx, pAPy, pAPx0, pAPy0, (tObjType)(triplet % 3),pagedata);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+int eval_triplet(int iOData, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  unsigned char *drcssubp, unsigned char *gdrcssubp,
+					  signed char *endcol, tstPageAttr *attrPassive, unsigned char* pagedata)
+{
+	int iAddress = (iOData      ) & 0x3f;
+	int iMode    = (iOData >>  6) & 0x1f;
+	int iData    = (iOData >> 11) & 0x7f;
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (iAddress < 40) /* column addresses */
+	{
+		int offset;	/* offset to page_char and page_atrb */
+
+		if (iMode != 0x06)
+			*pAPx = iAddress;	/* new Active Column */
+		offset = (*pAPy0 + *pAPy) * 40 + *pAPx0 + *pAPx;	/* offset to page_char and page_atrb */
+#if TUXTXT_DEBUG
+		if (dumpl25)
+			printf("  M%02xC%02xD%02x %d r:%d ch:%02x", iMode, iAddress, iData, *endcol,*pAPy0 + *pAPy,page_char[offset]);
+#endif
+
+		switch (iMode)
+		{
+		case 0x00:
+			if (0 == (iData>>5))
+			{
+				int newcolor = iData & 0x1f;
+				if (*endcol < 0) /* passive object */
+					attrPassive->fg = newcolor;
+				else if (*endcol == 40) /* active object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int oldcolor = (p)->fg; /* current color (set-after) */
+					int c = *pAPx0 + *pAPx;	/* current column absolute */
+					do
+					{
+						p->fg = newcolor;
+						p++;
+						c++;
+					} while (c < 40 && p->fg == oldcolor);	/* stop at change by level 1 page */
+				}
+				else /* adaptive object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int c = *pAPx;	/* current column relative to object origin */
+					do
+					{
+						p->fg = newcolor;
+						p++;
+						c++;
+					} while (c <= *endcol);
+				}
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  ,%02d FGCol T%x#%x", iAddress, (iData>>3)&0x03, iData&0x07);
+#endif
+			}
+			break;
+		case 0x01:
+			if (iData >= 0x20)
+			{
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  ,%02d BlockMosaic G1 #%02x", iAddress, iData);
+#endif
+				page_char[offset] = iData;
+				if (*endcol < 0) /* passive object */
+				{
+					attrPassive->charset = C_G1C; /* FIXME: separated? */
+					page_atrb[offset] = *attrPassive;
+				}
+				else if (page_atrb[offset].charset != C_G1S)
+					page_atrb[offset].charset = C_G1C; /* FIXME: separated? */
+			}
+			break;
+		case 0x02:
+		case 0x0b:
+#if TUXTXT_DEBUG
+			if (dumpl25)
+				printf("  ,%02d G3 #%02x f%db%d", iAddress, iData,attrPassive->fg, attrPassive->bg);
+#endif
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G3;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_G3;
+			break;
+		case 0x03:
+			if (0 == (iData>>5))
+			{
+				int newcolor = iData & 0x1f;
+				if (*endcol < 0) /* passive object */
+					attrPassive->bg = newcolor;
+				else if (*endcol == 40) /* active object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int oldcolor = (p)->bg; /* current color (set-after) */
+					int c = *pAPx0 + *pAPx;	/* current column absolute */
+					do
+					{
+						p->bg = newcolor;
+						if (newcolor == black)
+							p->IgnoreAtBlackBgSubst = 1;
+						p++;
+						c++;
+					} while (c < 40 && p->bg == oldcolor);	/* stop at change by level 1 page */
+				}
+				else /* adaptive object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int c = *pAPx;	/* current column relative to object origin */
+					do
+					{
+						p->bg = newcolor;
+						if (newcolor == black)
+							p->IgnoreAtBlackBgSubst = 1;
+						p++;
+						c++;
+					} while (c <= *endcol);
+				}
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  ,%02d BGCol T%x#%x", iAddress, (iData>>3)&0x03, iData&0x07);
+#endif
+			}
+			break;
+		case 0x06:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  PDC");
+#endif
+			/* ignore */
+			break;
+		case 0x07:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  ,%02d Flash M%xP%x", iAddress, iData & 0x03, (iData >> 2) & 0x07);
+#endif
+			if ((iData & 0x60) != 0) break; // reserved data field
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->flashing=iData & 0x1f;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].flashing=iData & 0x1f;
+			break;
+		case 0x08:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  ,%02d G0+G2 set #%02x (p105)", iAddress, iData);
+#endif
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->setG0G2=iData & 0x3f;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].setG0G2=iData & 0x3f;
+			break;
+		case 0x09:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  ,%02d G0 #%02x '%c'", iAddress, iData, iData);
+#endif
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G0P; /* FIXME: secondary? */
+				attrPassive->setX26  = 1;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+			{
+				page_atrb[offset].charset = C_G0P; /* FIXME: secondary? */
+				page_atrb[offset].setX26  = 1;
+			}
+			break;
+//		case 0x0b: (see 0x02)
+		case 0x0c:
+		{
+#if TUXTXT_DEBUG
+			/*if (dumpl25)
+				printf("  ,%02d Attribute%s%s%s%s%s%s", iAddress,
+						 (iData & 0x40) ? " DoubleWidth" : "",
+						 (iData & 0x20) ? " UnderlineSep" : "",
+						 (iData & 0x10) ? " InvColour" : "",
+						 (iData & 0x04) ? " Conceal" : "",
+						 (iData & 0x02) ? " Boxing" : "",
+					 (iData & 0x01) ? " DoubleHeight" : "");*/	
+#endif
+			int conc = (iData & 0x04);
+			int inv  = (iData & 0x10);
+			int dw   = (iData & 0x40 ?1:0);
+			int dh   = (iData & 0x01 ?1:0);
+			int sep  = (iData & 0x20);
+			int bw   = (iData & 0x02 ?1:0);
+			if (*endcol < 0) /* passive object */
+			{
+				if (conc)
+				{
+					attrPassive->concealed = 1;
+					attrPassive->fg = attrPassive->bg;
+				}
+				attrPassive->inverted = (inv ? 1- attrPassive->inverted : 0);
+				attrPassive->doubleh = dh;
+				attrPassive->doublew = dw;
+				attrPassive->boxwin = bw;
+				if (bw) attrPassive->IgnoreAtBlackBgSubst = 0;
+				if (sep)
+				{
+					if (attrPassive->charset == C_G1C)
+						attrPassive->charset = C_G1S;
+					else
+						attrPassive->underline = 1;
+				}
+				else
+				{
+					if (attrPassive->charset == C_G1S)
+						attrPassive->charset = C_G1C;
+					else
+						attrPassive->underline = 0;
+				}
+			}
+			else
+			{
+
+				int c = *pAPx0 + (*endcol == 40 ? *pAPx : 0);	/* current column */
+				int c1 = offset;
+				tstPageAttr *p = &page_atrb[offset];
+				do
+				{
+					p->inverted = (inv ? 1- p->inverted : 0);
+					if (conc)
+					{
+						p->concealed = 1;
+						p->fg = p->bg;
+					}
+					if (sep)
+					{
+						if (p->charset == C_G1C)
+							p->charset = C_G1S;
+						else
+							p->underline = 1;
+					}
+					else
+					{
+						if (p->charset == C_G1S)
+							p->charset = C_G1C;
+						else
+							p->underline = 0;
+					}
+					p->doublew = dw;
+					p->doubleh = dh;
+					p->boxwin = bw;
+					if (bw) p->IgnoreAtBlackBgSubst = 0;
+					p++;
+					c++;
+					c1++;
+				} while (c < *endcol);
+			}
+			break;
+		}
+		case 0x0d:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  ,%02d %cDRCS #%02x", iAddress, (iData & 0x40) ? ' ' : 'G', iData & 0x3f);
+#endif
+			page_char[offset] = iData & 0x3f;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_OFFSET_DRCS + ((iData & 0x40) ? (0x10 + *drcssubp) : *gdrcssubp);
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_OFFSET_DRCS + ((iData & 0x40) ? (0x10 + *drcssubp) : *gdrcssubp);
+			break;
+		case 0x0f:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  ,%02d G2 #%02x", iAddress, iData);
+#endif
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G2;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_G2;
+			break;
+		default:
+			if (iMode == 0x10 && iData == 0x2a)
+				iData = '@';
+			if (iMode >= 0x10)
+			{
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  ,%02d G0 #%02x %c +diacr. %x", iAddress, iData, iData, iMode & 0x0f);
+#endif
+				page_char[offset] = iData;
+				if (*endcol < 0) /* passive object */
+				{
+					attrPassive->charset = C_G0P;
+					attrPassive->diacrit = iMode & 0x0f;
+					attrPassive->setX26  = 1;
+					page_atrb[offset] = *attrPassive;
+				}
+				else
+				{
+					page_atrb[offset].charset = C_G0P;
+					page_atrb[offset].diacrit = iMode & 0x0f;
+					page_atrb[offset].setX26  = 1;
+				}
+			}
+			break; /* unsupported or not yet implemented mode: ignore */
+		} /* switch (iMode) */
+	}
+	else /* ================= (iAddress >= 40): row addresses ====================== */
+	{
+#if TUXTXT_DEBUG
+		//if (dumpl25)
+		//	printf("  M%02xR%02xD%02x", iMode, iAddress, iData);
+#endif
+		switch (iMode)
+		{
+		case 0x00:
+			if (0 == (iData>>5))
+			{
+#if TUXTXT_DEBUG
+				//if (dumpl25)
+				//	printf("  FScrCol T%x#%x", (iData>>3)&0x03, iData&0x07);
+#endif
+				FullScrColor = iData & 0x1f;
+			}
+			break;
+		case 0x01:
+			if (*endcol == 40) /* active object */
+			{
+				*pAPy = RowAddress2Row(iAddress);	/* new Active Row */
+
+				int color = iData & 0x1f;
+				int row = *pAPy0 + *pAPy;
+				int maxrow;
+#if TUXTXT_DEBUG
+				/*if (dumpl25)
+				{
+					printf("  AP=%d,0", RowAddress2Row(iAddress));
+					if (0 == (iData>>5))
+						printf("  FRowCol T%x#%x", (iData>>3)&0x03, iData&0x07);
+					else if (3 == (iData>>5))
+						printf("  FRowCol++ T%x#%x", (iData>>3)&0x03, iData&0x07);
+				}*/
+#endif
+				if (row <= 24 && 0 == (iData>>5))
+					maxrow = row;
+				else if (3 == (iData>>5))
+					maxrow = 24;
+				else
+					maxrow = -1;
+				for (; row <= maxrow; row++)
+					FullRowColor[row] = color;
+				*endcol = -1;
+			}
+			break;
+		case 0x04:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf(" AP=%d,%d", RowAddress2Row(iAddress), iData);
+#endif
+			*pAPy = RowAddress2Row(iAddress); /* new Active Row */
+			if (iData < 40)
+				*pAPx = iData;	/* new Active Column */
+			*endcol = -1; /* FIXME: check if row changed? */
+			break;
+		case 0x07:
+#if TUXTXT_DEBUG
+			/*if (dumpl25)
+			{
+				if (iAddress == 0x3f)
+					printf("  AP=0,0");
+				if (0 == (iData>>5))
+					printf("  Address Display R0 FRowCol T%x#%x", (iData>>3)&0x03, iData&0x07);
+				else if (3 == (iData>>5))
+					printf("  Address Display R0->24 FRowCol T%x#%x", (iData>>3)&0x03, iData&0x07);
+			}*/
+#endif
+			if (iAddress == 0x3f)
+			{
+				*pAPx = *pAPy = 0; /* new Active Position 0,0 */
+				if (*endcol == 40) /* active object */
+				{
+					int color = iData & 0x1f;
+					int row = *pAPy0; // + *pAPy;
+					int maxrow;
+
+					if (row <= 24 && 0 == (iData>>5))
+						maxrow = row;
+					else if (3 == (iData>>5))
+						maxrow = 24;
+					else
+						maxrow = -1;
+					for (; row <= maxrow; row++)
+						FullRowColor[row] = color;
+				}
+				*endcol = -1;
+			}
+			break;
+		case 0x08:
+		case 0x09:
+		case 0x0a:
+		case 0x0b:
+		case 0x0c:
+		case 0x0d:
+		case 0x0e:
+		case 0x0f:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  PDC");
+#endif
+			/* ignore */
+			break;
+		case 0x10:
+#if TUXTXT_DEBUG
+			//if (dumpl25)
+			//	printf("  AP=%d,%d  temp. Origin Modifier", iAddress - 40, iData);
+#endif
+			tAPy = iAddress - 40;
+			tAPx = iData;
+			break;
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			if (iAddress & 0x10)	/* POP or GPOP */
+			{
+				unsigned char APx = 0, APy = 0;
+				unsigned char APx0 = *pAPx0 + *pAPx + tAPx, APy0 = *pAPy0 + *pAPy + tAPy;
+				int triplet = 3 * ((iData >> 5) & 0x03) + (iMode & 0x03);
+				int packet = (iAddress & 0x03) + 1;
+				int subp = iData & 0x0f;
+				int high = (iData >> 4) & 0x01;
+
+
+				if (APx0 < 40) /* not in side panel */
+				{
+#if TUXTXT_DEBUG
+					/*if (dumpl25)
+						printf("  Object Invocation %5s %8s S%xP%xT%x%c %c#%03d\n---",
+								 ObjectSource[(iAddress >> 3) & 0x03], ObjectType[iMode & 0x03],
+								 subp,
+							 packet,
+								 triplet,
+								 "LH"[high],
+								 "PCD"[triplet % 3],
+								 8*packet + 2*(triplet-1)/3 + 1);*/
+#endif
+					eval_NumberedObject((iAddress & 0x08) ? gpop : pop, subp, packet, triplet, high, &APx, &APy, &APx0, &APy0);
+#if TUXTXT_DEBUG
+					//if (dumpl25)
+					//	printf("---");
+#endif
+				}
+#if TUXTXT_DEBUG
+				//else if (dumpl25)
+				//	printf("Object Invocation for Side Panel - ignored");
+#endif
+			}
+			else if (iAddress & 0x08)	/* local: eval invoked object */
+			{
+				unsigned char APx = 0, APy = 0;
+				unsigned char APx0 = *pAPx0 + *pAPx + tAPx, APy0 = *pAPy0 + *pAPy + tAPy;
+				int descode = ((iAddress & 0x01) << 3) | (iData >> 4);
+				int triplet = iData & 0x0f;
+
+				if (APx0 < 40) /* not in side panel */
+				{
+
+					eval_object(13 * 23 + 13 * descode + triplet, pstCachedPage, &APx, &APy, &APx0, &APy0, (tObjType)(triplet % 3), pagedata);
+
+				}
+
+			}
+			break;
+		case 0x15:
+		case 0x16:
+		case 0x17:
+			if (0 == (iAddress & 0x08))	/* Object Definition illegal or only level 3.5 */
+				break; /* ignore */
+
+			tAPx = tAPy = 0;
+			*endcol = -1;
+			return 0xFF; /* termination by object definition */
+			break;
+		case 0x18:
+			if (0 == (iData & 0x10)) /* DRCS Mode reserved or only level 3.5 */
+				break; /* ignore */
+
+			if (iData & 0x40)
+				*drcssubp = iData & 0x0f;
+			else
+				*gdrcssubp = iData & 0x0f;
+			break;
+		case 0x1f:
+
+			tAPx = tAPy = 0;
+			*endcol = -1;
+			return 0x80 | iData; /* explicit termination */
+			break;
+		default:
+			break; /* unsupported or not yet implemented mode: ignore */
+		} /* switch (iMode) */
+	} /* (iAddress >= 40): row addresses */
+
+	if (iAddress < 40 || iMode != 0x10) /* leave temp. AP-Offset unchanged only immediately after definition */
+		tAPx = tAPy = 0;
+
+
+	debugf(20, "%s: <\n", __func__);
+
+	return 0; /* normal exit, no termination */
+}
+
+int setnational(unsigned char sec)
+{
+
+	debugf(20, "%s: >\n", __func__);
+
+	switch (sec)
+	{
+		case 0x08:
+			return NAT_PL; //polish
+		case 0x16:
+		case 0x36:
+			return NAT_TR; //turkish
+		case 0x1d:
+			return NAT_SR; //serbian, croatian, slovenian
+		case 0x20:
+		case 0x24:
+		case 0x25:
+			return NAT_RU; // cyrillic
+		case 0x22:
+			return NAT_ET; // estonian
+		case 0x23:
+			return NAT_LV; // latvian, lithuanian
+		case 0x37:
+			return NAT_GR; // greek
+		case 0x47:
+		case 0x57:
+			// TODO : arabic
+			break;
+		case 0x55:
+			// TODO : hebrew
+			break;
+
+	}
+
+	debugf(20, "%s: <\n", __func__);
+	
+	return countryconversiontable[sec & 0x07];
+}
+
+/* evaluate level 2.5 information */
+void eval_l25()
+{
+
+	debugf(20, "%s: >\n", __func__);
+
+	memset(FullRowColor, 0, sizeof(FullRowColor));
+	FullScrColor = black;
+
+	if (!tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage])
+		return;
+
+	/* normal page */
+	if (tuxtxt_is_dec(tuxtxt_cache.page))
+	{
+		unsigned char APx0, APy0, APx, APy;
+		tstPageinfo *pi = &(tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage]->pageinfo);
+		tstCachedPage *pmot = tuxtxt_cache.astCachetable[(tuxtxt_cache.page & 0xf00) | 0xfe][0];
+		unsigned short *colortable = 0;
+		int p26Received = 0;
+		int BlackBgSubst = 0;
+		int ColorTableRemapping = 0;
+
+
+		pop = gpop = drcs = gdrcs = 0;
+
+
+		if (pi->ext)
+		{
+			tstExtData *e = pi->ext;
+
+			if (e->p26[0])
+				p26Received = 1;
+
+			if (e->p27)
+			{
+				tstp27 *p27 = e->p27;
+				if (p27[0].l25)
+					gpop = p27[0].page;
+				if (p27[1].l25)
+					pop = p27[1].page;
+				if (p27[2].l25)
+					gdrcs = p27[2].page;
+				if (p27[3].l25)
+					drcs = p27[3].page;
+			}
+
+			if (e->p28Received)
+			{
+				colortable = e->bgr;
+				BlackBgSubst = e->BlackBgSubst;
+				ColorTableRemapping = e->ColorTableRemapping;
+				memset(FullRowColor, e->DefRowColor, sizeof(FullRowColor));
+				FullScrColor = e->DefScreenColor;
+				national_subset = setnational(e->DefaultCharset);
+				national_subset_secondary = setnational(e->SecondCharset);
+
+			} /* e->p28Received */
+		}
+
+		if (!colortable && tuxtxt_cache.astP29[tuxtxt_cache.page >> 8])
+		{
+			tstExtData *e = tuxtxt_cache.astP29[tuxtxt_cache.page >> 8];
+			colortable = e->bgr;
+			BlackBgSubst = e->BlackBgSubst;
+			ColorTableRemapping = e->ColorTableRemapping;
+			memset(FullRowColor, e->DefRowColor, sizeof(FullRowColor));
+			FullScrColor = e->DefScreenColor;
+			national_subset = setnational(e->DefaultCharset);
+			national_subset_secondary = setnational(e->SecondCharset);
+
+		}
+
+		if (ColorTableRemapping)
+		{
+			int i;
+			for (i = 0; i < 25*40; i++)
+			{
+				page_atrb[i].fg += MapTblFG[ColorTableRemapping - 1];
+				if (!BlackBgSubst || page_atrb[i].bg != black || page_atrb[i].IgnoreAtBlackBgSubst)
+					page_atrb[i].bg += MapTblBG[ColorTableRemapping - 1];
+			}
+		}
+
+		/* determine ?pop/?drcs from MOT */
+		if (pmot)
+		{
+			unsigned char pmot_data[23*40];
+			tuxtxt_decompress_page((tuxtxt_cache.page & 0xf00) | 0xfe,0,pmot_data);
+
+			unsigned char *p = pmot_data; /* start of link data */
+			int o = 2 * (((tuxtxt_cache.page & 0xf0) >> 4) * 10 + (tuxtxt_cache.page & 0x0f));	/* offset of links for current page */
+			int opop = p[o] & 0x07;	/* index of POP link */
+			int odrcs = p[o+1] & 0x07;	/* index of DRCS link */
+			unsigned char obj[3*4*4]; // types* objects * (triplet,packet,subp,high)
+			unsigned char type,ct, tstart = 4*4;
+			memset(obj,0,sizeof(obj));
+
+
+			if (p[o] & 0x08) /* GPOP data used */
+			{
+				if (!gpop || !(p[18*40] & 0x08)) /* no p27 data or higher prio of MOT link */
+				{
+					gpop = ((p[18*40] << 8) | (p[18*40+1] << 4) | p[18*40+2]) & 0x7ff;
+					if ((gpop & 0xff) == 0xff)
+						gpop = 0;
+					else
+					{
+						if (gpop < 0x100)
+							gpop += 0x800;
+						if (!p26Received)
+						{
+							ct=2;
+							while (ct)
+							{
+								ct--;
+								type = (p[18*40+5] >> 2*ct) & 0x03;
+
+								if (type == 0) continue;
+							    obj[(type-1)*(tstart)+ct*4  ] = 3 * ((p[18*40+7+ct*2] >> 1) & 0x03) + type; //triplet
+							    obj[(type-1)*(tstart)+ct*4+1] = ((p[18*40+7+ct*2] & 0x08) >> 3) + 1       ; //packet
+							    obj[(type-1)*(tstart)+ct*4+2] = p[18*40+6+ct*2] & 0x0f                    ; //subp
+							    obj[(type-1)*(tstart)+ct*4+3] = p[18*40+7+ct*2] & 0x01                    ; //high
+
+
+							}
+						}
+					}
+				}
+			}
+			if (opop) /* POP data used */
+			{
+				opop = 18*40 + 10*opop;	/* offset to POP link */
+				if (!pop || !(p[opop] & 0x08)) /* no p27 data or higher prio of MOT link */
+				{
+					pop = ((p[opop] << 8) | (p[opop+1] << 4) | p[opop+2]) & 0x7ff;
+					if ((pop & 0xff) == 0xff)
+						pop = 0;
+					else
+					{
+						if (pop < 0x100)
+							pop += 0x800;
+						if (!p26Received)
+						{
+							ct=2;
+							while (ct)
+							{
+								ct--;
+								type = (p[opop+5] >> 2*ct) & 0x03;
+
+								if (type == 0) continue;
+							    obj[(type-1)*(tstart)+(ct+2)*4  ] = 3 * ((p[opop+7+ct*2] >> 1) & 0x03) + type; //triplet
+							    obj[(type-1)*(tstart)+(ct+2)*4+1] = ((p[opop+7+ct*2] & 0x08) >> 3) + 1       ; //packet
+							    obj[(type-1)*(tstart)+(ct+2)*4+2] = p[opop+6+ct*2]                           ; //subp
+							    obj[(type-1)*(tstart)+(ct+2)*4+3] = p[opop+7+ct*2] & 0x01                    ; //high
+
+							}
+						}
+					}
+				}
+			}
+			// eval default objects in correct order
+			for (ct = 0; ct < 12; ct++)
+			{
+
+				if (obj[ct*4] != 0)
+				{
+					APx0 = APy0 = APx = APy = tAPx = tAPy = 0;
+					eval_NumberedObject(ct % 4 > 1 ? pop : gpop, obj[ct*4+2], obj[ct*4+1], obj[ct*4], obj[ct*4+3], &APx, &APy, &APx0, &APy0);
+				}
+			}
+
+			if (p[o+1] & 0x08) /* GDRCS data used */
+			{
+				if (!gdrcs || !(p[20*40] & 0x08)) /* no p27 data or higher prio of MOT link */
+				{
+					gdrcs = ((p[20*40] << 8) | (p[20*40+1] << 4) | p[20*40+2]) & 0x7ff;
+					if ((gdrcs & 0xff) == 0xff)
+						gdrcs = 0;
+					else if (gdrcs < 0x100)
+						gdrcs += 0x800;
+				}
+			}
+			if (odrcs) /* DRCS data used */
+			{
+				odrcs = 20*40 + 4*odrcs;	/* offset to DRCS link */
+				if (!drcs || !(p[odrcs] & 0x08)) /* no p27 data or higher prio of MOT link */
+				{
+					drcs = ((p[odrcs] << 8) | (p[odrcs+1] << 4) | p[odrcs+2]) & 0x7ff;
+					if ((drcs & 0xff) == 0xff)
+						drcs = 0;
+					else if (drcs < 0x100)
+						drcs += 0x800;
+				}
+			}
+			if (tuxtxt_cache.astCachetable[gpop][0])
+				tuxtxt_cache.astCachetable[gpop][0]->pageinfo.function = FUNC_GPOP;
+			if (tuxtxt_cache.astCachetable[pop][0])
+				tuxtxt_cache.astCachetable[pop][0]->pageinfo.function = FUNC_POP;
+			if (tuxtxt_cache.astCachetable[gdrcs][0])
+				tuxtxt_cache.astCachetable[gdrcs][0]->pageinfo.function = FUNC_GDRCS;
+			if (tuxtxt_cache.astCachetable[drcs][0])
+				tuxtxt_cache.astCachetable[drcs][0]->pageinfo.function = FUNC_DRCS;
+		} /* if mot */
+
+
+
+		/* evaluate local extension data from p26 */
+		if (p26Received)
+		{
+
+			APx0 = APy0 = APx = APy = tAPx = tAPy = 0;
+			eval_object(13 * (23-2 + 2), tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage], &APx, &APy, &APx0, &APy0, OBJ_ACTIVE, &page_char[40]); /* 1st triplet p26/0 */
+		}
+
+		{
+			int r, c;
+			int o = 0;
+
+
+			for (r = 0; r < 25; r++)
+				for (c = 0; c < 39; c++)
+				{
+					if (BlackBgSubst && page_atrb[o].bg == black && !(page_atrb[o].IgnoreAtBlackBgSubst))
+					{
+						if (FullRowColor[r] == 0x08)
+							page_atrb[o].bg = FullScrColor;
+						else
+							page_atrb[o].bg = FullRowColor[r];
+					}
+					o++;
+				}
+		}
+
+		if (!hintmode)
+		{
+			int i;
+			for (i = 0; i < 25*40; i++)
+			{
+				if (page_atrb[i].concealed) page_atrb[i].fg = page_atrb[i].bg;
+			}
+		}
+
+		if (boxed || transpmode)
+//			FullScrColor = transp;
+			FillBorder(transp);
+		else
+			FillBorder(FullScrColor);
+
+		if (colortable) /* as late as possible to shorten the time the old page is displayed with the new colors */
+			setcolors(colortable, 16, 16); /* set colors for CLUTs 2+3 */
+	} /* is_dec(page) */
+
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/* *************** */
+/* Signal Handling */
+
+static void sbSigHandler(int signo)
+{
+	debugf(1, "%s: >\n", __func__);
+
+	/* exit */
+	CleanUp();
+	
+	unlink ("/tmp/block.tmp");
+	unlink ("/tmp/rc.socket");
+
+	//aktivate E2 framebuffer output
+	system("if [ -e /tmp/.e2fbstop ]; then killall -USR2 enigma2; fi");
+
+ 	debugf(1, "Tuxtxt dies with signal %d\n", signo);
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+/* ********** rc thread **************** */
+
+void * rcThread(void *vData)
+{
+    int key;
+    char stmp[9];
+    struct sockaddr_un cliadr, srvadr;
+    int srvfd;
+    socklen_t len;    
+    
+    debugf(1, "%s: >\n", __func__);
+
+    srvadr.sun_family = AF_LOCAL;
+    strcpy( srvadr.sun_path, "/tmp/rc.socket" );
+    rc=-1;
+    srvfd = socket( AF_LOCAL, SOCK_STREAM, 0 );
+    unlink ( "/tmp/rc.socket" );     
+    bind( srvfd, (struct sockaddr *) &srvadr, sizeof( srvadr ) );
+    listen( srvfd, 10 );
+    len = sizeof(cliadr);
+    
+    debugf (1, "Thread started !!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+
+    while (rc == -1)
+    {
+    	rc = accept( srvfd, (struct sockaddr *) &cliadr, &len );
+    
+    	usleep(1000000);
+    }
+    debugf (1, "!!!!!!!!!!!!!! rc = %d\n", rc);
+
+    while (die == 0)
+    {
+       newKey = 0;
+       RCCode = -1;
+       if ( read(rc, &stmp, sizeof("00000000")) )
+       {
+	   stmp[8]= '\0';
+	   debugf(1, "TT_KEY->: %s\n", stmp);
+	   sscanf(stmp, "%d", &key);
+	   debugf(1, "TT_KEY->: %d\n", key);
+
+           switch (key)
+               {
+                   case KEY_UP:        RCCode = RC_UP;        break;
+                   case KEY_DOWN:        RCCode = RC_DOWN;    break;
+                   case KEY_LEFT:        RCCode = RC_LEFT;    break;
+                   case KEY_RIGHT:        RCCode = RC_RIGHT;    break;
+                   case KEY_OK:        RCCode = RC_OK;        break;
+                   case KEY_0:        RCCode = RC_0;        break;
+                   case KEY_1:        RCCode = RC_1;        break;
+                   case KEY_2:        RCCode = RC_2;        break;
+                   case KEY_3:        RCCode = RC_3;        break;
+                   case KEY_4:        RCCode = RC_4;        break;
+                   case KEY_5:        RCCode = RC_5;        break;
+                   case KEY_6:        RCCode = RC_6;        break;
+                   case KEY_7:        RCCode = RC_7;        break;
+                   case KEY_8:        RCCode = RC_8;        break;
+                   case KEY_9:        RCCode = RC_9;        break;
+                   case KEY_RED:        RCCode = RC_RED;    break;
+                   case KEY_GREEN:        RCCode = RC_GREEN;    break;
+                   case KEY_YELLOW:    RCCode = RC_YELLOW;    break;
+                   case KEY_BLUE:        RCCode = RC_BLUE;    break;
+                   case KEY_VOLUMEUP:    RCCode = RC_PLUS;    break;
+                   case KEY_VOLUMEDOWN:    RCCode = RC_MINUS;    break;
+                   case KEY_MUTE:        RCCode = RC_MUTE;    break;
+                   case KEY_HELP:        RCCode = RC_HELP;    break;
+                   case KEY_MENU:        RCCode = RC_DBOX;    break;
+                   case KEY_HOME:        RCCode = RC_HOME;    break;
+                   case KEY_POWER:        RCCode = RC_STANDBY;    break;
+                   default:  RCCode = -1;
+	       }
+       
+       	   if (RCCode != -1)
+	   	newKey = 1;
+	   else
+	        newKey = 0;
+       }
+       
+       usleep(100000);       	
+
+    }
+    
+    debugf(1, "%s: <\n", __func__);
+    
+    pthread_cancel(self);
+    return NULL;
+}
+
+
+/******************************************************************************
+ * main loop                                                                  *
+ ******************************************************************************/
+
+int main(int argc, char **argv)
+{
+	char cvs_revision[] = "$Revision: 1.95 $";
+   	struct sigaction action;
+
+	debugf(1, "%s: >\n", __func__);
+
+   	action.sa_handler = sbSigHandler;
+
+   	sigemptyset(&action.sa_mask);
+   	action.sa_flags = 0;
+   	sigaction(SIGILL,  &action, (struct sigaction*)NULL);
+   	sigaction(SIGFPE,  &action, (struct sigaction*)NULL);
+   	sigaction(SIGBUS,  &action, (struct sigaction*)NULL);
+   	sigaction(SIGSEGV, &action, (struct sigaction*)NULL);
+   	sigaction(SIGSYS,  &action, (struct sigaction*)NULL);
+   	sigaction(SIGTERM, &action, (struct sigaction*)NULL);
+   	sigaction(SIGKILL, &action, (struct sigaction*)NULL);
+   	sigaction(SIGINT, &action, (struct sigaction*)NULL);
+
+	getCurrentPIGSettings(&left, &top, &width, &height);
+        getCurrentASPECTSettings();
+        setCurrentASPECTSettings(0);
+
+#if !TUXTXT_CFG_STANDALONE
+	int initialized = tuxtxt_init();
+	if ( initialized )
+		tuxtxt_cache.page = 0x100;
+#endif
+
+	/* show versioninfo */
+	sscanf(cvs_revision, "%*s %s", versioninfo);
+	printf("TuxTxt %s\n", versioninfo);
+	printf("for 32bpp framebuffer\n");
+
+	/* get params */
+	if (argc==1)
+	{
+		printf("\nUSAGE: tuxtxt vtpid\n");
+		printf("No PID given, so scanning for PIDs ...\n\n");
+		tuxtxt_cache.vtxtpid=0;
+	}
+	else 
+	{
+		tuxtxt_cache.vtxtpid = atoi(argv[1]);
+	}
+
+	/* open Framebuffer */
+	if ((fb=open("/dev/fb0", O_RDWR)) == -1)
+	{
+		perror("TuxTxt <open /dev/fb0>");
+		return 0;
+	}
+
+	sx = 20;
+	ex = 700;
+	sy = 20;
+	ey = 556;
+   	
+	if (tuxtxt_cache.vtxtpid == -1 || fb == -1 || rc == -1 || sx == -1 || ex == -1 || sy == -1 || ey == -1)
+	{
+		printf("TuxTxt <Invalid Param(s)>\n");
+		return 0;
+	}
+
+	unlink ("/tmp/block.tmp");
+	unlink ("/tmp/rc.socket");
+	int bfd = open ("/tmp/block.tmp", O_RDWR | O_CREAT | O_TRUNC, S_IRWXU | S_IRWXG | S_IRWXO );
+	close(bfd);
+
+	//deaktivate E2 framebuffer output
+	system("if [ -e /tmp/.e2fbstop ]; then killall -USR1 enigma2; fi");
+
+	/* initialisations */
+	if (Init() == 0)
+		return 0;
+
+	/* main loop */
+	
+
+	//start with page 100
+	PageInput(1);
+	RenderPage();
+	PageInput(0);
+	RenderPage();
+	PageInput(0);
+	RenderPage();
+	blit();
+	RenderPage();
+	blit();
+
+	if (pthread_create(&self, NULL, rcThread, (void *)NULL) < 0)
+	{
+	    debugf(1, "!!!!!!!!!!!! Failed to create thread !!!!!!!!!!!!11\n");
+	} else
+	    debugf(1, "!!!!!!!!!!!! create thread !!!!!!!!!!!!11\n");
+
+	do {
+		/* update page or timestring and lcd */
+		RenderPage();
+
+		blit();
+	
+		if (GetRCCode() == 1)
+		{
+#if TUXTXT_DEBUG
+			printf("transpmode=%d\n", transpmode);
+#endif
+			if (transpmode == 2) /* TV mode */
+			{
+				switch (RCCode)
+				{
+				case RC_OK:
+					continue; /* otherwise ignore key */
+				case RC_UP:
+				case RC_DOWN:
+				case RC_0:
+				case RC_1:
+				case RC_2:
+				case RC_3:
+				case RC_4:
+				case RC_5:
+				case RC_6:
+				case RC_7:
+				case RC_8:
+				case RC_9:
+				case RC_GREEN:
+				case RC_YELLOW:
+				case RC_BLUE:
+				case RC_PLUS:
+				case RC_MINUS:
+				case RC_DBOX:
+				case RC_STANDBY:
+					transpmode = 1; /* switch to normal mode */
+					SwitchTranspMode();
+					break;		/* and evaluate key */
+
+				case RC_MUTE:		/* regular toggle to transparent */
+					break;
+
+				case RC_HELP:
+				{
+					continue; /* otherwise ignore exit key */
+				}
+				default:
+					continue; /* ignore all other keys */
+				}
+			}
+
+			switch (RCCode)
+			{
+			case RC_UP:
+				GetNextPageOne(!swapupdown);
+				break;
+			case RC_DOWN:
+				GetNextPageOne(swapupdown);
+				break;
+			case RC_RIGHT:	
+				if (boxed)
+				{
+				    subtitledelay++;				    
+		    		    // display subtitledelay
+				    PosY = StartY;
+				    char ns[10];
+				    SetPosX(1);
+				    sprintf(ns,"+%d    ",subtitledelay);
+				    RenderCharFB(ns[0],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[1],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[2],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[4],&atrtable[ATR_WB]);					    
+				}
+				else
+    				    GetNextSubPage(1);	
+				break;
+			case RC_LEFT:
+				if (boxed)
+				{
+				    subtitledelay--;
+				    if (subtitledelay < 0) subtitledelay = 0;
+		    		    // display subtitledelay
+				    PosY = StartY;
+				    char ns[10];
+				    SetPosX(1);
+				    sprintf(ns,"+%d    ",subtitledelay);
+				    RenderCharFB(ns[0],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[1],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[2],&atrtable[ATR_WB]);
+				    RenderCharFB(ns[4],&atrtable[ATR_WB]);					    
+				}
+				else
+				    GetNextSubPage(-1);	
+				break;
+			case RC_OK:
+				if (tuxtxt_cache.subpagetable[tuxtxt_cache.page] == 0xFF)
+					continue;
+				PageCatching();
+				break;
+
+			case RC_0:
+			case RC_1:
+			case RC_2:
+			case RC_3:
+			case RC_4:
+			case RC_5:
+			case RC_6:
+			case RC_7:
+			case RC_8:
+			case RC_9:
+				PageInput(RCCode - RC_0);
+				break;
+			case RC_RED:	 ColorKey(prev_100);		break;
+			case RC_GREEN:	 ColorKey(prev_10);		break;
+			case RC_YELLOW: ColorKey(next_10);		break;
+			case RC_BLUE:	 ColorKey(next_100);		break;
+			case RC_PLUS:	 SwitchZoomMode();		break;
+			case RC_MINUS:	 SwitchScreenMode(-1);prevscreenmode = screenmode; break;
+			case RC_MUTE:	 SwitchTranspMode();	break;
+			case RC_HELP:	 SwitchHintMode();		break;
+#ifdef CONFIG_MENU
+			case RC_DBOX:	 ConfigMenu(0);			break;
+#endif
+			}
+		}
+
+	} while ((RCCode != RC_HOME) && (RCCode != RC_STANDBY));
+
+	/* exit */
+	CleanUp();
+	
+#if !TUXTXT_CFG_STANDALONE
+	if ( initialized )
+		tuxtxt_close();
+#endif
+	unlink ("/tmp/block.tmp");
+	unlink ("/tmp/rc.socket");
+
+	//aktivate E2 framebuffer output
+	system("if [ -e /tmp/.e2fbstop ]; then killall -USR2 enigma2; fi");
+
+	debugf(1, "%s: <\n", __func__);
+
+	return 0;
+}
+
+/******************************************************************************
+ * MyFaceRequester
+ ******************************************************************************/
+
+FT_Error MyFaceRequester(FTC_FaceID face_id, FT_Library library, FT_Pointer request_data, FT_Face *aface)
+{
+	FT_Error result;
+
+	debugf(5, "%s: >\n", __func__);
+
+	result = FT_New_Face(library, (char*) face_id, 0, aface);
+
+#if TUXTXT_DEBUG
+	if (!result)
+		printf("TuxTxt <font %s loaded>\n", (char*)face_id);
+	else
+		printf("TuxTxt <open font %s failed>\n", (char*)face_id, result);
+#endif
+
+	debugf(5, "%s: <\n", __func__);
+
+	return result;
+}
+
+/******************************************************************************
+ * Init                                                                       *
+ ******************************************************************************/
+
+int Init()
+{
+	int error, i;
+	unsigned char magazine;
+
+	debugf(1, "%s: >\n", __func__);
+
+	/* init data */
+
+ 	//page_atrb[32] = transp<<4 | transp;
+	inputcounter  = 2;
+
+	for (magazine = 1; magazine < 9; magazine++)
+	{
+		tuxtxt_cache.current_page  [magazine] = -1;
+		tuxtxt_cache.current_subpage [magazine] = -1;
+	}
+#if TUXTXT_CFG_STANDALONE
+/* init data */
+	memset(&tuxtxt_cache.astCachetable, 0, sizeof(tuxtxt_cache.astCachetable));
+	memset(&tuxtxt_cache.subpagetable, 0xFF, sizeof(tuxtxt_cache.subpagetable));
+	memset(&tuxtxt_cache.astP29, 0, sizeof(tuxtxt_cache.astP29));
+
+	memset(&tuxtxt_cache.basictop, 0, sizeof(tuxtxt_cache.basictop));
+	memset(&tuxtxt_cache.adip, 0, sizeof(tuxtxt_cache.adip));
+	memset(&tuxtxt_cache.flofpages, 0 , sizeof(tuxtxt_cache.flofpages));
+	tuxtxt_cache.maxadippg  = -1;
+	tuxtxt_cache.bttok      = 0;
+	maxhotlist = -1;
+
+	//page_atrb[32] = transp<<4 | transp;
+	inputcounter  = 2;
+	tuxtxt_cache.cached_pages  = 0;
+
+	tuxtxt_cache.page_receiving = -1;
+	tuxtxt_cache.page       = 0x100;
+#endif
+	lastpage   = tuxtxt_cache.page;
+	prev_100   = 0x100;
+	prev_10    = 0x100;
+	next_100   = 0x100;
+	next_10    = 0x100;
+	tuxtxt_cache.subpage    = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+	if (tuxtxt_cache.subpage == 0xff)
+	tuxtxt_cache.subpage    = 0;
+	
+	tuxtxt_cache.pageupdate = 0;
+
+	tuxtxt_cache.zap_subpage_manual = 0;
+
+	subtitledelay = 0;
+	delaystarted = 0;
+
+	/* init lcd */
+	//UpdateLCD();
+
+	/* config defaults */
+	screenmode = 0;
+	screen_mode1 = 0;
+	screen_mode2 = 0;
+	color_mode   = 10;
+	trans_mode   = 10;
+	menulanguage = 0;	/* german */
+	national_subset = 0;/* default */
+	auto_national   = 1;
+	swapupdown      = 0;
+	showhex         = 0;
+	showflof        = 1;
+	show39          = 1;
+	showl25         = 1;
+	dumpl25         = 0;
+	usettf          = 0;
+	TTFWidthFactor16  = 28;
+	TTFHeightFactor16 = 16;
+	TTFShiftX         = 0;
+	TTFShiftY         = 0;
+
+	/* load config */
+	if ((conf = fopen(TUXTXTCONF, "rt")) == 0)
+	{
+		perror("TuxTxt <fopen tuxtxt.conf>");
+	}
+	else
+	{
+		while(1)
+		{
+			char line[100];
+			int ival;
+
+			if (!fgets(line, sizeof(line), conf))
+				break;
+
+			if (1 == sscanf(line, "ScreenMode16x9Normal %i", &ival))
+				screen_mode1 = ival & 1;
+			else if (1 == sscanf(line, "ScreenMode16x9Divided %i", &ival))
+				screen_mode2 = ival & 1;
+			else if (1 == sscanf(line, "Brightness %i", &ival))
+				color_mode = ival;
+			else if (1 == sscanf(line, "AutoNational %i", &ival))
+				auto_national = ival & 1;
+			else if (1 == sscanf(line, "NationalSubset %i", &ival))
+			{
+				if (ival >= 0 && ival <= MAX_NATIONAL_SUBSET)
+					national_subset = ival;
+			}
+			else if (1 == sscanf(line, "MenuLanguage %i", &ival))
+			{
+				if (ival >= 0 && ival <= MAXMENULANGUAGE)
+					menulanguage = ival;
+			}
+			else if (1 == sscanf(line, "SwapUpDown %i", &ival))
+				swapupdown = ival & 1;
+			else if (1 == sscanf(line, "ShowHexPages %i", &ival))
+				showhex = ival & 1;
+			else if (1 == sscanf(line, "Transparency %i", &ival))
+				trans_mode = ival;
+			else if (1 == sscanf(line, "TTFWidthFactor16 %i", &ival))
+	            TTFWidthFactor16 = ival;
+			else if (1 == sscanf(line, "TTFHeightFactor16 %i", &ival))
+	            TTFHeightFactor16 = ival;
+			else if (1 == sscanf(line, "TTFShiftX %i", &ival))
+	            TTFShiftX = ival;
+			else if (1 == sscanf(line, "TTFShiftY %i", &ival))
+	            TTFShiftY = ival;
+			else if (1 == sscanf(line, "Screenmode %i", &ival))
+	            screenmode = ival;
+			else if (1 == sscanf(line, "ShowFLOF %i", &ival))
+	            showflof = ival & 1;
+			else if (1 == sscanf(line, "Show39 %i", &ival))
+	            show39 = ival & 1;
+			else if (1 == sscanf(line, "ShowLevel2p5 %i", &ival))
+	            showl25 = ival & 1;
+			else if (1 == sscanf(line, "DumpLevel2p5 %i", &ival))
+	            dumpl25 = ival & 1;
+			else if (1 == sscanf(line, "UseTTF %i", &ival))
+	            usettf = ival & 1;
+			else if (1 == sscanf(line, "StartX %i", &ival))
+	            sx = ival;
+			else if (1 == sscanf(line, "EndX %i", &ival))
+	            ex = ival;
+			else if (1 == sscanf(line, "StartY %i", &ival))
+	            sy = ival;
+			else if (1 == sscanf(line, "EndY %i", &ival))
+	            ey = ival;
+		}
+		fclose(conf);
+	}
+	
+	debugf(1, "sx %d, ex %d, sy %d, ey %d\n", sx, ex, sy, ey);
+	
+	saveconfig = 0;
+	savedscreenmode = screenmode;
+	national_subset_secondary = NAT_DEFAULT;
+
+
+	/* init fontlibrary */
+	if ((error = FT_Init_FreeType(&library)))
+	{
+#if TUXTXT_DEBUG
+		printf("TuxTxt <FT_Init_FreeType: 0x%.2X>", error);
+#endif
+		return 0;
+	}
+
+	if ((error = FTC_Manager_New(library, 7, 2, 0, &MyFaceRequester, NULL, &manager)))
+	{
+		FT_Done_FreeType(library);
+#if TUXTXT_DEBUG
+		printf("TuxTxt <FTC_Manager_New: 0x%.2X>\n", error);
+#endif
+		return 0;
+	}
+
+	if ((error = FTC_SBitCache_New(manager, &cache)))
+	{
+		FTC_Manager_Done(manager);
+		FT_Done_FreeType(library);
+#if TUXTXT_DEBUG
+		printf("TuxTxt <FTC_SBit_Cache_New: 0x%.2X>\n", error);
+#endif
+		return 0;
+	}
+
+	fontwidth = 0;	/* initialize at first setting */
+
+
+	/* calculate font dimensions */
+	displaywidth = (ex-sx);
+	fontheight = (ey-sy) / 25; //21;
+	fontwidth_normal = (ex-sx) / 40;
+	setfontwidth(fontwidth_normal);
+	fontwidth_topmenumain = (TV43STARTX-sx) / 40;
+	fontwidth_topmenusmall = (ex- TOPMENUSTARTX) / TOPMENUCHARS;
+	fontwidth_small = (TV169FULLSTARTX-sx)  / 40;
+	ymosaic[0] = 0; /* y-offsets for 2*3 mosaic */
+	ymosaic[1] = (fontheight + 1) / 3;
+	ymosaic[2] = (fontheight * 2 + 1) / 3;
+	ymosaic[3] = fontheight;
+	{
+		int i;
+		for (i = 0; i <= 10; i++)
+			aydrcs[i] = (fontheight * i + 5) / 10;
+	}
+
+	/* center screen */
+	StartX = sx; //+ (((ex-sx) - 40*fontwidth) / 2);
+	StartY = sy + (((ey-sy) - 25*fontheight) / 2);
+
+	debugf(1, "StartX %d, StartY %d, displaywidth %d\n", StartX, StartY, displaywidth);
+
+	if (usettf)
+	{
+		typettf.face_id = (FTC_FaceID) TUXTXTTTFVAR;
+		typettf.height = (FT_UShort) fontheight * TTFHeightFactor16 / 16;
+	}
+	else
+	{
+		typettf.face_id = (FTC_FaceID) TUXTXTOTBVAR;
+		typettf.width  = (FT_UShort) 23;
+		typettf.height = (FT_UShort) 23;
+	}
+
+	//typettf.image_type = ftc_image_mono;
+	typettf.flags = FT_LOAD_MONOCHROME;
+
+	if ((error = FTC_Manager_LookupFace(manager, typettf.face_id, &face)))
+	{
+		if (usettf == 1)
+		    typettf.face_id = (FT_Pointer) TUXTXTTTF;
+		else 
+		    typettf.face_id = (FT_Pointer) TUXTXTOTB;
+		    
+		if ((error = FTC_Manager_LookupFace(manager, typettf.face_id, &face)))
+		{
+#if TUXTXT_DEBUG
+			printf("TuxTxt <FTC_Manager_Lookup_Face failed with Errorcode 0x%.2X>\n", error);
+#endif
+			FTC_Manager_Done(manager);
+			FT_Done_FreeType(library);
+			return 0;
+		}
+	}
+	ascender = (usettf ? fontheight * face->ascender / face->units_per_EM : 16);
+#if TUXTXT_DEBUG
+	printf("TuxTxt <fh%d fw%d fs%d tm%d ts%d ym%d %d %d sx%d sy%d a%d>\n",
+			 fontheight, fontwidth, fontwidth_small, fontwidth_topmenumain, fontwidth_topmenusmall,
+			 ymosaic[0], ymosaic[1], ymosaic[2], StartX, StartY, ascender);
+#endif
+
+
+	/* get fixed screeninfo */
+	if (ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
+	{
+		perror("TuxTxt <FBIOGET_FSCREENINFO>");
+		return 0;
+	}
+
+	stride=fix_screeninfo.line_length;
+
+	debugf(1, "stride = %d\n", stride);
+
+	/* get variable screeninfo */
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+	{
+		perror("TuxTxt <FBIOGET_VSCREENINFO>");
+		return 0;
+	}
+
+	/* set new colormap */
+	setcolors((unsigned short *)defaultcolors, 0, SIZECOLTABLE);
+
+	/* map framebuffer into memory */
+	debugf(1, "%dk video memory\n", fix_screeninfo.smem_len/1024);
+
+	lfb = (unsigned char*)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0);
+
+	if (!lfb)
+	{
+		perror("TuxTxt <mmap>");
+		return 0;
+	}
+
+	//MOVE THE LFB BEHIND OUR VISIBLE SCREEN
+	lfb += 1920*1080*4;
+	ClearBB(transp); /* initialize backbuffer */
+
+	for (i = 0; i < 40 * 25; i++)
+	{
+		page_char[i] = ' ';
+		page_atrb[i].fg = transp;
+		page_atrb[i].bg = transp;
+		page_atrb[i].charset = C_G0P;
+		page_atrb[i].doubleh = 0;
+		page_atrb[i].doublew = 0;
+		page_atrb[i].IgnoreAtBlackBgSubst = 0;
+	}
+
+	/*  if no vtxtpid for current service, search PIDs */
+	if (tuxtxt_cache.vtxtpid == 0)
+	{
+		/* get all vtxt-pids */
+		getpidsdone = -1;						 /* don't kill thread */
+		if (GetTeletextPIDs() == 0)
+		{
+			FTC_Manager_Done(manager);
+			FT_Done_FreeType(library);
+			munmap(lfb, fix_screeninfo.smem_len);
+			return 0;
+		}
+
+		if (auto_national)
+			national_subset = pid_table[0].national_subset;
+#ifdef CONFIG_MENU
+		if (pids_found > 1)
+			ConfigMenu(1);
+#endif
+		else
+		{
+			tuxtxt_cache.vtxtpid = pid_table[0].vtxt_pid;
+			current_service = 0;
+			RenderMessage(ShowServiceName);
+		}
+	}
+	else
+	{
+		SDT_ready = 0;
+		getpidsdone = 0;
+//		tuxtxt_cache.pageupdate = 1; /* force display of message page not found (but not twice) */
+
+	}
+
+#if TUXTXT_CFG_STANDALONE
+	tuxtxt_init_demuxer();
+	tuxtxt_start_thread();
+#else
+	tuxtxt_start(tuxtxt_cache.vtxtpid);
+#endif
+
+	/* setup rc */
+	blocking = 0;
+
+	gethotlist();
+
+	SwitchScreenMode(screenmode);
+	prevscreenmode = screenmode;
+	
+	debugf(1, "%s: <\n", __func__);
+
+	/* init successfull */
+	return 1;
+}
+
+/******************************************************************************
+ * Cleanup                                                                    *
+ ******************************************************************************/
+
+void CleanUp()
+{
+	int curscreenmode = screenmode;
+
+	debugf(1, "%s: >\n", __func__);
+
+	die = 1;
+
+	if (screenmode)
+		SwitchScreenMode(0); /* turn off divided screen */
+        setCurrentASPECTSettings(1);
+
+#if TUXTXT_CFG_STANDALONE
+	tuxtxt_stop_thread();
+	tuxtxt_clear_cache();
+	if (tuxtxt_cache.dmx != -1)
+    	    close(tuxtxt_cache.dmx);
+	tuxtxt_cache.dmx = -1;
+#else
+	tuxtxt_stop();
+#endif
+
+	/* clear screen */
+	memset(lfb, 0, 576 * 720 * 4);
+
+	blit();
+
+	/* close freetype */
+	FTC_Manager_Done(manager);
+	FT_Done_FreeType(library);
+
+	/* unmap framebuffer */
+	munmap(lfb, fix_screeninfo.smem_len);
+
+	/* close rc */
+	close(rc);
+
+	/* close framebuffer */
+	close(fb);
+
+	if (hotlistchanged)
+		savehotlist();
+
+	/* save config */
+	if (saveconfig || curscreenmode != savedscreenmode)
+	{
+		if ((conf = fopen(TUXTXTCONF, "wt")) == 0)
+		{
+			perror("TuxTxt <fopen tuxtxt.conf>");
+		}
+		else
+		{
+#if TUXTXT_DEBUG
+			printf("TuxTxt <saving config>\n");
+#endif
+			fprintf(conf, "ScreenMode16x9Normal %d\n", screen_mode1);
+			fprintf(conf, "ScreenMode16x9Divided %d\n", screen_mode2);
+			fprintf(conf, "Brightness %d\n", color_mode);
+			fprintf(conf, "MenuLanguage %d\n", menulanguage);
+			fprintf(conf, "AutoNational %d\n", auto_national);
+			fprintf(conf, "NationalSubset %d\n", national_subset);
+			fprintf(conf, "SwapUpDown %d\n", swapupdown);
+			fprintf(conf, "ShowHexPages %d\n", showhex);
+			fprintf(conf, "Transparency 0x%X\n", trans_mode);
+			fprintf(conf, "TTFWidthFactor16 %d\n", TTFWidthFactor16);
+			fprintf(conf, "TTFHeightFactor16 %d\n", TTFHeightFactor16);
+			fprintf(conf, "TTFShiftX %d\n", TTFShiftX);
+			fprintf(conf, "TTFShiftY %d\n", TTFShiftY);
+			fprintf(conf, "Screenmode %d\n", curscreenmode);
+			fprintf(conf, "ShowFLOF %d\n", showflof);
+			fprintf(conf, "Show39 %d\n", show39);
+			fprintf(conf, "ShowLevel2p5 %d\n", showl25);
+			fprintf(conf, "DumpLevel2p5 %d\n", dumpl25);
+			fprintf(conf, "UseTTF %d\n", usettf);
+			fprintf(conf, "StartX %d\n", sx);
+			fprintf(conf, "EndX %d\n", ex);
+			fprintf(conf, "StartY %d\n", sy);
+			fprintf(conf, "EndY %d\n", ey);
+			fclose(conf);
+		}
+	}
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * GetTeletextPIDs                                                           *
+ ******************************************************************************/
+int GetTeletextPIDs()
+{
+	struct dmx_sct_filter_params dmx_flt;
+	int pat_scan, pmt_scan, sdt_scan, desc_scan, pid_test, byte, diff, first_sdt_sec;
+
+	unsigned char PAT[1024];
+	unsigned char SDT[1024];
+	unsigned char PMT[1024];
+	int dmx;
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* open demuxer */
+	if ((dmx = open(DMX, O_RDWR)) == -1)
+	{
+		perror("TuxTxt <open DMX>");
+		return 0;
+	}
+	if (ioctl(dmx, DMX_SET_BUFFER_SIZE, 64*1024) < 0)
+	{
+		perror("Tuxtxt <DMX_SET_BUFFERSIZE>");
+		close(dmx);
+		return 0;
+	}
+
+	/* show infobar */
+	RenderMessage(ShowInfoBar);
+
+	/* read PAT to get all PMT's */
+
+	memset(&dmx_flt.filter, 0x00, sizeof(struct dmx_filter));
+
+
+	dmx_flt.pid              = 0x0000;
+	dmx_flt.flags            = DMX_ONESHOT | DMX_CHECK_CRC | DMX_IMMEDIATE_START;
+	dmx_flt.filter.filter[0] = 0x00;
+	dmx_flt.filter.mask[0]   = 0xFF;
+	dmx_flt.timeout          = 5000;
+
+
+	if (ioctl(dmx, DMX_SET_FILTER, &dmx_flt) == -1)
+	{
+		perror("TuxTxt <DMX_SET_FILTER PAT>");
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+		return 0;
+	}
+
+	if (read(dmx, PAT, sizeof(PAT)) == -1)
+	{
+		perror("TuxTxt <read PAT>");
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+		return 0;
+	}
+
+	/* scan each PMT for vtxt-pid */
+	pids_found = 0;
+
+	for (pat_scan = 0x0A; pat_scan < 0x0A + (((PAT[0x01]<<8 | PAT[0x02]) & 0x0FFF) - 9); pat_scan += 4)
+	{
+#if TUXTXT_DEBUG
+		printf("PAT liefert:%04x, %04x \n",((PAT[pat_scan - 2]<<8) | (PAT[pat_scan - 1])),(PAT[pat_scan]<<8 | PAT[pat_scan+1]) & 0x1FFF);
+#endif
+		if (((PAT[pat_scan - 2]<<8) | (PAT[pat_scan - 1])) == 0)
+			continue;
+// workaround for Dreambox PMT "Connection timed out"-problem (not very nice, but it works...)
+#ifdef HAVE_DREAMBOX_HARDWARE
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+		if ((dmx = open(DMX, O_RDWR)) == -1)
+		{
+			perror("TuxTxt <open DMX>");
+			return 0;
+		}
+#endif
+		dmx_flt.pid               = (PAT[pat_scan]<<8 | PAT[pat_scan+1]) & 0x1FFF;
+		dmx_flt.flags             = DMX_ONESHOT | DMX_CHECK_CRC | DMX_IMMEDIATE_START;
+		dmx_flt.filter.filter[0]  = 0x02;
+		dmx_flt.filter.mask[0]    = 0xFF;
+		dmx_flt.timeout           = 5000;
+
+		if (ioctl(dmx, DMX_SET_FILTER, &dmx_flt) == -1)
+		{
+			perror("TuxTxt <DMX_SET_FILTER PMT>");
+			continue;
+		}
+
+		if (read(dmx, PMT, sizeof(PMT)) == -1)
+		{
+			perror("TuxTxt <read PMT>");
+			continue;
+		}
+		for (pmt_scan = 0x0C + ((PMT[0x0A]<<8 | PMT[0x0B]) & 0x0FFF);
+			  pmt_scan < (((PMT[0x01]<<8 | PMT[0x02]) & 0x0FFF) - 7);
+			  pmt_scan += 5 + PMT[pmt_scan + 4])
+		{
+			if (PMT[pmt_scan] == 6)
+			{
+				for (desc_scan = pmt_scan + 5;
+					  desc_scan < pmt_scan + ((PMT[pmt_scan + 3]<<8 | PMT[pmt_scan + 4]) & 0x0FFF) + 5;
+					  desc_scan += 2 + PMT[desc_scan + 1])
+				{
+					if (PMT[desc_scan] == 0x56)
+					{
+						char country_code[4];
+
+						for (pid_test = 0; pid_test < pids_found; pid_test++)
+							if (pid_table[pid_test].vtxt_pid == ((PMT[pmt_scan + 1]<<8 | PMT[pmt_scan + 2]) & 0x1FFF))
+								goto skip_pid;
+
+						pid_table[pids_found].vtxt_pid     = (PMT[pmt_scan + 1]<<8 | PMT[pmt_scan + 2]) & 0x1FFF;
+						pid_table[pids_found].service_id = PMT[0x03]<<8 | PMT[0x04];
+						if (PMT[desc_scan + 1] == 5)
+						{
+							country_code[0] = PMT[desc_scan + 2] | 0x20;
+							country_code[1] = PMT[desc_scan + 3] | 0x20;
+							country_code[2] = PMT[desc_scan + 4] | 0x20;
+							country_code[3] = 0;
+							pid_table[pids_found].national_subset = GetNationalSubset(country_code);
+						}
+						else
+						{
+							country_code[0] = 0;
+							pid_table[pids_found].national_subset = NAT_DEFAULT; /* use default charset */
+						}
+
+#if TUXTXT_DEBUG
+						printf("TuxTxt <Service %04x Country code \"%3s\" national subset %2d%s>\n",
+								 pid_table[pids_found].service_id,
+								 country_code,
+								 pid_table[pids_found].national_subset,
+								 (pid_table[pids_found].vtxt_pid == tuxtxt_cache.vtxtpid) ? " * " : ""
+								 );
+#endif
+
+						pids_found++;
+skip_pid:
+					;
+					}
+				}
+			}
+		}
+	}
+
+	/* check for teletext */
+	if (pids_found == 0)
+	{
+#if TUXTXT_DEBUG
+		printf("TuxTxt <no Teletext on TS found>\n");
+#endif
+
+		RenderMessage(NoServicesFound);
+		sleep(3);
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+		return 0;
+	}
+
+	/* read SDT to get servicenames */
+	SDT_ready = 0;
+
+	dmx_flt.pid              = 0x0011;
+	dmx_flt.flags            = DMX_CHECK_CRC | DMX_IMMEDIATE_START;
+	dmx_flt.filter.filter[0] = 0x42;
+	dmx_flt.filter.mask[0]   = 0xFF;
+	dmx_flt.timeout          = 5000;
+
+	if (ioctl(dmx, DMX_SET_FILTER, &dmx_flt) == -1)
+	{
+		perror("TuxTxt <DMX_SET_FILTER SDT>");
+
+		RenderMessage(ShowServiceName);
+		ioctl(dmx, DMX_STOP);
+		close(dmx);
+
+		return 1;
+	}
+
+	first_sdt_sec = -1;
+	while (1)
+	{
+		if (read(dmx, SDT, 3) == -1)
+		{
+			perror("TuxTxt <read SDT>");
+
+			ioctl(dmx, DMX_STOP);
+			close(dmx);
+			RenderMessage(ShowServiceName);
+			return 1;
+		}
+
+		if (read(dmx, SDT+3, ((SDT[1] & 0x0f) << 8) | SDT[2]) == -1)
+		{
+			perror("TuxTxt <read SDT>");
+
+			ioctl(dmx, DMX_STOP);
+			close(dmx);
+			RenderMessage(ShowServiceName);
+			return 1;
+		}
+
+		if (first_sdt_sec == SDT[6])
+			break;
+
+		if (first_sdt_sec == -1)
+			first_sdt_sec = SDT[6];
+
+		/* scan SDT to get servicenames */
+		for (sdt_scan = 0x0B; sdt_scan < ((SDT[1]<<8 | SDT[2]) & 0x0FFF) - 7; sdt_scan += 5 + ((SDT[sdt_scan + 3]<<8 | SDT[sdt_scan + 4]) & 0x0FFF))
+		{
+			for (pid_test = 0; pid_test < pids_found; pid_test++)
+			{
+				if ((SDT[sdt_scan]<<8 | SDT[sdt_scan + 1]) == pid_table[pid_test].service_id && SDT[sdt_scan + 5] == 0x48)
+				{
+					diff = 0;
+					pid_table[pid_test].service_name_len = SDT[sdt_scan+9 + SDT[sdt_scan+8]];
+
+					for (byte = 0; byte < pid_table[pid_test].service_name_len; byte++)
+					{
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x5B;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x7B;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x5C;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x7C;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x5D;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x7D;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] == (unsigned char)'')
+							SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] = 0x7E;
+						if (SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] >= 0x80 && SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte] <= 0x9F)
+							diff--;
+						else
+							pid_table[pid_test].service_name[byte + diff] = SDT[sdt_scan+10 + SDT[sdt_scan + 8] + byte];
+					}
+
+					pid_table[pid_test].service_name_len += diff;
+				}
+			}
+		}
+	}
+	ioctl(dmx, DMX_STOP);
+	SDT_ready = 1;
+
+	/* show current servicename */
+	current_service = 0;
+
+	if (tuxtxt_cache.vtxtpid != 0)
+	{
+		while (pid_table[current_service].vtxt_pid != tuxtxt_cache.vtxtpid && current_service < pids_found)
+			current_service++;
+
+		if (auto_national && current_service < pids_found)
+			national_subset = pid_table[current_service].national_subset;
+		RenderMessage(ShowServiceName);
+	}
+
+	getpidsdone = 1;
+
+	RenderCharLCD(pids_found/10,  7, 44);
+	RenderCharLCD(pids_found%10, 19, 44);
+	ioctl(dmx, DMX_STOP);
+	close(dmx);
+
+	debugf(5, "%s: <\n", __func__);
+
+	return 1;
+}
+
+/******************************************************************************
+ * GetNationalSubset                                                          *
+ ******************************************************************************/
+
+int GetNationalSubset(char *cc)
+{
+	debugf(5, "%s: >\n", __func__);
+
+	if (memcmp(cc, "cze", 3) == 0 || memcmp(cc, "ces", 3) == 0 ||
+	    memcmp(cc, "slo", 3) == 0 || memcmp(cc, "slk", 3) == 0)
+		return 0;
+	if (memcmp(cc, "eng", 3) == 0)
+		return 1;
+	if (memcmp(cc, "est", 3) == 0)
+		return 2;
+	if (memcmp(cc, "fre", 3) == 0 || memcmp(cc, "fra", 3) == 0)
+		return 3;
+	if (memcmp(cc, "ger", 3) == 0 || memcmp(cc, "deu", 3) == 0)
+		return 4;
+	if (memcmp(cc, "ita", 3) == 0)
+		return 5;
+	if (memcmp(cc, "lav", 3) == 0 || memcmp(cc, "lit", 3) == 0)
+		return 6;
+	if (memcmp(cc, "pol", 3) == 0)
+		return 7;
+	if (memcmp(cc, "spa", 3) == 0 || memcmp(cc, "por", 3) == 0)
+		return 8;
+	if (memcmp(cc, "rum", 3) == 0 || memcmp(cc, "ron", 3) == 0)
+		return 9;
+	if (memcmp(cc, "scc", 3) == 0 || memcmp(cc, "srp", 3) == 0 ||
+	    memcmp(cc, "scr", 3) == 0 || memcmp(cc, "hrv", 3) == 0 ||
+	    memcmp(cc, "slv", 3) == 0)
+		return 10;
+	if (memcmp(cc, "swe", 3) == 0 ||
+	    memcmp(cc, "dan", 3) == 0 ||
+	    memcmp(cc, "nor", 3) == 0 ||
+	    memcmp(cc, "fin", 3) == 0 ||
+	    memcmp(cc, "hun", 3) == 0)
+		return 11;
+	if (memcmp(cc, "tur", 3) == 0)
+		return 12;
+	if (memcmp(cc, "rus", 3) == 0 ||
+	    memcmp(cc, "bul", 3) == 0 ||
+	    memcmp(cc, "ser", 3) == 0 ||
+	    memcmp(cc, "cro", 3) == 0 ||
+	    memcmp(cc, "ukr", 3) == 0)
+		return NAT_RU;
+	if (memcmp(cc, "gre", 3) == 0)
+		return NAT_GR;
+
+	debugf(5, "%s: <\n", __func__);
+
+	return NAT_DEFAULT;	/* use default charset */
+}
+
+/******************************************************************************
+ * ConfigMenu                                                                 *
+ ******************************************************************************/
+#ifdef CONFIG_MENU
+#if TUXTXT_DEBUG
+void charpage()
+{
+	PosY = StartY;
+	PosX = StartX;
+	char cachefill[100];
+	int fullsize =0,hexcount = 0, col, p,sp;
+	int escpage = 0;
+	tstCachedPage* pg;
+	ClearFB(black);
+
+	int zipsize = 0;
+	for (p = 0; p < 0x900; p++)
+	{
+		for (sp = 0; sp < 0x80; sp++)
+		{
+			pg = tuxtxt_cache.astCachetable[p][sp];
+			if (pg)
+			{
+
+				fullsize+=23*40;
+				zipsize += tuxtxt_get_zipsize(p,sp);
+			}
+		}
+	}
+
+
+	memset(cachefill,' ',40);
+	sprintf(cachefill,"f:%d z:%d h:%d c:%d %03x",fullsize, zipsize, hexcount, tuxtxt_cache.cached_pages, escpage);
+
+	for (col = 0; col < 40; col++)
+	{
+		RenderCharFB(cachefill[col], &atrtable[ATR_WB]);
+	}
+	tstPageAttr atr;
+	memcpy(&atr,&atrtable[ATR_WB],sizeof(tstPageAttr));
+	int row;
+	atr.charset = C_G0P;
+	PosY = StartY+fontheight;
+	for (row = 0; row < 16; row++)
+	{
+		PosY+= fontheight;
+		SetPosX(1);
+		for (col=0; col < 6; col++)
+		{
+			RenderCharFB(col*16+row+0x20, &atr);
+		}
+	}
+	atr.setX26 = 1;
+	PosY = StartY+fontheight;
+	for (row = 0; row < 16; row++)
+	{
+		PosY+= fontheight;
+		SetPosX(10);
+		for (col=0; col < 6; col++)
+		{
+			RenderCharFB(col*16+row+0x20, &atr);
+		}
+	}
+	PosY = StartY+fontheight;
+	atr.charset = C_G2;
+	atr.setX26 = 0;
+	for (row = 0; row < 16; row++)
+	{
+		PosY+= fontheight;
+		SetPosX(20);
+		for (col=0; col < 6; col++)
+		{
+			RenderCharFB(col*16+row+0x20, &atr);
+		}
+	}
+	atr.charset = C_G3;
+	PosY = StartY+fontheight;
+	for (row = 0; row < 16; row++)
+	{
+		PosY+= fontheight;
+		SetPosX(30);
+		for (col=0; col < 6; col++)
+		{
+			RenderCharFB(col*16+row+0x20, &atr);
+		}
+	}
+	do
+	{
+		GetRCCode();
+	}
+	while (RCCode != RC_OK && RCCode != RC_HOME);
+}
+#endif
+
+void Menu_HighlightLine(char *menu, int line, int high)
+{
+	char hilitline[] = "0111111111111111111111111111102";
+	int itext = Menu_Width*line; /* index start menuline */
+	int byte;
+	int national_subset_bak = national_subset;
+
+	debugf(5, "%s: >\n", __func__);
+
+	PosX = Menu_StartX;
+	PosY = Menu_StartY + line*fontheight;
+	if (line == MenuLine[M_NAT])
+		national_subset = national_subset_bak;
+	else
+		national_subset = menusubset[menulanguage];
+
+	for (byte = 0; byte < Menu_Width; byte++)
+		RenderCharFB(menu[itext + byte],
+						 high ?
+						 &atrtable[hilitline[byte] - '0' + ATR_MENUHIL0] :
+						 &atrtable[menuatr[itext + byte] - '0' + ATR_MENU0]);
+	national_subset = national_subset_bak;
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+void Menu_UpdateHotlist(char *menu, int hotindex, int menuitem)
+{
+	int i, j, k;
+	tstPageAttr *attr;
+
+	debugf(5, "%s: >\n", __func__);
+
+	PosX = Menu_StartX + 6*fontwidth;
+	PosY = Menu_StartY + (MenuLine[M_HOT]+1)*fontheight;
+	j = Menu_Width*(MenuLine[M_HOT]+1) + 6; /* start index in menu */
+
+	for (i = 0; i <= maxhotlist+1; i++)
+	{
+		if (i == maxhotlist+1) /* clear last+1 entry in case it was deleted */
+		{
+			attr = &atrtable[ATR_MENU5];
+			memset(&menu[j], ' ', 3);
+		}
+		else
+		{
+			if (i == hotindex)
+				attr = &atrtable[ATR_MENU1];
+			else
+			attr = &atrtable[ATR_MENU5];
+			hex2str(&menu[j+2], hotlist[i]);
+		}
+
+		for (k = 0; k < 3; k++)
+			RenderCharFB(menu[j+k], attr);
+
+		if (i == 4)
+		{
+			PosX = Menu_StartX + 6*fontwidth;
+			PosY += fontheight;
+			j += 2*Menu_Width - 4*4;
+		}
+		else
+		{
+			j += 4; /* one space distance */
+			PosX += fontwidth;
+		}
+	}
+
+	hex2str(&menu[Menu_Width*MenuLine[M_HOT] + hotlistpagecolumn[menulanguage]], (hotindex >= 0) ? hotlist[hotindex] : tuxtxt_cache.page);
+	memcpy(&menu[Menu_Width*MenuLine[M_HOT] + hotlisttextcolumn[menulanguage]], &hotlisttext[menulanguage][(hotindex >= 0) ? 5 : 0], 5);
+	PosX = Menu_StartX + 20*fontwidth;
+	PosY = Menu_StartY + MenuLine[M_HOT]*fontheight;
+
+	Menu_HighlightLine(menu, MenuLine[M_HOT], (menuitem == M_HOT) ? 1 : 0);
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+void Menu_Init(char *menu, int current_pid, int menuitem, int hotindex)
+{
+	int byte, line;
+	int national_subset_bak = national_subset;
+
+	debugf(5, "%s: >\n", __func__);
+
+	memcpy(menu, configmenu[menulanguage], Menu_Height*Menu_Width);
+
+	if (getpidsdone)
+	{
+		memset(&menu[MenuLine[M_PID]*Menu_Width+3], 0x20,24);
+		if (SDT_ready)
+			memcpy(&menu[MenuLine[M_PID]*Menu_Width+3+(24-pid_table[current_pid].service_name_len)/2], &pid_table[current_pid].service_name, pid_table[current_pid].service_name_len);
+		else
+			hex2str(&menu[MenuLine[M_PID]*Menu_Width + 13 + 3], tuxtxt_cache.vtxtpid);
+	}
+	if (!getpidsdone || current_pid == 0 || pids_found == 1)
+		menu[MenuLine[M_PID]*Menu_Width +  1] = ' ';
+
+	if (!getpidsdone || current_pid == pids_found - 1 || pids_found == 1)
+		menu[MenuLine[M_PID]*Menu_Width + 28] = ' ';
+
+
+	/* set 16:9 modi, colors & national subset */
+	memcpy(&menu[Menu_Width*MenuLine[M_SC1] + Menu_Width - 5], &configonoff[menulanguage][screen_mode1  ? 3 : 0], 3);
+	memcpy(&menu[Menu_Width*MenuLine[M_SC2] + Menu_Width - 5], &configonoff[menulanguage][screen_mode2  ? 3 : 0], 3);
+
+	menu[MenuLine[M_COL]*Menu_Width +  1] = (color_mode == 1  ? ' ' : '');
+	menu[MenuLine[M_COL]*Menu_Width + 28] = (color_mode == 24 ? ' ' : '');
+	memset(&menu[Menu_Width*MenuLine[M_COL] + 3             ], 0x7f,color_mode);
+	memset(&menu[Menu_Width*MenuLine[M_COL] + 3+color_mode  ], 0x20,24-color_mode);
+//	memcpy(&menu[Menu_Width*MenuLine[M_COL] + Menu_Width - 5], &configonoff[menulanguage][color_mode    ? 3 : 0], 3);
+	menu[MenuLine[M_TRA]*Menu_Width +  1] = (trans_mode == 1  ? ' ' : '');
+	menu[MenuLine[M_TRA]*Menu_Width + 28] = (trans_mode == 24 ? ' ' : '');
+	memset(&menu[Menu_Width*MenuLine[M_TRA] + 3             ], 0x7f,trans_mode);
+	memset(&menu[Menu_Width*MenuLine[M_TRA] + 3+trans_mode  ], 0x20,24-trans_mode);
+
+	memcpy(&menu[Menu_Width*MenuLine[M_AUN] + Menu_Width - 5], &configonoff[menulanguage][auto_national ? 3 : 0], 3);
+	if (national_subset != NAT_DE)
+		memcpy(&menu[Menu_Width*MenuLine[M_NAT] + 2], &countrystring[national_subset*COUNTRYSTRING_WIDTH], COUNTRYSTRING_WIDTH);
+	if (national_subset == 0  || auto_national)
+		menu[MenuLine[M_NAT]*Menu_Width +  1] = ' ';
+	if (national_subset == MAX_NATIONAL_SUBSET || auto_national)
+		menu[MenuLine[M_NAT]*Menu_Width + 28] = ' ';
+	if (showhex)
+		menu[MenuLine[M_PID]*Menu_Width + 27] = '?';
+	/* render menu */
+	PosY = Menu_StartY;
+	for (line = 0; line < Menu_Height; line++)
+	{
+		PosX = Menu_StartX;
+		if (line == MenuLine[M_NAT])
+			national_subset = national_subset_bak;
+		else
+			national_subset = menusubset[menulanguage];
+
+		if (line == Menu_Height-2)
+			memcpy(&menu[line*Menu_Width + 21], versioninfo, 4);
+
+		for (byte = 0; byte < Menu_Width; byte++)
+			RenderCharFB(menu[line*Menu_Width + byte], &atrtable[menuatr[line*Menu_Width + byte] - '0' + ATR_MENU0]);
+
+		PosY += fontheight;
+	}
+	national_subset = national_subset_bak;
+	Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+	Menu_UpdateHotlist(menu, hotindex, menuitem);
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+void ConfigMenu(int Init)
+{
+	int menuitem = M_Start;
+	int current_pid = 0;
+	int hotindex;
+	int oldscreenmode;
+	int i;
+	int national_subset_bak = national_subset;
+	char menu[Menu_Height*Menu_Width];
+
+	debugf(5, "%s: >\n", __func__);
+
+	if (auto_national && tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage] &&
+		tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage]->pageinfo.nationalvalid)
+		national_subset = countryconversiontable[tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage]->pageinfo.national];
+
+	if (getpidsdone)
+	{
+		/* set current vtxt */
+		if (tuxtxt_cache.vtxtpid == 0)
+			tuxtxt_cache.vtxtpid = pid_table[0].vtxt_pid;
+		else
+			while(pid_table[current_pid].vtxt_pid != tuxtxt_cache.vtxtpid && current_pid < pids_found)
+				current_pid++;
+	}
+
+	/* reset to normal mode */
+	if (zoommode)
+		zoommode = 0;
+
+	if (transpmode)
+	{
+		transpmode = 0;
+		ClearBB(black);
+	}
+
+	oldscreenmode = screenmode;
+	if (screenmode)
+		SwitchScreenMode(0); /* turn off divided screen */
+
+	hotindex = getIndexOfPageInHotlist();
+
+	/* clear framebuffer */
+	ClearFB(transp);
+	clearbbcolor = black;
+	Menu_Init(menu, current_pid, menuitem, hotindex);
+
+	/* set blocking mode */
+	blocking = 1;
+	blit();
+
+	/* loop */
+	do {
+		if (GetRCCode() == 1)
+		{
+			//blit();
+			if (
+#if (RC_1 > 0)
+				RCCode >= RC_1 && /* generates a warning... */
+#endif
+				RCCode <= RC_1+M_MaxDirect) /* direct access */
+			{
+				Menu_HighlightLine(menu, MenuLine[menuitem], 0);
+				menuitem = RCCode-RC_1;
+				Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+
+				if (menuitem != M_PID) /* just select */
+					RCCode = RC_OK;
+			}
+
+			switch (RCCode)
+			{
+			case RC_UP:
+				Menu_HighlightLine(menu, MenuLine[menuitem], 0);
+				if (--menuitem < 0)
+					menuitem = M_Number-1;
+				if (auto_national && (menuitem == M_NAT))
+					menuitem--;
+				Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+				break;
+
+			case RC_DOWN:
+				Menu_HighlightLine(menu, MenuLine[menuitem], 0);
+				if (++menuitem > M_Number-1)
+					menuitem = 0;
+				if (auto_national && (menuitem == M_NAT))
+					menuitem++;
+				Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+				break;
+
+			case RC_LEFT:
+				switch (menuitem)
+				{
+				case M_COL:
+					saveconfig = 1;
+					color_mode--;
+					if (color_mode < 1) color_mode = 1;
+					menu[MenuLine[M_COL]*Menu_Width +  1] = (color_mode == 1  ? ' ' : '');
+					menu[MenuLine[M_COL]*Menu_Width + 28] = (color_mode == 24 ? ' ' : '');
+					memset(&menu[Menu_Width*MenuLine[M_COL] + 3             ], 0x7f,color_mode);
+					memset(&menu[Menu_Width*MenuLine[M_COL] + 3+color_mode  ], 0x20,24-color_mode);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					setcolors((unsigned short *)defaultcolors, 0, SIZECOLTABLE);
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				case M_TRA:
+					saveconfig = 1;
+					trans_mode--;
+					if (trans_mode < 1) trans_mode = 1;
+					menu[MenuLine[M_TRA]*Menu_Width +  1] = (trans_mode == 1  ? ' ' : '');
+					menu[MenuLine[M_TRA]*Menu_Width + 28] = (trans_mode == 24 ? ' ' : '');
+					memset(&menu[Menu_Width*MenuLine[M_TRA] + 3             ], 0x7f,trans_mode);
+					memset(&menu[Menu_Width*MenuLine[M_TRA] + 3+trans_mode  ], 0x20,24-trans_mode);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					setcolors((unsigned short *)defaultcolors, 0, SIZECOLTABLE);
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				case M_PID:
+				{
+					if (!getpidsdone)
+					{
+						GetTeletextPIDs();
+						ClearFB(transp);
+						/* set current vtxt */
+						if (tuxtxt_cache.vtxtpid == 0)
+							tuxtxt_cache.vtxtpid = pid_table[0].vtxt_pid;
+						else
+							while(pid_table[current_pid].vtxt_pid != tuxtxt_cache.vtxtpid && current_pid < pids_found)
+								current_pid++;
+						Menu_Init(menu, current_pid, menuitem, hotindex);
+					}
+					if (current_pid > 0)
+					{
+						current_pid--;
+
+						memset(&menu[MenuLine[M_PID]*Menu_Width + 3], ' ', 24);
+
+						if (SDT_ready)
+						{
+							memcpy(&menu[MenuLine[M_PID]*Menu_Width+3+(24-pid_table[current_pid].service_name_len)/2],
+							       &pid_table[current_pid].service_name,
+							       pid_table[current_pid].service_name_len);
+						}
+						else
+							hex2str(&menu[MenuLine[M_PID]*Menu_Width + 13 + 3], tuxtxt_cache.vtxtpid);
+
+						if (pids_found > 1)
+						{
+							if (current_pid == 0)
+							{
+								menu[MenuLine[M_PID]*Menu_Width +  1] = ' ';
+								menu[MenuLine[M_PID]*Menu_Width + 28] = '';
+							}
+							else
+							{
+								menu[MenuLine[M_PID]*Menu_Width +  1] = '';
+								menu[MenuLine[M_PID]*Menu_Width + 28] = '';
+							}
+						}
+
+						Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+
+						if (auto_national)
+						{
+							national_subset = pid_table[current_pid].national_subset;
+
+							memcpy(&menu[Menu_Width*MenuLine[M_NAT] + 2], &countrystring[national_subset*COUNTRYSTRING_WIDTH], COUNTRYSTRING_WIDTH);
+							Menu_HighlightLine(menu, MenuLine[M_NAT], 0);
+						}
+					}
+					break;
+				}
+
+				case M_NAT:
+					saveconfig = 1;
+					if (national_subset > 0)
+					{
+						national_subset--;
+
+						if (national_subset == 0)
+						{
+							menu[MenuLine[M_NAT]*Menu_Width +  1] = ' ';
+							menu[MenuLine[M_NAT]*Menu_Width + 28] = '';
+						}
+						else
+						{
+							menu[MenuLine[M_NAT]*Menu_Width +  1] = '';
+							menu[MenuLine[M_NAT]*Menu_Width + 28] = '';
+						}
+
+						Menu_Init(menu, current_pid, menuitem, hotindex);
+					}
+					break;
+
+				case M_HOT: /* move towards top of hotlist */
+					if (hotindex <= 0) /* if not found, start at end */
+						hotindex = maxhotlist;
+					else
+						hotindex--;
+					Menu_UpdateHotlist(menu, hotindex, menuitem);
+					break;
+
+				case M_LNG:
+					saveconfig = 1;
+					if (--menulanguage < 0)
+						menulanguage = MAXMENULANGUAGE;
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				} /* switch menuitem */
+				break; /* RC_LEFT */
+
+			case RC_RIGHT:
+				switch (menuitem)
+				{
+				case M_COL:
+					saveconfig = 1;
+					color_mode++;
+					if (color_mode > 24) color_mode = 24;
+					menu[MenuLine[M_COL]*Menu_Width +  1] = (color_mode == 1  ? ' ' : '');
+					menu[MenuLine[M_COL]*Menu_Width + 28] = (color_mode == 24 ? ' ' : '');
+					memset(&menu[Menu_Width*MenuLine[M_COL] + 3             ], 0x7f,color_mode);
+					memset(&menu[Menu_Width*MenuLine[M_COL] + 3+color_mode  ], 0x20,24-color_mode);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					setcolors((unsigned short *)defaultcolors, 0, SIZECOLTABLE);
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				case M_TRA:
+					saveconfig = 1;
+					trans_mode++;
+					if (trans_mode > 24) trans_mode = 24;
+					menu[MenuLine[M_TRA]*Menu_Width +  1] = (trans_mode == 1  ? ' ' : '');
+					menu[MenuLine[M_TRA]*Menu_Width + 28] = (trans_mode == 24 ? ' ' : '');
+					memset(&menu[Menu_Width*MenuLine[M_TRA] + 3             ], 0x7f,trans_mode);
+					memset(&menu[Menu_Width*MenuLine[M_TRA] + 3+trans_mode  ], 0x20,24-trans_mode);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					setcolors((unsigned short *)defaultcolors, 0, SIZECOLTABLE);
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				case M_PID:
+					if (!getpidsdone)
+					{
+						GetTeletextPIDs();
+						ClearFB(transp);
+						/* set current vtxt */
+						if (tuxtxt_cache.vtxtpid == 0)
+							tuxtxt_cache.vtxtpid = pid_table[0].vtxt_pid;
+						else
+							while(pid_table[current_pid].vtxt_pid != tuxtxt_cache.vtxtpid && current_pid < pids_found)
+								current_pid++;
+						Menu_Init(menu, current_pid, menuitem, hotindex);
+					}
+					if (current_pid < pids_found - 1)
+					{
+						current_pid++;
+
+						memset(&menu[MenuLine[M_PID]*Menu_Width + 3], ' ', 24);
+
+						if (SDT_ready)
+							memcpy(&menu[MenuLine[M_PID]*Menu_Width + 3 +
+											 (24-pid_table[current_pid].service_name_len)/2],
+									 &pid_table[current_pid].service_name,
+									 pid_table[current_pid].service_name_len);
+						else
+							hex2str(&menu[MenuLine[M_PID]*Menu_Width + 13 + 3], pid_table[current_pid].vtxt_pid);
+
+						if (pids_found > 1)
+						{
+							if (current_pid == pids_found - 1)
+							{
+								menu[MenuLine[M_PID]*Menu_Width +  1] = '';
+								menu[MenuLine[M_PID]*Menu_Width + 28] = ' ';
+							}
+							else
+							{
+								menu[MenuLine[M_PID]*Menu_Width +  1] = '';
+								menu[MenuLine[M_PID]*Menu_Width + 28] = '';
+							}
+						}
+
+						Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+
+						if (auto_national)
+						{
+							if (getpidsdone)
+								national_subset = pid_table[current_pid].national_subset;
+							memcpy(&menu[Menu_Width*MenuLine[M_NAT] + 2], &countrystring[national_subset*COUNTRYSTRING_WIDTH], COUNTRYSTRING_WIDTH);
+							Menu_HighlightLine(menu, MenuLine[M_NAT], 0);
+						}
+					}
+					break;
+
+				case M_NAT:
+					saveconfig = 1;
+					if (national_subset < MAX_NATIONAL_SUBSET)
+					{
+						national_subset++;
+
+						if (national_subset == MAX_NATIONAL_SUBSET)
+						{
+							menu[MenuLine[M_NAT]*Menu_Width +  1] = '';
+							menu[MenuLine[M_NAT]*Menu_Width + 28] = ' ';
+						}
+						else
+						{
+							menu[MenuLine[M_NAT]*Menu_Width +  1] = '';
+							menu[MenuLine[M_NAT]*Menu_Width + 28] = '';
+						}
+
+						Menu_Init(menu, current_pid, menuitem, hotindex);
+					}
+					break;
+
+				case M_HOT: /* select hotindex */
+					if ((unsigned int)hotindex >= maxhotlist) /* if not found, start at 0 */
+						hotindex = 0;
+					else
+						hotindex++;
+					Menu_UpdateHotlist(menu, hotindex, menuitem);
+					break;
+
+				case M_LNG:
+					saveconfig = 1;
+					if (++menulanguage > MAXMENULANGUAGE)
+						menulanguage = 0;
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				}
+				break; /* RC_RIGHT */
+
+			case RC_PLUS:
+				switch (menuitem)
+				{
+				case M_HOT: /* move towards end of hotlist */
+				{
+					if (hotindex<0) /* not found: add page at end */
+					{
+						if (maxhotlist < (sizeof(hotlist)/sizeof(hotlist[0])-1)) /* only if still room left */
+						{
+							hotindex = ++maxhotlist;
+							hotlist[hotindex] = tuxtxt_cache.page;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+					else /* found */
+					{
+						if (hotindex < maxhotlist) /* not already at end */
+						{
+							int temp = hotlist[hotindex];
+							hotlist[hotindex] = hotlist[hotindex+1];
+							hotlist[hotindex+1] = temp;
+							hotindex++;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+				}
+				break;
+				}
+				break; /* RC_PLUS */
+
+			case RC_MINUS:
+				switch (menuitem)
+				{
+				case M_HOT: /* move towards top of hotlist */
+				{
+					if (hotindex<0) /* not found: add page at top */
+					{
+						if (maxhotlist < (sizeof(hotlist)/sizeof(hotlist[0])-1)) /* only if still room left */
+						{
+							for (hotindex = maxhotlist; hotindex >= 0; hotindex--) /* move rest of list */
+							{
+								hotlist[hotindex+1] = hotlist[hotindex];
+							}
+							maxhotlist++;
+							hotindex = 0;
+							hotlist[hotindex] = tuxtxt_cache.page;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+					else /* found */
+					{
+						if (hotindex > 0) /* not already at front */
+						{
+							int temp = hotlist[hotindex];
+							hotlist[hotindex] = hotlist[hotindex-1];
+							hotlist[hotindex-1] = temp;
+							hotindex--;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+				}
+				break;
+				}
+				break; /* RC_MINUS */
+
+			case RC_HELP:
+				switch (menuitem)
+				{
+				case M_HOT: /* current page is added to / removed from hotlist */
+				{
+					if (hotindex<0) /* not found: add page */
+					{
+						if (maxhotlist < (sizeof(hotlist)/sizeof(hotlist[0])-1)) /* only if still room left */
+						{
+							hotlist[++maxhotlist] = tuxtxt_cache.page;
+							hotindex = maxhotlist;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+					else /* found: remove */
+					{
+						if (maxhotlist > 0) /* don't empty completely */
+						{
+							int i;
+
+							for (i=hotindex; i<maxhotlist; i++) /* move rest of list */
+							{
+								hotlist[i] = hotlist[i+1];
+							}
+							maxhotlist--;
+							if (hotindex > maxhotlist)
+								hotindex = maxhotlist;
+							hotlistchanged = 1;
+							Menu_UpdateHotlist(menu, hotindex, menuitem);
+						}
+					}
+				}
+				break;
+				case M_PID:
+					showhex ^= 1;
+					menu[MenuLine[M_PID]*Menu_Width + 27] = (showhex ? '?' : ' ');
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+				break;
+#if TUXTXT_DEBUG
+				case M_LNG:
+					charpage();
+					ClearFB(transp);
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+				break;
+#endif
+				}
+				break; /* RC_MUTE */
+
+			case RC_OK:
+				switch (menuitem)
+				{
+				case M_PID:
+					if (!getpidsdone)
+					{
+						GetTeletextPIDs();
+						ClearFB(transp);
+						/* set current vtxt */
+						if (tuxtxt_cache.vtxtpid == 0)
+							tuxtxt_cache.vtxtpid = pid_table[0].vtxt_pid;
+						else
+							while(pid_table[current_pid].vtxt_pid != tuxtxt_cache.vtxtpid && current_pid < pids_found)
+								current_pid++;
+						Menu_Init(menu, current_pid, menuitem, hotindex);
+					}
+					else if (pids_found > 1)
+					{
+							if (hotlistchanged)
+								savehotlist();
+
+						if (Init || tuxtxt_cache.vtxtpid != pid_table[current_pid].vtxt_pid)
+							{
+#if TUXTXT_CFG_STANDALONE
+								tuxtxt_stop_thread();
+								tuxtxt_clear_cache();
+#else
+								tuxtxt_stop();
+							if (Init)
+								tuxtxt_cache.vtxtpid = 0; // force clear cache
+#endif
+								/* reset data */
+
+
+								//page_atrb[32] = transp<<4 | transp;
+								inputcounter = 2;
+
+
+								tuxtxt_cache.page     = 0x100;
+								lastpage = 0x100;
+								prev_100 = 0x100;
+								prev_10  = 0x100;
+								next_100 = 0x100;
+								next_10  = 0x100;
+								tuxtxt_cache.subpage  = 0;
+
+								tuxtxt_cache.pageupdate = 0;
+								tuxtxt_cache.zap_subpage_manual = 0;
+								hintmode = 0;
+								memset(page_char,' ',40 * 25);
+
+								for (i = 0; i < 40*25; i++)
+								{
+									page_atrb[i].fg = transp;
+									page_atrb[i].bg = transp;
+								}
+								ClearFB(transp);
+
+
+								/* start demuxer with new vtxtpid */
+								if (auto_national)
+									national_subset = pid_table[current_pid].national_subset;
+
+#if TUXTXT_CFG_STANDALONE
+								tuxtxt_cache.vtxtpid = pid_table[current_pid].vtxt_pid;
+								tuxtxt_start_thread();
+#else
+								tuxtxt_start(pid_table[current_pid].vtxt_pid);
+#endif
+							}
+//							tuxtxt_cache.pageupdate = 1;
+
+							ClearBB(black);
+							gethotlist();
+
+						/* show new teletext */
+						current_service = current_pid;
+//						RenderMessage(ShowServiceName);
+									
+						blocking = 0;
+						RCCode = -1;
+						if (oldscreenmode)
+							SwitchScreenMode(oldscreenmode); /* restore divided screen */
+						return;
+					}
+					break;
+
+				case M_SC1:
+					saveconfig = 1;
+					screen_mode1++;
+					screen_mode1 &= 1;
+
+					memcpy(&menu[Menu_Width*MenuLine[M_SC1] + Menu_Width - 5], &configonoff[menulanguage][screen_mode1  ? 3 : 0], 3);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					break;
+
+				case M_SC2:
+					saveconfig = 1;
+					screen_mode2++;
+					screen_mode2 &= 1;
+
+					memcpy(&menu[Menu_Width*MenuLine[M_SC2] + Menu_Width - 5], &configonoff[menulanguage][screen_mode2  ? 3 : 0], 3);
+					Menu_HighlightLine(menu, MenuLine[menuitem], 1);
+					break;
+
+
+				case M_AUN:
+					saveconfig = 1;
+					auto_national++;
+					auto_national &= 1;
+					if (auto_national)
+					{
+					 	if (getpidsdone)
+							national_subset = pid_table[current_pid].national_subset;
+						else
+						{
+							if (tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage] &&
+								tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage]->pageinfo.nationalvalid)
+								national_subset = countryconversiontable[tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage]->pageinfo.national];
+							else
+								national_subset = national_subset_bak;
+						}
+
+					}
+					Menu_Init(menu, current_pid, menuitem, hotindex);
+					break;
+				case M_HOT: /* show selected page */
+				{
+					if (hotindex >= 0) /* not found: ignore */
+					{
+						lastpage = tuxtxt_cache.page;
+						tuxtxt_cache.page = hotlist[hotindex];
+						tuxtxt_cache.subpage = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+						inputcounter = 2;
+						tuxtxt_cache.pageupdate = 1;
+						RCCode = RC_HOME;		 /* leave menu */
+					}
+				}
+				break;
+				} /* RC_OK */
+				break;
+			}
+			blit();
+		}
+		//UpdateLCD(); /* update number of cached pages */
+	} while ((RCCode != RC_HOME) && (RCCode != RC_DBOX) && (RCCode != RC_MUTE));
+
+	/* reset to nonblocking mode */
+	blocking = 0;
+	
+	tuxtxt_cache.pageupdate = 1;
+	RCCode = -1;
+	if (oldscreenmode)
+		SwitchScreenMode(oldscreenmode); /* restore divided screen */
+
+	debugf(5, "%s: <\n", __func__);
+}
+#endif
+
+/******************************************************************************
+ * PageInput                                                                  *
+ ******************************************************************************/
+
+void PageInput(int Number)
+{
+	int zoom = 0;
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* clear temp_page */
+	if (inputcounter == 2)
+		temp_page = 0;
+
+	/* check for 0 & 9 on first position */
+	if (Number == 0 && inputcounter == 2)
+	{
+		/* set page */
+		temp_page = lastpage; /* 0 toggles to last page as in program switching */
+		inputcounter = -1;
+	}
+	else if (Number == 9 && inputcounter == 2)
+	{
+		/* set page */
+		temp_page = getIndexOfPageInHotlist(); /* 9 toggles through hotlist */
+
+		if (temp_page<0 || temp_page==maxhotlist) /* from any (other) page go to first page in hotlist */
+			temp_page = (maxhotlist >= 0) ? hotlist[0] : 0x100;
+		else
+			temp_page = hotlist[temp_page+1];
+
+		inputcounter = -1;
+	}
+
+	/* show pageinput */
+	if (zoommode == 2)
+	{
+		zoommode = 1;
+		CopyBB2FB();
+	}
+
+	if (zoommode == 1)
+		zoom = 1<<10;
+
+	PosY = StartY;
+
+	switch (inputcounter)
+	{
+	case 2:
+		SetPosX(1);
+		RenderCharFB(Number | '0', &atrtable[ATR_WB]);
+		RenderCharFB('-', &atrtable[ATR_WB]);
+		RenderCharFB('-', &atrtable[ATR_WB]);
+		break;
+
+	case 1:
+		SetPosX(2);
+		RenderCharFB(Number | '0', &atrtable[ATR_WB]);
+		break;
+
+	case 0:
+		SetPosX(3);
+		RenderCharFB(Number | '0', &atrtable[ATR_WB]);
+		break;
+	}
+
+	/* generate pagenumber */
+	if (inputcounter >= 0)
+		temp_page |= Number << inputcounter*4;
+
+	inputcounter--;
+
+	if (inputcounter < 0)
+	{
+		/* disable subpage zapping */
+		tuxtxt_cache.zap_subpage_manual = 0;
+
+		/* reset input */
+		inputcounter = 2;
+
+		/* set new page */
+		lastpage = tuxtxt_cache.page;
+
+		tuxtxt_cache.page = temp_page;
+		hintmode = 0;
+
+		/* check cache */
+		int subp = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+		if (subp != 0xFF)
+		{
+			tuxtxt_cache.subpage = subp;
+			tuxtxt_cache.pageupdate = 1;
+#if TUXTXT_DEBUG
+			printf("TuxTxt <DirectInput: %.3X-%.2X>\n", tuxtxt_cache.page, tuxtxt_cache.subpage);
+#endif
+
+		}
+		else
+		{
+			tuxtxt_cache.subpage = 0;
+//			RenderMessage(PageNotFound);
+#if TUXTXT_DEBUG
+			printf("TuxTxt <DirectInput: %.3X not found>\n", tuxtxt_cache.page);
+#endif
+		}
+	}
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * GetNextPageOne                                                             *
+ ******************************************************************************/
+
+void GetNextPageOne(int up)
+{
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* disable subpage zapping */
+	tuxtxt_cache.zap_subpage_manual = 0;
+
+	/* abort pageinput */
+	inputcounter = 2;
+
+	/* find next cached page */
+	lastpage = tuxtxt_cache.page;
+
+	int subp;
+	do {
+		if (up)
+			tuxtxt_next_dec(&tuxtxt_cache.page);
+		else
+			tuxtxt_prev_dec(&tuxtxt_cache.page);
+		subp = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+	} while (subp == 0xFF && tuxtxt_cache.page != lastpage);
+
+	/* update page */
+	if (tuxtxt_cache.page != lastpage)
+	{
+		if (zoommode == 2)
+			zoommode = 1;
+
+		tuxtxt_cache.subpage = subp;
+		hintmode = 0;
+		tuxtxt_cache.pageupdate = 1;
+#if TUXTXT_DEBUG
+		printf("TuxTxt <NextPageOne: %.3X-%.2X>\n", tuxtxt_cache.page, tuxtxt_cache.subpage);
+#endif
+	}
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * GetNextSubPage                                                             *
+ ******************************************************************************/
+void GetNextSubPage(int offset)
+{
+	int loop;
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* abort pageinput */
+	inputcounter = 2;
+
+	for (loop = tuxtxt_cache.subpage + offset; loop != tuxtxt_cache.subpage; loop += offset)
+	{
+		if (loop < 0)
+			loop = 0x79;
+		else if (loop > 0x79)
+			loop = 0;
+		if (loop == tuxtxt_cache.subpage)
+			break;
+
+		if (tuxtxt_cache.astCachetable[tuxtxt_cache.page][loop])
+		{
+			/* enable manual subpage zapping */
+			tuxtxt_cache.zap_subpage_manual = 1;
+
+			/* update page */
+			if (zoommode == 2) /* if zoomed to lower half */
+				zoommode = 1; /* activate upper half */
+
+			tuxtxt_cache.subpage = loop;
+			hintmode = 0;
+			tuxtxt_cache.pageupdate = 1;
+#if TUXTXT_DEBUG
+			printf("TuxTxt <NextSubPage: %.3X-%.2X>\n", tuxtxt_cache.page, tuxtxt_cache.subpage);
+#endif
+			return;
+		}
+	}
+
+#if TUXTXT_DEBUG
+	printf("TuxTxt <NextSubPage: no other SubPage>\n");
+#endif
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * ColorKey                                                                   *
+ ******************************************************************************/
+
+void ColorKey(int target)
+{
+	debugf(5, "%s: >\n", __func__);
+
+	if (!target)
+		return;
+	if (zoommode == 2)
+		zoommode = 1;
+	lastpage     = tuxtxt_cache.page;
+	tuxtxt_cache.page         = target;
+	tuxtxt_cache.subpage      = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+	inputcounter = 2;
+	hintmode     = 0;
+	tuxtxt_cache.pageupdate   = 1;
+#if TUXTXT_DEBUG
+	printf("TuxTxt <ColorKey: %.3X>\n", tuxtxt_cache.page);
+#endif
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * PageCatching                                                               *
+ ******************************************************************************/
+
+void PageCatching()
+{
+	int byte;
+	int oldzoommode = zoommode;
+
+	debugf(5, "%s: >\n", __func__);
+
+	pagecatching = 1;
+
+	/* abort pageinput */
+	inputcounter = 2;
+
+	/* show info line */
+	zoommode = 0;
+	PosX = StartX;
+	PosY = StartY + 24*fontheight;
+	for (byte = 0; byte < 40-nofirst; byte++)
+		RenderCharFB(catchmenutext[menulanguage][byte], &atrtable[catchmenutext[menulanguage][byte+40] - '0' + ATR_CATCHMENU0]);
+	zoommode = oldzoommode;
+
+	/* check for pagenumber(s) */
+	catch_row    = 1;
+	catch_col    = 0;
+	catched_page = 0;
+	pc_old_row = pc_old_col = 0; /* no inverted page number to restore yet */
+	CatchNextPage(0, 1);
+
+	if (!catched_page)
+	{
+		pagecatching = 0;
+		tuxtxt_cache.pageupdate = 1;
+		return;
+	}
+
+	/* loop */
+	do {
+		GetRCCode();
+
+		switch (RCCode)
+		{
+		case RC_LEFT:
+			CatchNextPage(0, -1);
+			break;
+		case RC_RIGHT:
+			CatchNextPage(0, 1);
+			break;
+		case RC_UP:
+			CatchNextPage(-1, -1);
+			break;
+		case RC_DOWN:
+			CatchNextPage(1, 1);
+			break;
+		case RC_0:
+		case RC_1:
+		case RC_2:
+		case RC_3:
+		case RC_4:
+		case RC_5:
+		case RC_6:
+		case RC_7:
+		case RC_8:
+		case RC_9:
+		case RC_RED:
+		case RC_GREEN:
+		case RC_YELLOW:
+		case RC_BLUE:
+		case RC_PLUS:
+		case RC_MINUS:
+		case RC_DBOX:
+		case RC_HOME:
+		case RC_HELP:
+		case RC_MUTE:
+			tuxtxt_cache.pageupdate = 1;
+			pagecatching = 0;
+			RCCode = -1;
+			return;
+		}
+		//UpdateLCD();
+	} while (RCCode != RC_OK);
+
+	/* set new page */
+	if (zoommode == 2)
+		zoommode = 1;
+
+	lastpage     = tuxtxt_cache.page;
+	tuxtxt_cache.page         = catched_page;
+	hintmode = 0;
+	tuxtxt_cache.pageupdate = 1;
+	pagecatching = 0;
+
+	int subp = tuxtxt_cache.subpagetable[tuxtxt_cache.page];
+	if (subp != 0xFF)
+		tuxtxt_cache.subpage = subp;
+	else
+		tuxtxt_cache.subpage = 0;
+
+	debugf(5, "%s: <\n", __func__);
+
+}
+
+/******************************************************************************
+ * CatchNextPage                                                              *
+ ******************************************************************************/
+
+void CatchNextPage(int firstlineinc, int inc)
+{
+	int tmp_page, allowwrap = 1; /* allow first wrap around */
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* catch next page */
+	for(;;)
+	{
+		unsigned char *p = &(page_char[catch_row*40 + catch_col]);
+		tstPageAttr a = page_atrb[catch_row*40 + catch_col];
+
+		if (!(a.charset == C_G1C || a.charset == C_G1S) && /* no mosaic */
+			 (a.fg != a.bg) && /* not hidden */
+			 (*p >= '1' && *p <= '8' && /* valid page number */
+			  *(p+1) >= '0' && *(p+1) <= '9' &&
+			  *(p+2) >= '0' && *(p+2) <= '9') &&
+			 (catch_row == 0 || (*(p-1) < '0' || *(p-1) > '9')) && /* non-numeric char before and behind */
+			 (catch_row == 37 || (*(p+3) < '0' || *(p+3) > '9')))
+		{
+			tmp_page = ((*p - '0')<<8) | ((*(p+1) - '0')<<4) | (*(p+2) - '0');
+
+			{
+				catched_page = tmp_page;
+				RenderCatchedPage();
+				catch_col += inc;	/* FIXME: limit */
+#if TUXTXT_DEBUG
+				printf("TuxTxt <PageCatching: %.3X\n", catched_page);
+#endif
+				return;
+			}
+		}
+
+		if (firstlineinc > 0)
+		{
+			catch_row++;
+			catch_col = 0;
+			firstlineinc = 0;
+		}
+		else if (firstlineinc < 0)
+		{
+			catch_row--;
+			catch_col = 37;
+			firstlineinc = 0;
+		}
+		else
+			catch_col += inc;
+
+		if (catch_col > 37)
+		{
+			catch_row++;
+			catch_col = 0;
+		}
+		else if (catch_col < 0)
+		{
+			catch_row--;
+			catch_col = 37;
+		}
+
+		if (catch_row > 23)
+		{
+			if (allowwrap)
+			{
+				allowwrap = 0;
+				catch_row = 1;
+				catch_col = 0;
+			}
+			else
+			{
+#if TUXTXT_DEBUG
+				printf("TuxTxt <PageCatching: no PageNumber>\n");
+#endif
+				return;
+			}
+		}
+		else if (catch_row < 1)
+		{
+			if (allowwrap)
+			{
+				allowwrap = 0;
+				catch_row = 23;
+				catch_col =37;
+			}
+			else
+			{
+#if TUXTXT_DEBUG
+				printf("TuxTxt <PageCatching: no PageNumber>\n");
+#endif
+				return;
+			}
+		}
+	}
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+
+/******************************************************************************
+ * RenderCatchedPage                                                          *
+ ******************************************************************************/
+
+void RenderCatchedPage()
+{
+	int zoom = 0;
+
+	debugf(5, "%s: >\n", __func__);
+
+	/* handle zoom */
+	if (zoommode)
+		zoom = 1<<10;
+
+	if (pc_old_row || pc_old_col) /* not at first call */
+	{
+		/* restore pagenumber */
+		SetPosX(pc_old_col);
+
+		if (zoommode == 2)
+			PosY = StartY + (pc_old_row-12)*fontheight*((zoom>>10)+1);
+		else
+			PosY = StartY + pc_old_row*fontheight*((zoom>>10)+1);
+
+		RenderCharFB(page_char[pc_old_row*40 + pc_old_col    ], &page_atrb[pc_old_row*40 + pc_old_col    ]);
+		RenderCharFB(page_char[pc_old_row*40 + pc_old_col + 1], &page_atrb[pc_old_row*40 + pc_old_col + 1]);
+		RenderCharFB(page_char[pc_old_row*40 + pc_old_col + 2], &page_atrb[pc_old_row*40 + pc_old_col + 2]);
+	}
+
+	pc_old_row = catch_row;
+	pc_old_col = catch_col;
+
+	/* mark pagenumber */
+	if (zoommode == 1 && catch_row > 11)
+	{
+		zoommode = 2;
+		CopyBB2FB();
+	}
+	else if (zoommode == 2 && catch_row < 12)
+	{
+		zoommode = 1;
+		CopyBB2FB();
+	}
+	SetPosX(catch_col);
+
+
+	if (zoommode == 2)
+		PosY = StartY + (catch_row-12)*fontheight*((zoom>>10)+1);
+	else
+		PosY = StartY + catch_row*fontheight*((zoom>>10)+1);
+
+	tstPageAttr a0 = page_atrb[catch_row*40 + catch_col    ];
+	tstPageAttr a1 = page_atrb[catch_row*40 + catch_col + 1];
+	tstPageAttr a2 = page_atrb[catch_row*40 + catch_col + 2];
+	int t;
+
+	/* exchange colors */
+	t = a0.fg; a0.fg = a0.bg; a0.bg = t;
+	t = a1.fg; a1.fg = a1.bg; a1.bg = t;
+	t = a2.fg; a2.fg = a2.bg; a2.bg = t;
+
+	RenderCharFB(page_char[catch_row*40 + catch_col    ], &a0);
+	RenderCharFB(page_char[catch_row*40 + catch_col + 1], &a1);
+	RenderCharFB(page_char[catch_row*40 + catch_col + 2], &a2);
+
+	debugf(5, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * SwitchZoomMode                                                             *
+ ******************************************************************************/
+
+void SwitchZoomMode()
+{
+	debugf(1, "%s: >\n", __func__);
+	
+	if (tuxtxt_cache.subpagetable[tuxtxt_cache.page] != 0xFF)
+	{
+		/* toggle mode */
+		zoommode++;
+
+		if (zoommode == 3)
+			zoommode = 0;
+
+#if TUXTXT_DEBUG
+		printf("TuxTxt <SwitchZoomMode: %d>\n", zoommode);
+#endif
+		/* update page */
+		tuxtxt_cache.pageupdate = 1; /* FIXME */
+	}
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * SwitchScreenMode                                                           *
+ ******************************************************************************/
+
+void getCurrentPIGSettings(int* left, int* top, int* width, int* height)
+{
+	FILE* fd;
+	
+	fd = fopen("/proc/stb/vmpeg/0/dst_left", "r");
+	fscanf(fd, "%x", left);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_top", "r");
+	fscanf(fd, "%x", top);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_width", "r");
+	fscanf(fd, "%x", width);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_height", "r");
+	fscanf(fd, "%x", height);
+	fclose(fd);
+
+	debugf(1, "%s: top %x, left %x, width %x, height %x\n", __func__, *left, *top, *width, *height);
+}
+
+void getCurrentASPECTSettings()
+{
+	FILE* fd;
+	
+	fd = fopen("/proc/stb/video/aspect", "r");
+	fscanf(fd, "%s", aspect);
+	fclose(fd);
+}
+
+void setCurrentPIGSettings(int left, int top, int width, int height)
+{
+	FILE* fd;
+	
+	debugf(1, "%s: top %x, left %x, width %x, height %x\n", __func__, left, top, width, height);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_left", "w");
+	fprintf(fd, "%x", left);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_top", "w");
+	fprintf(fd, "%x", top);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_width", "w");
+	fprintf(fd, "%x", width);
+	fclose(fd);
+
+	fd = fopen("/proc/stb/vmpeg/0/dst_height", "w");
+	fprintf(fd, "%x", height);
+	fclose(fd);
+}
+
+void setCurrentASPECTSettings(int reset)
+{
+	FILE* fd;
+	
+	fd = fopen("/proc/stb/video/aspect", "w");
+	if (reset == 1)
+	   fprintf(fd, "%s", aspect);
+	else
+	   fprintf(fd, "4:3");
+	fclose(fd);
+}
+
+void SwitchScreenMode(int newscreenmode)
+{
+
+	struct v4l2_format format;
+
+	debugf(1, "%s: >\n", __func__);
+
+	/* reset transparency mode */
+	if (transpmode)
+		transpmode = 0;
+
+	if (newscreenmode < 0) /* toggle mode */
+		screenmode++;
+	else /* set directly */
+		screenmode = newscreenmode;
+//	if ((screenmode > (screen_mode2 ? 2 : 1)) || (screenmode < 0))
+	if ((screenmode > 2) || (screenmode < 0))
+		screenmode = 0;
+
+#if TUXTXT_DEBUG
+	printf("TuxTxt <SwitchScreenMode: %d>\n", screenmode);
+#endif
+
+	/* update page */
+	tuxtxt_cache.pageupdate = 1;
+
+	/* clear back buffer */
+	clearbbcolor = screenmode ? transp : FullScrColor;
+
+	ClearBB(clearbbcolor);
+
+	debugf(1, "screenmode %d\n", screenmode); 
+
+	/* set mode */
+	if (screenmode)								 /* split */
+	{
+		ClearFB(clearbbcolor);
+
+		int fw, fh, tx, ty, tw, th;
+
+		debugf(1, "Settup video picture\n");
+
+		if (screenmode==1) /* split with topmenu */
+		{
+
+			fw = fontwidth_topmenumain;
+			fh = fontheight;
+
+			tw = TV43WIDTH;
+
+			displaywidth= (TV43STARTX     -sx);
+			StartX = sx; //+ (((ex-sx) - (40*fw+2+tw)) / 2); /* center screen */
+
+			tx = TV43STARTX;
+			ty = TV43STARTY;
+			th = TV43HEIGHT;
+
+			debugf(1, "%s: top %x, left %x, width %x, height %x\n", __func__, left, top, width, height);
+
+			/* zur erklaerung: habe die werte nicht berechnen lassen,
+			 * da der player die ausgabe werte nochmal umrechnet (wohin auch immer)
+			 * und es dann ggf zu einer " Kernel panic - not syncing: Need true 64-bit/64-bit division"
+			 * kommt
+			 */
+			if (width == 720)
+			{
+				setCurrentPIGSettings(720 - 180, 576 - 150, 180, 150);
+			} else
+			if (width == 1280)
+			{
+				setCurrentPIGSettings(1280 - 250, 440, 250, 460);
+			} else
+			{
+				setCurrentPIGSettings(1920 - 300, 1080 - 200, 300, 200);
+			}
+		}
+		else /* 2: split with full height tv picture */
+		{
+			fw = fontwidth_small;
+			fh = fontheight;
+			tx = TV169FULLSTARTX;
+			ty = TV169FULLSTARTY;
+			tw = TV169FULLWIDTH;
+			th = TV169FULLHEIGHT;
+			displaywidth= (TV169FULLSTARTX-sx);
+
+			debugf(1, "%s: top %x, left %x, width %x, height %x\n", __func__, left, top, width, height);
+
+			/* zur erklaerung: habe die werte nicht berechnen lassen,
+			 * da der player die ausgabe werte nochmal umrechnet (wohin auch immer)
+			 * und es dann ggf zu einer " Kernel panic - not syncing: Need true 64-bit/64-bit division"
+			 * kommt
+			 */
+			if (width == 720)
+			{
+				setCurrentPIGSettings(360, 0, 360, 576);
+			} else
+			if (width == 1280)
+			{
+				setCurrentPIGSettings(640, 0, 640, 720);
+			} else
+			{
+				setCurrentPIGSettings(960, 0, 960, 1080);
+			}
+			
+		}
+
+		setfontwidth(fw);
+
+	}
+	else /* not split */
+	{
+		setCurrentPIGSettings(left, top, width, height);
+
+		setfontwidth(fontwidth_normal);
+		displaywidth= (ex-sx);
+		StartX = sx; //+ (ex-sx - 40*fontwidth) / 2; /* center screen */
+
+	}
+	debugf(1, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * SwitchTranspMode                                                           *
+ ******************************************************************************/
+
+void SwitchTranspMode()
+{
+	debugf(1, "%s: >\n", __func__);
+
+	if (screenmode)
+	{
+		prevscreenmode = screenmode;
+		SwitchScreenMode(0); /* turn off divided screen */
+	}
+	/* toggle mode */
+	if (!transpmode)
+		transpmode = 2;
+	else
+		transpmode--; /* backward to immediately switch to TV-screen */
+
+#if TUXTXT_DEBUG
+	printf("TuxTxt <SwitchTranspMode: %d>\n", transpmode);
+#endif
+
+	/* set mode */
+	if (!transpmode) /* normal text-only */
+	{
+		ClearBB(FullScrColor);
+		tuxtxt_cache.pageupdate = 1;
+	}
+	else if (transpmode == 1) /* semi-transparent BG with FG text */
+	{
+		ClearBB(transp);
+		tuxtxt_cache.pageupdate = 1;
+	}
+	else /* TV mode */
+	{
+		ClearFB(transp);
+		clearbbcolor = FullScrColor;
+	}
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * SwitchHintMode                                                             *
+ ******************************************************************************/
+
+void SwitchHintMode()
+{
+	/* toggle mode */
+	hintmode ^= 1;
+
+	debugf(1, "%s: >\n", __func__);
+
+	if (!hintmode)	/* toggle evaluation of level 2.5 information by explicitly switching off hintmode */
+	{
+		showl25 ^= 1;
+#if TUXTXT_DEBUG
+		printf("TuxTxt <ShowLevel2p5: %d>\n", showl25);
+#endif
+	}
+	/* update page */
+	tuxtxt_cache.pageupdate = 1;
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+void RenderDRCS( //FIXME
+	unsigned char *s,	/* pointer to char data, parity undecoded */
+	unsigned char *d,	/* pointer to frame buffer of top left pixel */
+	unsigned char *ax, /* array[0..12] of x-offsets, array[0..10] of y-offsets for each pixel */
+	unsigned char fgcolor, unsigned char bgcolor)
+{
+	int bit, x, y, ltmp;
+	unsigned char *ay = ax + 13; /* array[0..10] of y-offsets for each pixel */
+
+	debugf(1, "FIXME: SETPIXEL: %s: >\n", __func__);
+
+	for (y = 0; y < 10; y++) /* 10*2 bytes a 6 pixels per char definition */
+	{
+		unsigned char c1 = deparity[*s++];
+		unsigned char c2 = deparity[*s++];
+		int h = ay[y+1] - ay[y];
+
+		if (!h)
+			continue;
+		if (((c1 == ' ') && (*(s-2) != ' ')) || ((c2 == ' ') && (*(s-1) != ' '))) /* parity error: stop decoding FIXME */
+			return;
+		for (bit = 0x20, x = 0;
+			  bit;
+			  bit >>= 1, x++)	/* bit mask (MSB left), column counter */
+		{
+			int i, f1, f2;
+
+			f1 = (c1 & bit) ? fgcolor : bgcolor;
+			f2 = (c2 & bit) ? fgcolor : bgcolor;
+
+			for (i = 0; i < h; i++)
+			{
+				if (ax[x+1] > ax[x])
+				{
+//					memset(d + ax[x], f1, ax[x+1] - ax[x]);
+					for (ltmp=0 ; ltmp < (ax[x+1]-ax[x]); ltmp++)
+					{
+						memcpy(d + ax[x]*4 +ltmp*4,bgra[f1],4);
+					}
+				}
+				if (ax[x+7] > ax[x+6])
+				{
+//					memset(d + ax[x+6], f2, ax[x+7] - ax[x+6]); /* 2nd byte 6 pixels to the right */
+					for (ltmp=0 ; ltmp < (ax[x+7]-ax[x+6]); ltmp++)
+					{
+						memcpy(d + ax[x+6]*4 +ltmp*4,bgra[f2],4);
+					}
+
+				}
+				d += (720*4);
+			}
+			d -= h * (720*4);
+		}
+		d += h * (720*4);
+	}
+
+	debugf(1, "%s: <\n", __func__);
+}
+
+
+void DrawVLine(int x, int y, int l, int color)
+{
+	int ytemp;
+
+	debugf(20, "%s: >\n", __func__);
+
+	for (ytemp = 0; ytemp < l ; ytemp++)
+	{
+		setPixel(x, y + ytemp, color);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void DrawHLine(int x, int y, int l, int color)
+{
+	int ltmp;
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (l > 0)
+	{
+		for (ltmp=0; ltmp < l; ltmp++)
+		{
+			setPixel(x + ltmp, y, color);
+		}
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void FillRectMosaicSeparated(int x, int y, int w, int h, int fgcolor, int bgcolor, int set)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	FillRect(x, y, w, h, bgcolor);
+	if (set)
+	{
+		FillRect(x+1, y+1, w-2, h-2, fgcolor);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void FillTrapez(int x0, int y0, int l0, int xoffset1, int h, int l1, int color)
+{
+	unsigned char *p = lfb + x0*4 + y0 * (720*4);
+	int xoffset, l;
+	int yoffset;
+	int ltmp;
+
+	debugf(20, "%s: >\n", __func__);
+
+	for (yoffset = 0; yoffset < h; yoffset++)
+	{
+		l = l0 + ((l1-l0) * yoffset + h/2) / h;
+		xoffset = (xoffset1 * yoffset + h/2) / h;
+		if (l > 0)
+		{
+			for (ltmp=0; ltmp < l; ltmp++)
+			{
+				setPixel(xoffset + ltmp + x0, yoffset + y0, color);
+				//memcpy(p + xoffset * 4 + ltmp * 4, bgra[color], 4);
+			}
+		}
+		p += (720*4);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+
+}
+
+void FlipHorz(int x, int y, int w, int h)
+{
+	unsigned char buf[w*4];
+	unsigned char *p = lfb + x*4 + y * (720*4);
+	int w1,h1;
+
+	debugf(20, "%s: >\n", __func__);
+
+	for (h1 = 0 ; h1 < h ; h1++)
+	{
+		memcpy(buf,p,w*4);
+		for (w1 = 0 ; w1 < w ; w1++)
+		{
+			if (w1 + x > 720)
+				debugf(1, "%s !!!!!!!!! out of bounds x %d\n", __func__, w1 + x);
+			memcpy(p+w1*4,buf+((w-w1)*4)-4,4);
+		}
+		p += (720*4);
+
+		if (h1 + y > 576)
+			debugf(1, "%s !!!!!!!!! out of bounds y %d\n", __func__, w1 + y);
+
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void FlipVert(int x, int y, int w, int h)
+{
+	unsigned char buf[w*4];
+	unsigned char *p = lfb + x*4 + y * (720*4), *p1, *p2;
+	int h1;
+
+	debugf(20, "%s: >\n", __func__);
+
+	for (h1 = 0 ; h1 < h/2 ; h1++)
+	{
+		p1 = (p+(h1*(720*4)));
+		p2 = (p+(h-(h1+1))*(720*4));
+
+		if (w + x > 720)
+			debugf(1, "%s !!!!!!!!! out of bounds x %d\n", __func__, w + x);
+
+		if ((h-(h1+1) ) + y > 576)
+			debugf(1, "%s !!!!!!!!! out of bounds y %d\n", __func__, (h-(h1+1)) + y);
+
+		if (h1 + y > 576)
+			debugf(1, "%s !!!!!!!!! out of bounds y1 %d\n", __func__, h1 + y);
+		
+		memcpy(buf,p1,w*4);
+		memcpy(p1,p2,w*4);
+		memcpy(p2,buf,w*4);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+int ShapeCoord(int param, int curfontwidth, int curfontheight)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	switch (param)
+	{
+	case S_W13:
+		return curfontwidth/3;
+	case S_W12:
+		return curfontwidth/2;
+	case S_W23:
+		return curfontwidth*2/3;
+	case S_W11:
+		return curfontwidth;
+	case S_WM3:
+		return curfontwidth-3;
+	case S_H13:
+		return curfontheight/3;
+	case S_H12:
+		return curfontheight/2;
+	case S_H23:
+		return curfontheight*2/3;
+	case S_H11:
+		return curfontheight;
+	default:
+		return param;
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void DrawShape(int x, int y, int shapenumber, int curfontwidth, int curfontheight, int fgcolor, int bgcolor, int clear)
+{
+	if (shapenumber < 0x20 || shapenumber > 0x7e || (shapenumber == 0x7e && clear))
+		return;
+
+	unsigned char *p = aShapes[shapenumber - 0x20];
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (*p == S_INV)
+	{
+		int t = fgcolor;
+		fgcolor = bgcolor;
+		bgcolor = t;
+		p++;
+	}
+
+	if (clear)
+		FillRect(x, y, curfontwidth, fontheight, bgcolor);
+	while (*p != S_END)
+		switch (*p++)
+		{
+		case S_FHL:
+		{
+			int offset = ShapeCoord(*p++, curfontwidth, curfontheight);
+			DrawHLine(x, y + offset, curfontwidth, fgcolor);
+			break;
+		}
+		case S_FVL:
+		{
+			int offset = ShapeCoord(*p++, curfontwidth, curfontheight);
+			DrawVLine(x + offset, y, fontheight, fgcolor);
+			break;
+		}
+		case S_FLH:
+			FlipHorz(x,y,curfontwidth, fontheight);
+			break;
+		case S_FLV:
+			FlipVert(x,y,curfontwidth, fontheight);
+			break;
+		case S_BOX:
+		{
+			int xo = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int yo = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int w = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int h = ShapeCoord(*p++, curfontwidth, curfontheight);
+			FillRect(x + xo, y + yo, w, h, fgcolor);
+			break;
+		}
+		case S_TRA:
+		{
+			int x0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int y0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int l0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int x1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int y1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int l1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			FillTrapez(x + x0, y + y0, l0, x1-x0, y1-y0, l1, fgcolor);
+			break;
+		}
+		case S_BTR:
+		{
+			int x0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int y0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int l0 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int x1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int y1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			int l1 = ShapeCoord(*p++, curfontwidth, curfontheight);
+			FillTrapez(x + x0, y + y0, l0, x1-x0, y1-y0, l1, bgcolor);
+			break;
+		}
+		case S_LNK:
+		{
+			DrawShape(x, y, ShapeCoord(*p, curfontwidth, curfontheight), curfontwidth, curfontheight, fgcolor, bgcolor, 0);
+			//p = aShapes[ShapeCoord(*p, curfontwidth, curfontheight) - 0x20];
+			break;
+		}
+		default:
+			break;
+		}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+
+/******************************************************************************
+ * RenderChar                                                                 *
+ ******************************************************************************/
+
+/* Dagobert:
+ * So in this function is the problem with " ...".
+ * The tables in tuxtxt_def.h are of type unsigned int short int
+ * which is propably more than a char. So getting chars out of this
+ * array gives us values >=255 which are not what we want with our
+ * fonts. ok I added "& 0xFF" to get the correct value but this
+ * takes us internationalization but this is ok for me for the first
+ * shot. we take a shorter look why this works for dreambox but
+ * not for us.
+ */
+
+void RenderChar(int Char, tstPageAttr *Attribute, int zoom, int yoffset)
+{
+	int Row, Pitch, Bit;
+	int error, glyph;
+	int bgcolor, fgcolor;
+	int factor, xfactor;
+	int national_subset_local = national_subset;
+	unsigned char *sbitbuffer;
+
+	int curfontwidth = GetCurFontWidth();
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (Attribute->setX26)
+	{
+		national_subset_local = 0; // no national subset
+	}
+
+	// G0+G2 set designation
+	if (Attribute->setG0G2 != 0x3f)
+	{
+		switch (Attribute->setG0G2)
+		{
+			case 0x20 :
+			case 0x24 :
+			case 0x25 :
+				national_subset_local = NAT_RU;
+				break;
+			case 0x37:
+				national_subset_local = NAT_GR;
+				break;
+				//TODO: arabic and hebrew
+			default:
+				national_subset_local = countryconversiontable[Attribute->setG0G2 & 0x07];
+				break;
+
+		}
+
+	}
+	
+	if (Attribute->charset == C_G0S) // use secondary charset
+		national_subset_local = national_subset_secondary;
+	if (zoom && Attribute->doubleh)
+		factor = 4;
+	else if (zoom || Attribute->doubleh)
+		factor = 2;
+	else
+		factor = 1;
+
+	if (Attribute->doublew)
+	{
+		int t = curfontwidth;
+		PosX += t;
+		curfontwidth += GetCurFontWidth();
+		PosX -= t;
+		xfactor = 2;
+	}
+	else
+		xfactor = 1;
+
+	if (Char == 0xFF)	/* skip doubleheight chars in lower line */
+	{
+		PosX += curfontwidth;
+		return;
+	}
+
+	/* get colors */
+	if (Attribute->inverted)
+	{
+		int t = Attribute->fg;
+		Attribute->fg = Attribute->bg;
+		Attribute->bg = t;
+	}
+	fgcolor = Attribute->fg;
+	if (transpmode == 1 && PosY < StartY + 24*fontheight)
+	{
+		if (fgcolor == transp) /* outside boxed elements (subtitles, news) completely transparent */
+			bgcolor = transp;
+		else
+			bgcolor = transp2;
+	}
+	else
+		bgcolor = Attribute->bg;
+
+/*
+debugf(1, "charset = %d\n", Attribute->charset);		
+debugf(1, "national_subset_local = %d\n", national_subset_local);		
+*/
+	/* handle mosaic ->space*/
+	if ((Attribute->charset == C_G1C || Attribute->charset == C_G1S) &&
+		 ((Char&0xA0) == 0x20))
+	{
+		int w1 = (curfontwidth / 2 ) *xfactor;
+		int w2 = (curfontwidth - w1) *xfactor;
+		int y;
+
+		Char = (Char & 0x1f) | ((Char & 0x40) >> 1);
+		if (Attribute->charset == C_G1S) /* separated mosaic */
+			for (y = 0; y < 3; y++)
+			{
+				FillRectMosaicSeparated(PosX,      PosY + yoffset + ymosaic[y]*factor, w1, (ymosaic[y+1] - ymosaic[y])*factor, fgcolor, bgcolor, Char & 0x01);
+				FillRectMosaicSeparated(PosX + w1, PosY + yoffset + ymosaic[y]*factor, w2, (ymosaic[y+1] - ymosaic[y])*factor, fgcolor, bgcolor, Char & 0x02);
+				Char >>= 2;
+			}
+		else
+			for (y = 0; y < 3; y++)
+			{
+				FillRect(PosX,      PosY + yoffset + ymosaic[y]*factor, w1, (ymosaic[y+1] - ymosaic[y])*factor, (Char & 0x01) ? fgcolor : bgcolor);
+				FillRect(PosX + w1, PosY + yoffset + ymosaic[y]*factor, w2, (ymosaic[y+1] - ymosaic[y])*factor, (Char & 0x02) ? fgcolor : bgcolor);
+				Char >>= 2;
+			}
+
+		PosX += curfontwidth;
+/*debugf(1, "hier passierts 5\n");		*/
+		return;
+	}
+
+	if (Attribute->charset == C_G3)
+	{
+		if (Char < 0x20 || Char > 0x7d)
+		{
+			Char = 0x20;
+		}
+		else
+		{
+			if (*aShapes[Char - 0x20] == S_CHR)
+			{
+				unsigned char *p = aShapes[Char - 0x20];
+				Char = (*(p+1) <<8) + (*(p+2));
+			}
+			else if (*aShapes[Char - 0x20] == S_ADT)
+			{
+				int x,y,f,c;
+				unsigned char* p = lfb + PosX*4 + (PosY+yoffset)* (720*4);
+				for (y=0; y<fontheight;y++)
+				{
+					for (f=0; f<factor; f++)
+					{
+						for (x=0; x<curfontwidth*xfactor;x++)
+						{
+							c = (y&4 ? (x/3)&1 :((x+3)/3)&1);
+							setPixel(x + PosX, y + PosY + yoffset, (c ? fgcolor : bgcolor));
+							//memcpy((p+x*4),bgra[(c ? fgcolor : bgcolor)],4);
+						}
+						p += (720*4);
+					}
+				}
+				PosX += curfontwidth;
+				return;
+			}
+			else
+			{
+				DrawShape(PosX, PosY + yoffset, Char, curfontwidth, factor*fontheight, fgcolor, bgcolor,1);
+				PosX += curfontwidth;
+				return;
+			}
+		}
+	}
+	else if (Attribute->charset >= C_OFFSET_DRCS)
+	{
+
+		tstCachedPage *pcache = tuxtxt_cache.astCachetable[(Attribute->charset & 0x10) ? drcs : gdrcs][Attribute->charset & 0x0f];
+		if (pcache)
+		{
+			unsigned char drcs_data[23*40];
+			tuxtxt_decompress_page((Attribute->charset & 0x10) ? drcs : gdrcs,Attribute->charset & 0x0f,drcs_data);
+			unsigned char *p;
+			if (Char < 23*2)
+				p = drcs_data + 20*Char;
+			else if (pcache->pageinfo.p24)
+				p = pcache->pageinfo.p24 + 20*(Char - 23*2);
+			else
+			{
+				FillRect(PosX, PosY + yoffset, curfontwidth, factor*fontheight, bgcolor);
+				PosX += curfontwidth;
+				return;
+			}
+			axdrcs[12] = curfontwidth; /* adjust last x-offset according to position, FIXME: double width */
+			RenderDRCS(p,
+						  lfb + PosX*4 + (yoffset + PosY) * (720*4),
+						  axdrcs, fgcolor, bgcolor);
+		}
+		else
+		{
+			FillRect(PosX, PosY + yoffset, curfontwidth, factor*fontheight, bgcolor);
+		}
+		PosX += curfontwidth;
+		return;
+	}
+	else if (Attribute->charset == C_G2 && Char >= 0x20 && Char <= 0x7F)
+	{
+		if (national_subset_local == NAT_GR)
+			Char = G2table[2][Char-0x20];
+		else if (national_subset_local == NAT_RU)
+			Char = G2table[1][Char-0x20];
+		else
+			Char = G2table[0][Char-0x20];
+
+		if (Char == 0x7F)
+		{
+			FillRect(PosX, PosY + yoffset, curfontwidth, factor*ascender, fgcolor);
+			FillRect(PosX, PosY + yoffset + factor*ascender, curfontwidth, factor*(fontheight-ascender), bgcolor);
+			PosX += curfontwidth;
+			return;
+		}
+	}
+	else if (national_subset_local == NAT_GR && Char >= 0x40 && Char <= 0x7E)	/* remap complete areas for greek */
+		Char += 0x390 - 0x40;
+	else if (national_subset_local == NAT_GR && Char == 0x3c)
+		Char = '';
+	else if (national_subset_local == NAT_GR && Char == 0x3e)
+		Char = '';
+	else if (national_subset_local == NAT_GR && Char >= 0x23 && Char <= 0x24)
+		Char = nationaltable23[NAT_DE][Char-0x23]; /* #$ as in german option */
+	else if (national_subset_local == NAT_RU && Char >= 0x40 && Char <= 0x7E) /* remap complete areas for cyrillic */
+		Char = G0tablecyrillic[Char-0x20];
+	else
+	{
+		/* load char */
+		switch (Char)
+		{
+		case 0x00:
+		case 0x20:
+			FillRect(PosX, PosY + yoffset, curfontwidth, factor*fontheight, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0x23:
+		case 0x24:
+			Char = nationaltable23[national_subset_local][Char-0x23] & 0xFF;
+			break;
+		case 0x40:
+			Char = nationaltable40[national_subset_local] & 0xFF;
+			break;
+		case 0x5B:
+		case 0x5C:
+		case 0x5D:
+		case 0x5E:
+		case 0x5F:
+		case 0x60:
+			Char = nationaltable5b[national_subset_local][Char-0x5B] & 0xFF;
+			break;
+		case 0x7B:
+		case 0x7C:
+		case 0x7D:
+		case 0x7E:
+			Char = nationaltable7b[national_subset_local][Char-0x7B] & 0xFF;
+			break;
+		case 0x7F:
+			FillRect(PosX, PosY + yoffset, curfontwidth, factor*ascender, fgcolor);
+			FillRect(PosX, PosY + yoffset + factor*ascender, curfontwidth, factor*(fontheight-ascender), bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE0: /* |- */
+			DrawHLine(PosX, PosY + yoffset, curfontwidth, fgcolor);
+			DrawVLine(PosX, PosY + yoffset +1, fontheight -1, fgcolor);
+			FillRect(PosX +1, PosY + yoffset +1, curfontwidth-1, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE1: /* - */
+			DrawHLine(PosX, PosY + yoffset, curfontwidth, fgcolor);
+			FillRect(PosX, PosY + yoffset +1, curfontwidth, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE2: /* -| */
+			DrawHLine(PosX, PosY + yoffset, curfontwidth, fgcolor);
+			DrawVLine(PosX + curfontwidth -1, PosY + yoffset +1, fontheight -1, fgcolor);
+			FillRect(PosX, PosY + yoffset +1, curfontwidth-1, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE3: /* |  */
+			DrawVLine(PosX, PosY + yoffset, fontheight, fgcolor);
+			FillRect(PosX +1, PosY + yoffset, curfontwidth -1, fontheight, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE4: /*  | */
+			DrawVLine(PosX + curfontwidth -1, PosY + yoffset, fontheight, fgcolor);
+			FillRect(PosX, PosY + yoffset, curfontwidth -1, fontheight, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE5: /* |_ */
+			DrawHLine(PosX, PosY + yoffset + fontheight -1, curfontwidth, fgcolor);
+			DrawVLine(PosX, PosY + yoffset, fontheight -1, fgcolor);
+			FillRect(PosX +1, PosY + yoffset, curfontwidth-1, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE6: /* _ */
+			DrawHLine(PosX, PosY + yoffset + fontheight -1, curfontwidth, fgcolor);
+			FillRect(PosX, PosY + yoffset, curfontwidth, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE7: /* _| */
+			DrawHLine(PosX, PosY + yoffset + fontheight -1, curfontwidth, fgcolor);
+			DrawVLine(PosX + curfontwidth -1, PosY + yoffset, fontheight -1, fgcolor);
+			FillRect(PosX, PosY + yoffset, curfontwidth-1, fontheight-1, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE8: /* Ii */
+			FillRect(PosX +1, PosY + yoffset, curfontwidth -1, fontheight, bgcolor);
+			for (Row=0; Row < curfontwidth/2; Row++)
+				DrawVLine(PosX + Row, PosY + yoffset + Row, fontheight - Row, fgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xE9: /* II */
+			FillRect(PosX, PosY + yoffset, curfontwidth/2, fontheight, fgcolor);
+			FillRect(PosX + curfontwidth/2, PosY + yoffset, (curfontwidth+1)/2, fontheight, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xEA: /*   */
+			FillRect(PosX, PosY + yoffset, curfontwidth, fontheight, bgcolor);
+			FillRect(PosX, PosY + yoffset, curfontwidth/2, curfontwidth/2, fgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xEB: /*  */
+			FillRect(PosX, PosY + yoffset +1, curfontwidth, fontheight -1, bgcolor);
+			for (Row=0; Row < curfontwidth/2; Row++)
+				DrawHLine(PosX + Row, PosY + yoffset + Row, curfontwidth - Row, fgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xEC: /* -- */
+			FillRect(PosX, PosY + yoffset, curfontwidth, curfontwidth/2, fgcolor);
+			FillRect(PosX, PosY + yoffset + curfontwidth/2, curfontwidth, fontheight - curfontwidth/2, bgcolor);
+			PosX += curfontwidth;
+			return;
+		case 0xED:
+		case 0xEE:
+		case 0xEF:
+		case 0xF0:
+		case 0xF1:
+		case 0xF2:
+		case 0xF3:
+		case 0xF4:
+		case 0xF5:
+		case 0xF6:
+			Char = arrowtable[Char - 0xED];
+			break;
+		default:
+			break;
+		}
+	}
+	if (Char <= 0x20)
+	{
+#if TUXTXT_DEBUG
+		printf("TuxTxt found control char: %x \"%c\" \n", Char, Char);
+#endif
+		FillRect(PosX, PosY + yoffset, curfontwidth, factor*fontheight, bgcolor);
+		PosX += curfontwidth;
+		return;
+	}
+
+
+	if (!(glyph = FT_Get_Char_Index(face, Char)))
+	{
+		debugf(1, "TuxTxt <FT_Get_Char_Index for Char %d %x \"%c\" failed\n", Char, Char, Char & 0xFF );
+
+		FillRect(PosX, PosY + yoffset, curfontwidth, factor*fontheight, bgcolor);
+		PosX += curfontwidth;
+		return;
+	}
+
+	if ((error = FTC_SBitCache_Lookup(cache, &typettf, glyph, &sbit, NULL)) != 0)
+
+	{
+		debugf(1, "TuxTxt <FTC_SBitCache_Lookup: 0x%x> c%x a%x g%x w%d h%d x%d y%d\n",
+				 error, Char, Attribute, glyph, curfontwidth, fontheight, PosX, PosY);
+
+		FillRect(PosX, PosY + yoffset, curfontwidth, fontheight, bgcolor);
+		PosX += curfontwidth;
+		return;
+	}
+
+	/* render char */
+	sbitbuffer = sbit->buffer;
+	unsigned char localbuffer[1000]; // should be enough to store one character-bitmap...
+	// add diacritical marks
+	if (Attribute->diacrit)
+	{
+		FTC_SBit        sbit_diacrit;
+
+		if (national_subset_local == NAT_GR)
+			Char = G2table[2][0x20+ Attribute->diacrit];
+		else if (national_subset_local == NAT_RU)
+			Char = G2table[1][0x20+ Attribute->diacrit];
+		else
+			Char = G2table[0][0x20+ Attribute->diacrit];
+		if ((glyph = FT_Get_Char_Index(face, Char)))
+		{
+			if ((error = FTC_SBitCache_Lookup(cache, &typettf, glyph, &sbit_diacrit, NULL)) == 0)
+
+			{
+					sbitbuffer = localbuffer;
+					memcpy(sbitbuffer,sbit->buffer,sbit->pitch*sbit->height);
+
+					for (Row = 0; Row < sbit->height; Row++)
+					{
+						for (Pitch = 0; Pitch < sbit->pitch; Pitch++)
+						{
+							if (sbit_diacrit->pitch > Pitch && sbit_diacrit->height > Row)
+								sbitbuffer[Row*sbit->pitch+Pitch] |= sbit_diacrit->buffer[Row*sbit->pitch+Pitch];
+						}
+					}
+				}
+			}
+		}
+
+		unsigned char *p;
+		int f; /* running counter for zoom factor */
+
+		Row = factor * (ascender - sbit->top + TTFShiftY);
+		FillRect(PosX, PosY + yoffset, curfontwidth, Row, bgcolor); /* fill upper margin */
+
+		if (ascender - sbit->top + TTFShiftY + sbit->height > fontheight)
+			sbit->height = fontheight - ascender + sbit->top - TTFShiftY; /* limit char height to defined/calculated fontheight */
+
+
+//debugf(1, "PosX = %d, yoffset = %d, PosY %d, Row %d\n", PosX, yoffset, PosY, Row);
+
+
+		p = lfb + PosX*4 + (yoffset + PosY + Row) * (720*4); /* running pointer into framebuffer */
+
+		int saveRow = Row;
+		for (Row = sbit->height; Row; Row--) /* row counts up, but down may be a little faster :) */
+		{
+			int pixtodo = (usettf ? sbit->width : curfontwidth);
+			unsigned char *pstart = p;
+			int x = PosX;
+
+			for (Bit = xfactor * (sbit->left + TTFShiftX); Bit > 0; Bit--) /* fill left margin */
+			{
+				for (f = factor-1; f >= 0; f--)
+					setPixel(x, saveRow + f + yoffset + PosY + ((sbit->height - Row) * factor), bgcolor);
+					//memcpy((p + f*(720*4)),bgra[bgcolor],4);/*bgcolor*/
+				p += 4;
+				x += 1;
+				if (!usettf)
+					pixtodo--;
+			}
+
+			for (Pitch = sbit->pitch; Pitch; Pitch--)
+			{
+				for (Bit = 0x80; Bit; Bit >>= 1)
+				{
+					int color;
+
+					if (--pixtodo < 0)
+						break;
+
+					if (*sbitbuffer & Bit) /* bit set -> foreground */
+						color = fgcolor;
+					else /* bit not set -> background */
+						color = bgcolor;
+
+					for (f = factor-1; f >= 0; f--)
+						setPixel(x, saveRow + f + yoffset + PosY + ((sbit->height - Row) * factor), color);
+						//memcpy((p + f*(720*4)),bgra[color],4);
+					p+=4;
+					x+=1;
+					if (xfactor > 1) /* double width */
+					{
+						for (f = factor-1; f >= 0; f--)
+							setPixel(x, saveRow + f + yoffset + PosY + ((sbit->height - Row) * factor), color);
+							//memcpy((p + f*(720*4)),bgra[color],4);
+						p+=4;
+						x+=1;
+
+						if (!usettf)
+							pixtodo--;
+					}
+				}
+				sbitbuffer++;
+			}
+			for (Bit = (usettf ? (curfontwidth - xfactor*(sbit->width + sbit->left + TTFShiftX)) : pixtodo);
+				  Bit > 0; Bit--) /* fill rest of char width */
+			{
+				for (f = factor-1; f >= 0; f--)
+					setPixel(x, saveRow + f + yoffset + PosY + ((sbit->height - Row) * factor), bgcolor);
+					//memcpy((p + f*(720*4)),bgra[bgcolor],4);
+				p+=4;
+				x+=1;
+			}
+			p = pstart + factor*(720*4);
+		}
+
+		Row = ascender - sbit->top + sbit->height + TTFShiftY;
+		FillRect(PosX, PosY + yoffset + Row*factor, curfontwidth, (fontheight - Row) * factor, bgcolor); /* fill lower margin */
+		if (Attribute->underline)
+			FillRect(PosX, PosY + yoffset + (fontheight-2)* factor, curfontwidth,2*factor, fgcolor); /* underline char */
+
+		PosX += curfontwidth;
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * RenderCharFB                                                               *
+ ******************************************************************************/
+
+void RenderCharFB(int Char, tstPageAttr *Attribute)
+{
+	debugf(20, "%s: >\n", __func__);
+	RenderChar(Char, Attribute, zoommode, 0);
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * RenderCharBB                                                               *
+ ******************************************************************************/
+
+void RenderCharBB(int Char, tstPageAttr *Attribute)
+{
+	debugf(20, "%s: >\n", __func__);
+
+	RenderChar(Char, Attribute, 0, 0);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * RenderCharLCD                                                             *
+ ******************************************************************************/
+
+void RenderCharLCD(int Digit, int XPos, int YPos)
+{
+	int x, y;
+
+	debugf(20, "%s: >\n", __func__);
+
+	/* render digit to lcd backbuffer */
+	for (y = 0; y < 15; y++)
+	{
+		for (x = 0; x < 10; x++)
+		{
+			if (lcd_digits[Digit*15*10 + x + y*10])
+				lcd_backbuffer[XPos + x + ((YPos+y)/8)*120] |= 1 << ((YPos+y)%8);
+			else
+				lcd_backbuffer[XPos + x + ((YPos+y)/8)*120] &= ~(1 << ((YPos+y)%8));
+		}
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+#if 0
+void RenderCharLCDsmall(int Char, int XPos, int YPos)
+{
+	int old_width = fontwidth;
+	int old_height = fontheight;
+	setfontwidth(fontwidth_small_lcd);
+	typettf.font.pix_height = fontheight = fontwidth_small_lcd;
+	RenderChar(Char, 0, 0, -(YPos<<8 | XPos));
+	setfontwidth(old_width);
+	typettf.font.pix_height = fontheight = old_height;
+}
+#endif
+
+/******************************************************************************
+ * RenderMessage                                                              *
+ ******************************************************************************/
+
+void RenderMessage(int Message)
+{
+	int byte;
+	int fbcolor, timecolor, menuatr;
+	int pagecolumn;
+	const char *msg;
+
+
+	debugf(20, "%s: >\n", __func__);
+
+/*                     00000000001111111111222222222233333333334 */
+/*                     01234567890123456789012345678901234567890 */
+	char message_1[] = " www.tuxtxt.com x.xx ";
+	char message_2[] = "                                   ";
+/* 	char message_3[] = "   suche nach Teletext-Anbietern   "; */
+	char message_4[] = "                                   ";
+	char message_5[] = "";
+	char message_6[] = "";
+
+/* 	char message_7[] = " kein Teletext auf dem Transponder "; */
+/* 	char message_8[] = "  warte auf Empfang von Seite 100  "; */
+/* 	char message_9[] = "     Seite 100 existiert nicht!    "; */
+
+	memcpy(&message_1[24], versioninfo, 4);
+	/* reset zoom */
+	zoommode = 0;
+
+	/* set colors */
+#ifndef HAVE_DREAMBOX_HARDWARE
+	if (screenmode)
+	{
+		fbcolor   = black;
+		timecolor = black<<4 | black;
+		menuatr = ATR_MSGDRM0;
+	}
+	else
+#endif
+	{
+		fbcolor   = transp;
+		timecolor = transp<<4 | transp;
+		menuatr = ATR_MSG0;
+	}
+
+	/* clear framebuffer */
+	ClearFB(fbcolor);
+
+	/* hide header */
+	page_atrb[32].fg = transp;
+	page_atrb[32].bg = transp;
+
+
+	/* set pagenumber */
+	if (Message == ShowServiceName)
+	{
+		pagecolumn = message8pagecolumn[menulanguage];
+		msg = message_8[menulanguage];
+		memcpy(&message_4, msg, sizeof(message_4));
+		hex2str(message_4+pagecolumn, tuxtxt_cache.page);
+
+		if (SDT_ready)
+			memcpy(&message_2[2 + (35 - pid_table[current_service].service_name_len)/2],
+					 &pid_table[current_service].service_name, pid_table[current_service].service_name_len);
+		else if (Message == ShowServiceName)
+			hex2str(&message_2[17+3], tuxtxt_cache.vtxtpid);
+
+		msg = &message_3_blank[0];
+	}
+	else if (Message == NoServicesFound)
+		msg = &message_7[menulanguage][0];
+	else
+		msg = &message_3[menulanguage][0];
+
+	/* render infobar */
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*16;
+	for (byte = 0; byte < 37; byte++)
+		RenderCharFB(message_1[byte], &atrtable[menuatr + ((byte >= 9 && byte <= 27) ? 1 : 0)]);
+	RenderCharFB(message_1[37], &atrtable[menuatr + 2]);
+
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*17;
+	RenderCharFB(message_2[0], &atrtable[menuatr + 0]);
+	for (byte = 1; byte < 36; byte++)
+		RenderCharFB(message_2[byte], &atrtable[menuatr + 3]);
+	RenderCharFB(message_2[36], &atrtable[menuatr + 0]);
+	RenderCharFB(message_2[37], &atrtable[menuatr + 2]);
+
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*18;
+	RenderCharFB(msg[0], &atrtable[menuatr + 0]);
+	for (byte = 1; byte < 36; byte++)
+		RenderCharFB(msg[byte], &atrtable[menuatr + 3]);
+	RenderCharFB(msg[36], &atrtable[menuatr + 0]);
+	RenderCharFB(msg[37], &atrtable[menuatr + 2]);
+
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*19;
+	RenderCharFB(message_4[0], &atrtable[menuatr + 0]);
+	for (byte = 1; byte < 36; byte++)
+		RenderCharFB(message_4[byte], &atrtable[menuatr + 3]);
+	RenderCharFB(message_4[36], &atrtable[menuatr + 0]);
+	RenderCharFB(message_4[37], &atrtable[menuatr + 2]);
+
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*20;
+	for (byte = 0; byte < 37; byte++)
+		RenderCharFB(message_5[byte], &atrtable[menuatr + 0]);
+	RenderCharFB(message_5[37], &atrtable[menuatr + 2]);
+
+	PosX = StartX + fontwidth+5;
+	PosY = StartY + fontheight*21;
+	for (byte = 0; byte < 38; byte++)
+		RenderCharFB(message_6[byte], &atrtable[menuatr + 2]);
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * RenderPage                                                                 *
+ ******************************************************************************/
+
+void DoFlashing(int startrow)
+{
+	int row, col;
+
+	debugf(20, "%s: >\n", __func__);
+
+	/* get national subset */
+	if (auto_national &&
+		 national_subset <= NAT_MAX_FROM_HEADER && /* not for GR/RU as long as line28 is not evaluated */
+		 pageinfo && pageinfo->nationalvalid) /* individual subset according to page header */
+	{
+		national_subset = countryconversiontable[pageinfo->national];
+	}
+	/* Flashing */
+	tstPageAttr flashattr;
+	char flashchar;
+	struct timeval tv;
+	gettimeofday(&tv,NULL);
+	long flashphase = (tv.tv_usec / 1000) % 1000;
+	int srow = startrow;
+	int erow = 24;
+	int factor=1;
+	switch (zoommode)
+	{
+		case 1: erow = 12; factor=2;break;
+		case 2: srow = 12; factor=2;break;
+	}
+	PosY = StartY + startrow*fontheight*factor;
+	for (row = srow; row < erow; row++)
+	{
+		int index = row * 40;
+		int dhset = 0;
+		int incflash = 3;
+		int decflash = 2;
+		PosX = StartX;
+		for (col = nofirst; col < 40; col++)
+		{
+			if (page_atrb[index + col].flashing && page_char[index + col] > 0x20 && page_char[index + col]!= 0xff )
+			{
+				SetPosX(col);
+				flashchar = page_char[index + col];
+				int doflash = 0;
+				memcpy(&flashattr,&page_atrb[index + col],sizeof(tstPageAttr));
+				switch (flashattr.flashing &0x1c) // Flash Rate
+				{
+					case 0x00 :	// 1 Hz
+						if (flashphase>500) doflash = 1;
+						break;
+					case 0x04 :	// 2 Hz  Phase 1
+						if (flashphase<250) doflash = 1;
+						break;
+					case 0x08 :	// 2 Hz  Phase 2
+						if (flashphase>=250 && flashphase<500) doflash = 1;
+						break;
+					case 0x0c :	// 2 Hz  Phase 3
+						if (flashphase>=500 && flashphase<750) doflash = 1;
+						break;
+					case 0x10 :	// incremental flash
+						incflash++;
+						if (incflash>3) incflash = 1;
+						switch (incflash)
+						{
+							case 1: if (flashphase<250) doflash = 1; break;
+							case 2: if (flashphase>=250 && flashphase<500) doflash = 1;break;
+							case 3: if (flashphase>=500 && flashphase<750) doflash = 1;
+						}
+						break;
+					case 0x11 :	// decremental flash
+						decflash--;
+						if (decflash<1) decflash = 3;
+						switch (decflash)
+						{
+							case 1: if (flashphase<250) doflash = 1; break;
+							case 2: if (flashphase>=250 && flashphase<500) doflash = 1;break;
+							case 3: if (flashphase>=500 && flashphase<750) doflash = 1;
+						}
+						break;
+
+				}
+
+				switch (flashattr.flashing &0x03) // Flash Mode
+				{
+					case 0x01 :	// normal Flashing
+						if (doflash) flashattr.fg = flashattr.bg;
+						break;
+					case 0x02 :	// inverted Flashing
+						doflash = 1-doflash;
+						if (doflash) flashattr.fg = flashattr.bg;
+						break;
+					case 0x03 :	// color Flashing
+						if (doflash) flashattr.fg = flashattr.fg + (flashattr.fg > 7 ? (-8) : 8);
+						break;
+
+				}
+				RenderCharFB(flashchar,&flashattr);
+				if (flashattr.doublew) col++;
+				if (flashattr.doubleh) dhset = 1;
+			}
+		}
+		if (dhset)
+		{
+			row++;
+			PosY += fontheight*factor;
+		}
+		PosY += fontheight*factor;
+	}
+
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void RenderPage()
+{
+	int row, col, byte, startrow = 0;;
+	int national_subset_bak = national_subset;
+
+	debugf(20, "%s: >\n", __func__);
+
+	/* update lcd */
+	//UpdateLCD();
+
+	if (transpmode != 2 && delaystarted)
+	{
+	    struct timeval tv;
+    	    gettimeofday(&tv,NULL);
+	    if (tv.tv_sec - tv_delay.tv_sec < subtitledelay)
+		return;
+	}
+	
+	/* update page or timestring */
+	if (transpmode != 2 && tuxtxt_cache.pageupdate && tuxtxt_cache.page_receiving != tuxtxt_cache.page && inputcounter == 2)
+	{
+	    if (boxed && subtitledelay) 
+	    {
+		if (!delaystarted)
+		{
+		    gettimeofday(&tv_delay,NULL);
+		    delaystarted = 1;
+		    return;
+		}
+		else
+		    delaystarted = 0;
+
+	    }
+		/* reset update flag */
+		tuxtxt_cache.pageupdate = 0;
+
+
+		/* decode page */
+		if (tuxtxt_cache.subpagetable[tuxtxt_cache.page] != 0xFF)
+			DecodePage();
+		else
+			startrow = 1;
+
+		if (boxed)
+		{ 
+			if (screenmode != 0) 
+				SwitchScreenMode(0); /* turn off divided screen */
+		}
+		else 
+		{ 
+			if (screenmode != prevscreenmode && !transpmode) 
+				SwitchScreenMode(prevscreenmode);
+		}
+ 		/* display first column?  */
+		nofirst = show39;
+		for (row = 1; row < 24; row++)
+		{
+			byte = page_char[row*40];
+			if (byte != ' '  && byte != 0x00 && byte != 0xFF &&
+				 page_atrb[row*40].fg != page_atrb[row*40].bg)
+			{
+				nofirst = 0;
+				break;
+			}
+		}
+
+		fontwidth_normal = (ex-sx) / (40-nofirst);
+		setfontwidth(fontwidth_normal);
+		fontwidth_topmenumain = (TV43STARTX-sx) / (40-nofirst);
+		fontwidth_topmenusmall = (ex- TOPMENUSTARTX) / TOPMENUCHARS;
+		fontwidth_small = (TV169FULLSTARTX-sx)  / (40-nofirst);
+
+		switch(screenmode)
+		{
+			case 0:	setfontwidth(fontwidth_normal)     ; displaywidth= (ex             -sx);break;
+			case 1:  setfontwidth(fontwidth_topmenumain); displaywidth= (TV43STARTX     -sx);break;
+			case 2:  setfontwidth(fontwidth_small)      ; displaywidth= (TV169FULLSTARTX-sx);break;
+		}
+		if (transpmode || (boxed && !screenmode))
+		{
+			FillBorder(transp);//ClearBB(transp);
+#ifndef HAVE_DREAMBOX_HARDWARE
+			clearbbcolor = black;
+#else
+			clearbbcolor = transp;
+#endif
+		}
+		/* get national subset */
+		if (auto_national &&
+			 national_subset <= NAT_MAX_FROM_HEADER && /* not for GR/RU as long as line28 is not evaluated */
+			 pageinfo && pageinfo->nationalvalid) /* individual subset according to page header */
+		{
+			national_subset = countryconversiontable[pageinfo->national];
+		}
+
+		/* render page */
+		PosY = StartY + startrow*fontheight;
+		for (row = startrow; row < 24; row++)
+		{
+			int index = row * 40;
+
+			PosX = StartX;
+			for (col = nofirst; col < 40; col++)
+			{
+				RenderCharBB(page_char[index + col], &page_atrb[index + col]);
+
+				if (page_atrb[index + col].doubleh && page_char[index + col] != 0xff)	/* disable lower char in case of doubleh setting in l25 objects */
+					page_char[index + col + 40] = 0xff;
+				if (page_atrb[index + col].doublew)	/* skip next column if double width */
+				{
+					col++;
+					if (page_atrb[index + col-1].doubleh && page_char[index + col] != 0xff)	/* disable lower char in case of doubleh setting in l25 objects */
+						page_char[index + col + 40] = 0xff;
+				}
+			}
+			PosY += fontheight;
+		}
+		DoFlashing(startrow);
+		national_subset = national_subset_bak;
+
+		/* update framebuffer */
+		CopyBB2FB();
+	}
+	else if (transpmode != 2)
+	{
+		if (zoommode != 2)
+		{
+			PosY = StartY;
+			if (tuxtxt_cache.subpagetable[tuxtxt_cache.page] == 0xff)
+			{
+				page_atrb[32].fg = yellow;
+				page_atrb[32].bg = menu1;
+				int showpage = tuxtxt_cache.page_receiving;
+				int showsubpage = tuxtxt_cache.subpagetable[showpage];
+				if (showsubpage!=0xff)
+				{
+
+					tstCachedPage *pCachedPage;
+					pCachedPage = tuxtxt_cache.astCachetable[showpage][showsubpage];
+					if (pCachedPage && tuxtxt_is_dec(showpage))
+					{
+						PosX = StartX;
+						if (inputcounter == 2)
+						{
+							if (tuxtxt_cache.bttok && !tuxtxt_cache.basictop[tuxtxt_cache.page]) /* page non-existent according to TOP (continue search anyway) */
+							{
+								page_atrb[0].fg = white;
+								page_atrb[0].bg = red;
+							}
+							else
+							{
+								page_atrb[0].fg = yellow;
+								page_atrb[0].bg = menu1;
+							}
+							hex2str((char*) page_char+3, tuxtxt_cache.page);
+							for (col = nofirst; col < 7; col++) // selected page
+							{
+								RenderCharFB(page_char[col], &page_atrb[0]);
+							}
+							RenderCharFB(page_char[col], &page_atrb[32]);
+						}
+						else
+							SetPosX(8);
+
+						memcpy(&page_char[8], pCachedPage->p0, 24); /* header line without timestring */
+						for (col = 0; col < 24; col++)
+						{
+							RenderCharFB(pCachedPage->p0[col], &page_atrb[32]);
+						}
+					}
+				}
+			}
+			/* update timestring */
+			SetPosX(32);
+			for (byte = 0; byte < 8; byte++)
+			{
+				if (!page_atrb[32+byte].flashing)
+					RenderCharFB(tuxtxt_cache.timestring[byte], &page_atrb[32]);
+				else
+				{
+					SetPosX(33+byte);
+					page_char[32+byte] = page_char[32+byte];
+				}
+
+
+			}
+		}
+		DoFlashing(startrow);
+		national_subset = national_subset_bak;
+	}
+	else if (transpmode == 2 && tuxtxt_cache.pageupdate == 2)
+	{
+#if TUXTXT_DEBUG
+		//printf("received Update flag for page %03x\n",tuxtxt_cache.page);
+#endif
+		// display pagenr. when page has been updated while in transparency mode
+		PosY = StartY;
+
+		char ns[3];
+		SetPosX(1);
+		hex2str(ns+2,tuxtxt_cache.page);
+
+		RenderCharFB(ns[0],&atrtable[ATR_WB]);
+		RenderCharFB(ns[1],&atrtable[ATR_WB]);
+		RenderCharFB(ns[2],&atrtable[ATR_WB]);
+
+		tuxtxt_cache.pageupdate=0;
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * CreateLine25                                                               *
+ ******************************************************************************/
+
+void showlink(int column, int linkpage)
+{
+	unsigned char *p, line[] = "   >???   ";
+	int oldfontwidth = fontwidth;
+	int yoffset;
+
+	debugf(20, "%s: >\n", __func__);
+
+	yoffset = 0;
+
+	int abx = ((displaywidth)%(40-nofirst) == 0 ? displaywidth+1 : (displaywidth)/(((displaywidth)%(40-nofirst)))+1);// distance between 'inserted' pixels
+	int width = displaywidth /4;
+
+	PosY = StartY + 24*fontheight;
+
+	if (boxed)
+	{
+		PosX = StartX + column*width;
+		//debugf(20, "%s: x=%d(%d) y=%d(%d|%d) w=%d(%d) h=%d\n", __func__, PosX, abx, PosY+yoffset, PosY, yoffset, displaywidth, width, fontheight);
+		FillRect(PosX, PosY+yoffset, width, fontheight, transp);
+		//debugf(20, "%s: < boxed\n", __func__);
+		return;
+	}
+
+	if (tuxtxt_cache.adip[linkpage][0])
+	{
+		PosX = StartX + column*width;
+		int l = strlen((char*) tuxtxt_cache.adip[linkpage]);
+
+		if (l > 9) /* smaller font, if no space for one half space at front and end */
+			setfontwidth(oldfontwidth * 10 / (l+1));
+		FillRect(PosX, PosY+yoffset, width+(displaywidth%4), fontheight, atrtable[ATR_L250 + column].bg);
+		PosX += ((width) - (l*fontwidth+l*fontwidth/abx))/2; /* center */
+		for (p = tuxtxt_cache.adip[linkpage]; *p; p++)
+			RenderCharBB(*p, &atrtable[ATR_L250 + column]);
+		setfontwidth(oldfontwidth);
+	}
+	else /* display number */
+	{
+		PosX = StartX + column*width;
+		FillRect(PosX, PosY+yoffset, displaywidth+sx-PosX, fontheight, atrtable[ATR_L250 + column].bg);
+		if (linkpage < tuxtxt_cache.page)
+		{
+			line[6] = '<';
+			hex2str((char*) line + 5, linkpage);
+		}
+		else
+			hex2str((char*) line + 6, linkpage);
+		for (p = line; p < line+9; p++)
+			RenderCharBB(*p, &atrtable[ATR_L250 + column]);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+void CreateLine25()
+{
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (!tuxtxt_cache.bttok)
+		/* btt completely received and not yet decoded */
+		tuxtxt_decode_btt();
+	if (tuxtxt_cache.maxadippg >= 0)
+		tuxtxt_decode_adip();
+
+	if (!showhex && showflof &&
+		 (tuxtxt_cache.flofpages[tuxtxt_cache.page][0] || tuxtxt_cache.flofpages[tuxtxt_cache.page][1] || tuxtxt_cache.flofpages[tuxtxt_cache.page][2] || tuxtxt_cache.flofpages[tuxtxt_cache.page][3])) // FLOF-Navigation present
+	{
+		int i;
+
+		prev_100 = tuxtxt_cache.flofpages[tuxtxt_cache.page][0];
+		prev_10  = tuxtxt_cache.flofpages[tuxtxt_cache.page][1];
+		next_10  = tuxtxt_cache.flofpages[tuxtxt_cache.page][2];
+		next_100 = tuxtxt_cache.flofpages[tuxtxt_cache.page][3];
+
+		PosY = StartY + 24*fontheight;
+		PosX = StartX;
+		for (i=nofirst; i<40; i++)
+			RenderCharBB(page_char[24*40 + i], &page_atrb[24*40 + i]);
+	}
+	else
+	{
+		/*  normal: blk-1, grp+1, grp+2, blk+1 */
+		/*  hex:    hex+1, blk-1, grp+1, blk+1 */
+		if (showhex)
+		{
+			/* arguments: startpage, up, findgroup */
+			prev_100 = tuxtxt_next_hex(tuxtxt_cache.page);
+			prev_10  = toptext_getnext(tuxtxt_cache.page, 0, 0);
+			next_10  = toptext_getnext(tuxtxt_cache.page, 1, 1);
+		}
+		else
+		{
+			prev_100 = toptext_getnext(tuxtxt_cache.page, 0, 0);
+			prev_10  = toptext_getnext(tuxtxt_cache.page, 1, 1);
+			next_10  = toptext_getnext(prev_10, 1, 1);
+		}
+		next_100 = toptext_getnext(next_10, 1, 0);
+		showlink(0, prev_100);
+		showlink(1, prev_10);
+		showlink(2, next_10);
+		showlink(3, next_100);
+	}
+
+	if (//tuxtxt_cache.bttok &&
+		 screenmode == 1) /* TOP-Info present, divided screen -> create TOP overview */
+	{
+		char line[TOPMENUCHARS];
+		int current;
+		int prev10done, next10done, next100done, indent;
+		tstPageAttr *attrcol, *attr; /* color attribute for navigation keys and text */
+
+		int olddisplaywidth = displaywidth;
+		displaywidth = 1000*(40-nofirst); // disable pixelinsert;
+		setfontwidth(fontwidth_topmenusmall);
+
+		PosY = TOPMENUSTARTY;
+		memset(line, ' ', TOPMENUCHARS); /* init with spaces */
+
+		memcpy(line+TOPMENUINDENTBLK, tuxtxt_cache.adip[prev_100], 12);
+		hex2str(&line[TOPMENUINDENTDEF+12+TOPMENUSPC+2], prev_100);
+		RenderClearMenuLineBB(line, &atrtable[ATR_L250], &atrtable[ATR_TOPMENU2]);
+
+/*  1: blk-1, grp-1, grp+1, blk+1 */
+/*  2: blk-1, grp+1, grp+2, blk+1 */
+#if (LINE25MODE == 1)
+		current = prev_10 - 1;
+#else
+		current = tuxtxt_cache.page - 1;
+#endif
+
+		prev10done = next10done = next100done = 0;
+		while (PosY <= (TOPMENUENDY-fontheight))
+		{
+			attr = 0;
+			attrcol = &atrtable[ATR_WB];
+			if (!next100done && (PosY > (TOPMENUENDY - 2*fontheight))) /* last line */
+			{
+				attrcol = &atrtable[ATR_L253];
+				current = next_100;
+			}
+			else if (!next10done && (PosY > (TOPMENUENDY - 3*fontheight))) /* line before */
+			{
+				attrcol = &atrtable[ATR_L252];
+				current = next_10;
+			}
+			else if (!prev10done && (PosY > (TOPMENUENDY - 4*fontheight))) /* line before */
+			{
+				attrcol = &atrtable[ATR_L251];
+				current = prev_10;
+			}
+			else do
+			{
+				tuxtxt_next_dec(&current);
+				if (current == prev_10)
+				{
+					attrcol = &atrtable[ATR_L251];
+					prev10done = 1;
+					break;
+				}
+				else if (current == next_10)
+				{
+					attrcol = &atrtable[ATR_L252];
+					next10done = 1;
+					break;
+				}
+				else if (current == next_100)
+				{
+					attrcol = &atrtable[ATR_L253];
+					next100done = 1;
+					break;
+				}
+				else if (current == tuxtxt_cache.page)
+				{
+					attr = &atrtable[ATR_TOPMENU0];
+					break;
+				}
+			} while (tuxtxt_cache.adip[current][0] == 0 && (tuxtxt_cache.basictop[current] < 2 || tuxtxt_cache.basictop[current] > 7));
+
+			if (!tuxtxt_cache.bttok || (tuxtxt_cache.basictop[current] >= 2 && tuxtxt_cache.basictop[current] <= 5)) /* block (also for FLOF) */
+			{
+				indent = TOPMENUINDENTBLK;
+				if (!attr)
+					attr = &atrtable[tuxtxt_cache.basictop[current] <=3 ? ATR_TOPMENU1 : ATR_TOPMENU2]; /* green for program block */
+			}
+			else if (tuxtxt_cache.basictop[current] >= 6 && tuxtxt_cache.basictop[current] <= 7) /* group */
+			{
+				indent = TOPMENUINDENTGRP;
+				if (!attr)
+					attr = &atrtable[ATR_TOPMENU3];
+			}
+			else
+			{
+				indent = TOPMENUINDENTDEF;
+				if (!attr)
+					attr = &atrtable[ATR_WB];
+			}
+			memcpy(line+indent, tuxtxt_cache.adip[current], 12);
+			hex2str(&line[TOPMENUINDENTDEF+12+TOPMENUSPC+2], current);
+			RenderClearMenuLineBB(line, attrcol, attr);
+		}
+		displaywidth = olddisplaywidth;
+		setfontwidth(fontwidth_topmenumain);
+	}
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * CopyBB2FB                                                                  *
+ ******************************************************************************/
+
+void CopyBB2FB()
+{
+	debugf(2, "%s: >\n", __func__);
+
+	/* line 25 */
+	if (!pagecatching)
+		CreateLine25();
+	/* copy backbuffer to framebuffer */
+	if (!zoommode)
+	{
+		if (clearbbcolor >= 0)
+		{
+			clearbbcolor = -1;
+		}
+		blit();
+
+		return;
+	}
+
+	blit();
+
+	debugf(2, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * UpdateLCD                                                                  *
+ ******************************************************************************/
+
+void UpdateLCD()
+{
+	static int init_lcd = 1, old_cached_pages = -1, old_page = -1, old_subpage = -1, old_subpage_max = -1, old_hintmode = -1;
+	int  x, y, subpage_max = 0, update_lcd = 0;
+
+	debugf(20, "%s: >\n", __func__);
+
+	if (lcd == -1) return; // for Dreamboxes without LCD-Display (5xxx)
+	/* init or update lcd */
+	if (init_lcd)
+	{
+		init_lcd = 0;
+
+		for (y = 0; y < 64; y++)
+		{
+			int lcdbase = (y/8)*120;
+			int lcdmask = 1 << (y%8);
+
+			for (x = 0; x < 120; )
+			{
+				int rommask;
+				int rombyte = lcd_layout[x/8 + y*120/8];
+
+				for (rommask = 0x80; rommask; rommask >>= 1)
+				{
+					if (rombyte & rommask)
+						lcd_backbuffer[x + lcdbase] |= lcdmask;
+					else
+						lcd_backbuffer[x + lcdbase] &= ~lcdmask;
+					x++;
+				}
+			}
+		}
+
+		write(lcd, &lcd_backbuffer, sizeof(lcd_backbuffer));
+
+		for (y = 16; y < 56; y += 8)	/* clear rectangle in backbuffer */
+			for (x = 1; x < 118; x++)
+				lcd_backbuffer[x + (y/8)*120] = 0;
+
+		for (x = 3; x <= 116; x++)
+			lcd_backbuffer[x + (39/8)*120] |= 1 << (39%8);
+
+		for (y = 42; y <= 60; y++)
+			lcd_backbuffer[35 + (y/8)*120] |= 1 << (y%8);
+
+		for (y = 42; y <= 60; y++)
+			lcd_backbuffer[60 + (y/8)*120] |= 1 << (y%8);
+
+		RenderCharLCD(10, 43, 20);
+		RenderCharLCD(11, 79, 20);
+
+		return;
+	}
+	else
+	{
+		int p;
+
+		if (inputcounter == 2)
+			p = tuxtxt_cache.page;
+		else
+			p = temp_page + (0xDD >> 4*(1-inputcounter)); /* partial pageinput (filled with spaces) */
+
+		/* page */
+		if (old_page != p)
+		{
+			RenderCharLCD(p>>8,  7, 20);
+			RenderCharLCD((p&0x0F0)>>4, 19, 20);
+			RenderCharLCD(p&0x00F, 31, 20);
+
+			old_page = p;
+			update_lcd = 1;
+		}
+
+		/* current subpage */
+		if (old_subpage != tuxtxt_cache.subpage)
+		{
+			if (!tuxtxt_cache.subpage)
+			{
+				RenderCharLCD(0, 55, 20);
+				RenderCharLCD(1, 67, 20);
+			}
+			else
+			{
+				if (tuxtxt_cache.subpage >= 0xFF)
+					tuxtxt_cache.subpage = 1;
+				else if (tuxtxt_cache.subpage > 99)
+					tuxtxt_cache.subpage = 0;
+
+				RenderCharLCD(tuxtxt_cache.subpage>>4, 55, 20);
+				RenderCharLCD(tuxtxt_cache.subpage&0x0F, 67, 20);
+			}
+
+			old_subpage = tuxtxt_cache.subpage;
+			update_lcd = 1;
+		}
+
+		/* max subpage */
+		for (x = 0; x <= 0x79; x++)
+		{
+			if (tuxtxt_cache.astCachetable[tuxtxt_cache.page][x])
+				subpage_max = x;
+		}
+
+		if (old_subpage_max != subpage_max)
+		{
+			if (!subpage_max)
+			{
+				RenderCharLCD(0,  91, 20);
+				RenderCharLCD(1, 103, 20);
+			}
+			else
+			{
+				RenderCharLCD(subpage_max>>4,  91, 20);
+				RenderCharLCD(subpage_max&0x0F, 103, 20);
+			}
+
+			old_subpage_max = subpage_max;
+			update_lcd = 1;
+		}
+
+		/* cachestatus */
+		if (old_cached_pages != tuxtxt_cache.cached_pages)
+		{
+			#if 0
+			int s;
+			int p = tuxtxt_cache.cached_pages;
+			for (s=107; s >= 107-4*fontwidth_small_lcd; s -= fontwidth_small_lcd)
+			{
+				int c = p % 10;
+				if (p)
+					RenderCharLCDsmall('0'+c, s, 44);
+				else
+					RenderCharLCDsmall(' ', s, 44);
+				p /= 10;
+			}
+			#else
+			RenderCharLCD(tuxtxt_cache.cached_pages/1000, 67, 44);
+			RenderCharLCD(tuxtxt_cache.cached_pages%1000/100, 79, 44);
+			RenderCharLCD(tuxtxt_cache.cached_pages%100/10, 91, 44);
+			RenderCharLCD(tuxtxt_cache.cached_pages%10, 103, 44);
+			#endif
+
+			old_cached_pages = tuxtxt_cache.cached_pages;
+			update_lcd = 1;
+		}
+
+		/* mode */
+		if (old_hintmode != hintmode)
+		{
+			if (hintmode)
+				RenderCharLCD(12, 43, 44);
+			else
+				RenderCharLCD(13, 43, 44);
+
+			old_hintmode = hintmode;
+			update_lcd = 1;
+		}
+	}
+
+	if (update_lcd)
+		write(lcd, &lcd_backbuffer, sizeof(lcd_backbuffer));
+
+	debugf(20, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * DecodePage                                                                 *
+ ******************************************************************************/
+
+void DecodePage()
+{
+	int row, col;
+	int hold, dhset;
+	int foreground, background, doubleheight, doublewidth, charset, mosaictype, IgnoreAtBlackBgSubst, concealed, flashmode, boxwin;
+	unsigned char held_mosaic, *p;
+	tstCachedPage *pCachedPage;
+
+	debugf(2, "%s: >\n", __func__);
+
+	/* copy page to decode buffer */
+	if (tuxtxt_cache.subpagetable[tuxtxt_cache.page] == 0xff) /* not cached: do nothing */
+		return;
+	if (tuxtxt_cache.zap_subpage_manual)
+		pCachedPage = tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpage];
+	else
+		pCachedPage = tuxtxt_cache.astCachetable[tuxtxt_cache.page][tuxtxt_cache.subpagetable[tuxtxt_cache.page]];
+	if (!pCachedPage)	/* not cached: do nothing */
+		return;
+
+	tuxtxt_decompress_page(tuxtxt_cache.page,tuxtxt_cache.subpage,&page_char[40]);
+
+	memcpy(&page_char[8], pCachedPage->p0, 24); /* header line without timestring */
+
+	pageinfo = &(pCachedPage->pageinfo);
+	if (pageinfo->p24)
+		memcpy(&page_char[24*40], pageinfo->p24, 40); /* line 25 for FLOF */
+
+	/* copy timestring */
+	memcpy(&page_char[32], &tuxtxt_cache.timestring, 8);
+
+	/* check for newsflash & subtitle */
+	if (pageinfo->boxed && tuxtxt_is_dec(tuxtxt_cache.page))
+		boxed = 1;
+	else
+		boxed = 0;
+
+
+	/* modify header */
+	if (boxed)
+		memset(&page_char, ' ', 40);
+	else
+	{
+		memset(page_char, ' ', 8);
+		hex2str((char*) page_char+3, tuxtxt_cache.page);
+		if (tuxtxt_cache.subpage)
+		{
+			*(page_char+4) ='/';
+			*(page_char+5) ='0';
+			hex2str((char*) page_char+6, tuxtxt_cache.subpage);
+		}
+
+	}
+
+	if (!tuxtxt_is_dec(tuxtxt_cache.page))
+	{
+		if (pageinfo->function == FUNC_MOT) /* magazine organization table */
+		{
+#if TUXTXT_DEBUG
+			printf("TuxTxt <decoding MOT %03x/%02x %d>\n", tuxtxt_cache.page, tuxtxt_cache.subpage, pageinfo->function);
+#endif
+			ClearBB(black);
+			for (col = 0; col < 24*40; col++)
+				page_atrb[col] = atrtable[ATR_WB];
+			for (col = 40; col < 24*40; col++)
+				page_char[col] = number2char(page_char[col]);
+			boxed = 0;
+			return ; /* don't interpret irregular pages */
+		}
+		else if (pageinfo->function == FUNC_GPOP || pageinfo->function == FUNC_POP) /* object definitions */
+		{
+#if TUXTXT_DEBUG
+			printf("TuxTxt <decoding *POP %03x/%02x %d>\n", tuxtxt_cache.page, tuxtxt_cache.subpage, pageinfo->function);
+#endif
+			ClearBB(black);
+			for (col = 0; col < 24*40; col++)
+				page_atrb[col] = atrtable[ATR_WB];
+			p = page_char + 40;
+			for (row = 1; row < 12; row++)
+			{
+				*p++ = number2char(row); /* first column: number (0-9, A-..) */
+				for (col = 1; col < 40; col += 3)
+				{
+					int d = deh24(p);
+					if (d < 0)
+					{
+						memcpy(p, "???", 3);
+					p += 3;
+					}
+					else
+					{
+						*p++ = number2char((d >> 6) & 0x1f); /* mode */
+						*p++ = number2char(d & 0x3f); /* address */
+						*p++ = number2char((d >> 11) & 0x7f); /* data */
+					}
+				}
+			}
+			boxed = 0;
+			return ; /* don't interpret irregular pages */
+		}
+		else if (pageinfo->function == FUNC_GDRCS || pageinfo->function == FUNC_DRCS) /* character definitions */
+		{
+			#define DRCSROWS 8
+			#define DRCSCOLS (48/DRCSROWS)
+			#define DRCSZOOMX 3
+			#define DRCSZOOMY 5
+			#define DRCSXSPC (12*DRCSZOOMX + 2)
+			#define DRCSYSPC (10*DRCSZOOMY + 2)
+
+			unsigned char ax[] = { /* array[0..12] of x-offsets, array[0..10] of y-offsets for each pixel */
+				DRCSZOOMX * 0,
+				DRCSZOOMX * 1,
+				DRCSZOOMX * 2,
+				DRCSZOOMX * 3,
+				DRCSZOOMX * 4,
+				DRCSZOOMX * 5,
+				DRCSZOOMX * 6,
+				DRCSZOOMX * 7,
+				DRCSZOOMX * 8,
+				DRCSZOOMX * 9,
+				DRCSZOOMX * 10,
+				DRCSZOOMX * 11,
+				DRCSZOOMX * 12,
+				DRCSZOOMY * 0,
+				DRCSZOOMY * 1,
+				DRCSZOOMY * 2,
+				DRCSZOOMY * 3,
+				DRCSZOOMY * 4,
+				DRCSZOOMY * 5,
+				DRCSZOOMY * 6,
+				DRCSZOOMY * 7,
+				DRCSZOOMY * 8,
+				DRCSZOOMY * 9,
+				DRCSZOOMY * 10
+			};
+#if TUXTXT_DEBUG
+			printf("TuxTxt <decoding *DRCS %03x/%02x %d>\n", tuxtxt_cache.page, tuxtxt_cache.subpage, pageinfo->function);
+#endif
+			ClearBB(black);
+			for (col = 0; col < 24*40; col++)
+				page_atrb[col] = atrtable[ATR_WB];
+
+
+			for (row = 0; row < DRCSROWS; row++)
+				for (col = 0; col < DRCSCOLS; col++)
+					RenderDRCS(
+						page_char + 20 * (DRCSCOLS * row + col + 2),
+						lfb
+						+ (StartY + fontheight + DRCSYSPC * row + 576) * (720*4)
+						+ (StartX + DRCSXSPC * col)*4,
+						ax, white, black);
+
+			memset(page_char + 40, 0xff, 24*40); /* don't render any char below row 0 */
+			boxed = 0;
+			return ; /* don't interpret irregular pages */
+		}
+		else
+		{
+			int i;
+			int h, parityerror = 0;
+
+			for (i = 0; i < 8; i++)
+				page_atrb[i] = atrtable[ATR_WB];
+
+			/* decode parity/hamming */
+			for (i = 40; i < sizeof(page_char); i++)
+			{
+				page_atrb[i] = atrtable[ATR_WB];
+				p = page_char + i;
+				h = dehamming[*p];
+				if (parityerror && h != 0xFF)	/* if no regular page (after any parity error) */
+					hex2str((char*) p, h);	/* first try dehamming */
+				else
+				{
+					if (*p == ' ' || deparity[*p] != ' ') /* correct parity */
+						*p &= 127;
+					else
+					{
+						parityerror = 1;
+						if (h != 0xFF)	/* first parity error: try dehamming */
+							hex2str((char*) p, h);
+						else
+							*p = ' ';
+					}
+				}
+			}
+			if (parityerror)
+			{
+				boxed = 0;
+				return ; /* don't interpret irregular pages */
+			}
+		}
+	}
+#if TUXTXT_DEBUG
+  printf("decode\n");
+#endif
+	/* decode */
+	for (row = 0;
+		  row < ((showflof && pageinfo->p24) ? 25 : 24);
+		  row++)
+	{
+		/* start-of-row default conditions */
+		foreground   = white;
+		background   = black;
+		doubleheight = 0;
+		doublewidth  = 0;
+		charset      = C_G0P;
+		mosaictype   = 0;
+		concealed    = 0;
+		flashmode    = 0;
+		hold         = 0;
+		boxwin		 = 0;
+		held_mosaic  = ' ';
+		dhset        = 0;
+		IgnoreAtBlackBgSubst = 0;
+
+		if (boxed && memchr(&page_char[row*40], start_box, 40) == 0)
+		{
+			foreground = transp;
+			background = transp;
+		}
+
+		for (col = 0; col < 40; col++)
+		{
+			int index = row*40 + col;
+
+			page_atrb[index].fg = foreground;
+			page_atrb[index].bg = background;
+			page_atrb[index].charset = charset;
+			page_atrb[index].doubleh = doubleheight;
+			page_atrb[index].doublew = (col < 39 ? doublewidth : 0);
+			page_atrb[index].IgnoreAtBlackBgSubst = IgnoreAtBlackBgSubst;
+			page_atrb[index].concealed = concealed;
+			page_atrb[index].flashing  = flashmode;
+			page_atrb[index].boxwin    = boxwin;
+			page_atrb[index].inverted  = 0; // only relevant for Level 2.5
+			page_atrb[index].underline = 0; // only relevant for Level 2.5
+			page_atrb[index].diacrit   = 0; // only relevant for Level 2.5
+			page_atrb[index].setX26    = 0; // only relevant for Level 2.5
+			page_atrb[index].setG0G2   = 0x3f; // only relevant for Level 2.5
+
+			if (page_char[index] < ' ')
+			{
+				switch (page_char[index])
+				{
+				case alpha_black:
+				case alpha_red:
+				case alpha_green:
+				case alpha_yellow:
+				case alpha_blue:
+				case alpha_magenta:
+				case alpha_cyan:
+				case alpha_white:
+					concealed = 0;
+					foreground = page_char[index] - alpha_black + black;
+					if (col == 0 && page_char[index] == alpha_white)
+						page_atrb[index].fg = black; // indicate level 1 color change on column 0; (hack)
+					charset = C_G0P;
+					break;
+
+				case flash:
+					flashmode = 1;
+					break;
+				case steady:
+					flashmode = 0;
+					page_atrb[index].flashing = 0;
+					break;
+				case end_box:
+					boxwin = 0;
+					IgnoreAtBlackBgSubst = 0;
+/*					if (boxed)
+					{
+						foreground = transp;
+						background = transp;
+						IgnoreAtBlackBgSubst = 0;
+					}
+*/
+					break;
+
+				case start_box:
+					if (!boxwin)
+					{
+						boxwin = 1;
+						//background = 0x08;
+					}
+/*					if (boxed)
+					{
+						int rowstart = row * 40;
+						if (col > 0)
+							memset(&page_char[rowstart], ' ', col);
+						for (clear = 0; clear < col; clear++)
+						{
+							page_atrb[rowstart + clear].fg = page_atrb[rowstart + clear].bg = transp;
+							page_atrb[rowstart + clear].IgnoreAtBlackBgSubst = 0;
+						}
+					}
+*/
+					break;
+
+				case normal_size:
+					doubleheight = 0;
+					doublewidth = 0;
+					page_atrb[index].doubleh = doubleheight;
+					page_atrb[index].doublew = doublewidth;
+					break;
+
+				case double_height:
+					if (row < 23)
+					{
+						doubleheight = 1;
+						dhset = 1;
+					}
+					doublewidth = 0;
+
+					break;
+
+				case double_width:
+					if (col < 39)
+						doublewidth = 1;
+					doubleheight = 0;
+					break;
+
+				case double_size:
+					if (row < 23)
+					{
+						doubleheight = 1;
+						dhset = 1;
+					}
+					if (col < 39)
+						doublewidth = 1;
+					break;
+
+				case mosaic_black:
+				case mosaic_red:
+				case mosaic_green:
+				case mosaic_yellow:
+				case mosaic_blue:
+				case mosaic_magenta:
+				case mosaic_cyan:
+				case mosaic_white:
+					concealed = 0;
+					foreground = page_char[index] - mosaic_black + black;
+					charset = mosaictype ? C_G1S : C_G1C;
+					break;
+
+				case conceal:
+					page_atrb[index].concealed = 1;
+					concealed = 1;
+					if (!hintmode)
+					{
+						foreground = background;
+						page_atrb[index].fg = foreground;
+					}
+					break;
+
+				case contiguous_mosaic:
+					mosaictype = 0;
+					if (charset == C_G1S)
+					{
+						charset = C_G1C;
+						page_atrb[index].charset = charset;
+					}
+					break;
+
+				case separated_mosaic:
+					mosaictype = 1;
+					if (charset == C_G1C)
+					{
+						charset = C_G1S;
+						page_atrb[index].charset = charset;
+					}
+					break;
+
+				case esc:
+					if (charset == C_G0P)
+						charset = C_G0S;
+					else if (charset == C_G0S)
+						charset = C_G0P;
+					break;
+
+				case black_background:
+					background = black;
+					IgnoreAtBlackBgSubst = 0;
+					page_atrb[index].bg = background;
+					page_atrb[index].IgnoreAtBlackBgSubst = IgnoreAtBlackBgSubst;
+					break;
+
+				case new_background:
+					background = foreground;
+					if (background == black)
+						IgnoreAtBlackBgSubst = 1;
+					else
+						IgnoreAtBlackBgSubst = 0;
+					page_atrb[index].bg = background;
+					page_atrb[index].IgnoreAtBlackBgSubst = IgnoreAtBlackBgSubst;
+					break;
+
+				case hold_mosaic:
+					hold = 1;
+					break;
+
+				case release_mosaic:
+					hold = 2;
+					break;
+				}
+
+				/* handle spacing attributes */
+				if (hold && (page_atrb[index].charset == C_G1C || page_atrb[index].charset == C_G1S))
+					page_char[index] = held_mosaic;
+				else
+					page_char[index] = ' ';
+
+				if (hold == 2)
+					hold = 0;
+			}
+			else /* char >= ' ' */
+			{
+				/* set new held-mosaic char */
+				if ((charset == C_G1C || charset == C_G1S) &&
+					 ((page_char[index]&0xA0) == 0x20))
+					held_mosaic = page_char[index];
+				if (page_atrb[index].doubleh)
+					page_char[index + 40] = 0xFF;
+
+			}
+			if (!(charset == C_G1C || charset == C_G1S))
+				held_mosaic = ' '; /* forget if outside mosaic */
+
+		} /* for col */
+
+		/* skip row if doubleheight */
+		if (row < 23 && dhset)
+		{
+			for (col = 0; col < 40; col++)
+			{
+				int index = row*40 + col;
+				page_atrb[index+40].bg = page_atrb[index].bg;
+				page_atrb[index+40].fg = white;
+				if (!page_atrb[index].doubleh)
+					page_char[index+40] = ' ';
+				page_atrb[index+40].flashing = 0;
+				page_atrb[index+40].charset = C_G0P;
+				page_atrb[index+40].doubleh = 0;
+				page_atrb[index+40].doublew = 0;
+				page_atrb[index+40].IgnoreAtBlackBgSubst = 0;
+				page_atrb[index+40].concealed = 0;
+				page_atrb[index+40].flashing  = 0;
+				page_atrb[index+40].boxwin    = page_atrb[index].boxwin;
+			}
+			row++;
+		}
+	} /* for row */
+	FullScrColor = black;
+
+	if (showl25)
+		eval_l25();
+
+	/* handle Black Background Color Substitution and transparency (CLUT1#0) */
+	{
+		int r, c;
+		int o = 0;
+		char bitmask ;
+
+
+
+		for (r = 0; r < 25; r++)
+		{
+			for (c = 0; c < 40; c++)
+			{
+				bitmask = (page_atrb[o].bg == 0x08 ? 0x08 : 0x00) | (FullRowColor[r] == 0x08 ? 0x04 : 0x00) | (page_atrb[o].boxwin <<1) | boxed;
+				switch (bitmask)
+				{
+					case 0x08:
+					case 0x0b:
+						if (FullRowColor[r] == 0x08)
+							page_atrb[o].bg = FullScrColor;
+						else
+							page_atrb[o].bg = FullRowColor[r];
+						break;
+					case 0x01:
+					case 0x05:
+					case 0x09:
+					case 0x0a:
+					case 0x0c:
+					case 0x0d:
+					case 0x0e:
+					case 0x0f:
+						page_atrb[o].bg = transp;
+						break;
+				}
+				bitmask = (page_atrb[o].fg  == 0x08 ? 0x08 : 0x00) | (FullRowColor[r] == 0x08 ? 0x04 : 0x00) | (page_atrb[o].boxwin <<1) | boxed;
+				switch (bitmask)
+				{
+					case 0x08:
+					case 0x0b:
+						if (FullRowColor[r] == 0x08)
+							page_atrb[o].fg = FullScrColor;
+						else
+							page_atrb[o].fg = FullRowColor[r];
+						break;
+					case 0x01:
+					case 0x05:
+					case 0x09:
+					case 0x0a:
+					case 0x0c:
+					case 0x0d:
+					case 0x0e:
+					case 0x0f:
+						page_atrb[o].fg = transp;
+						break;
+				}
+				o++;
+			}
+		}
+	}
+	return ;
+
+	debugf(2, "%s: <\n", __func__);
+}
+
+/******************************************************************************
+ * GetRCCode                                                                  *
+ ******************************************************************************/
+
+#define vMENU 0x54
+#define vRED 0x6d
+#define vGREEN 0x6e
+#define vYELLOW 0x6f
+#define vBLUE 0x70
+#define vEXIT 0x55
+#define vTEXT 0x3c
+#define vEPG 0x4c
+#define vREWIND 0x21
+#define vFASTFORWARD 0x20
+#define vPLAY 0x38
+#define vPAUSE 0x39
+#define vRECORD 0x37
+#define vSTOP 0x31
+#define vSTANDBY 0x0c
+#define vMUTE 0x0d
+#define vCHANNELUP 0x1e
+#define vCHANNELDOWN 0x1f
+#define vVOLUMEUP 0x10
+#define vVOLUMEDOWN 0x11
+
+#define vINFO 0x0F
+#define vOK 0x5C
+#define vUP 0x58
+#define vRIGHT 0x5B
+#define vDOWN 0x59
+#define vLEFT 0x5A
+
+#define v0BUTTON 0x00
+#define v1BUTTON 0x01
+#define v2BUTTON 0x02
+#define v3BUTTON 0x03
+#define v4BUTTON 0x04
+#define v5BUTTON 0x05
+#define v6BUTTON 0x06
+#define v7BUTTON 0x07
+#define v8BUTTON 0x08
+#define v9BUTTON 0x09
+
+#define vFPVFORMATBUTTON 0x4A
+#define vFPMENUBUTTON 0x49
+#define vFPOPTIONBUTTON 0x47
+#define vFPEXITBUTTON 0x4B
+#define vFPPOWERBUTTON 0x48
+
+
+
+
+
+int my_atox (char * string)
+{
+    int val1, val2;
+    if(string[0]>=48&&string[0]<=57)
+        val1 = string[0]-48;
+    else if(string[0]>=65&&string[0]<=70)
+        val1 = string[0]-65+10;
+    else if(string[0]>=97&&string[0]<=102)
+        val1 = string[0]-97+10;
+    else
+        val1 = 32;
+	
+    if(string[1]>=48&&string[1]<=57)
+        val2 = string[1]-48;
+    else if(string[1]>=65&&string[1]<=70)
+        val2 = string[1]-65+10;
+    else if(string[1]>=97&&string[1]<=102)
+        val2 = string[1]-97+10;
+    else
+        val2 = 32;
+	
+    return(val1*16+val2);
+}
+
+int getKeyCompatibleCode(int code)
+{
+    switch (code)
+    {
+    case v1BUTTON: return KEY_1;
+    case v2BUTTON: return KEY_2;
+    case v3BUTTON: return KEY_3;
+    case v4BUTTON: return KEY_4;
+    case v5BUTTON: return KEY_5;
+    case v6BUTTON: return KEY_6;
+    case v7BUTTON: return KEY_7;
+    case v8BUTTON: return KEY_8;
+    case v9BUTTON: return KEY_9;
+    case v0BUTTON: return KEY_0;
+    case vVOLUMEUP: return KEY_VOLUMEUP;
+    case vVOLUMEDOWN: return KEY_VOLUMEDOWN;
+    case vMENU: return KEY_MENU;
+    case vYELLOW: return KEY_YELLOW;
+    case vGREEN: return KEY_GREEN;
+    case vRED: return KEY_RED;
+    case vBLUE: return KEY_BLUE;
+    case vEXIT: return KEY_HOME;
+    case vTEXT: return KEY_TEXT;
+    case vOK: return KEY_OK;
+    case vINFO: return KEY_HELP;
+    case vSTANDBY: return KEY_POWER;
+    case vUP: return KEY_UP;
+    case vDOWN: return KEY_DOWN;
+    case vLEFT: return KEY_LEFT;
+    case vRIGHT: return KEY_RIGHT;
+    case vEPG: return KEY_EPG;
+    case vREWIND: return KEY_REWIND;
+    case vFASTFORWARD: return KEY_FASTFORWARD;
+    case vPLAY: return KEY_PLAY;
+    case vPAUSE: return KEY_PAUSE;
+    case vRECORD: return KEY_RECORD;
+    case vSTOP: return KEY_STOP;
+
+    case vMUTE: return KEY_MUTE;
+    case vCHANNELUP: return KEY_PAGEUP;
+    case vCHANNELDOWN: return KEY_PAGEDOWN;
+
+    case vFPVFORMATBUTTON: return BTN_0;
+    case vFPMENUBUTTON: return BTN_1;
+    case vFPOPTIONBUTTON: return BTN_2;
+    case vFPEXITBUTTON: return BTN_3;
+    case vFPPOWERBUTTON: return BTN_4;
+
+    default:  return -1;
+    }
+}
+
+
+int GetRCCode()
+{
+    if (blocking == 1)
+    {
+       while(1)
+       {
+           /* block until rcThread says there is a new key */
+	   usleep(1000000/100);
+	   if (newKey == 1)
+	   {   
+	        newKey = 0;
+		return 1;
+  	   }
+       }
+    } else
+    {
+	/* return immediately with current status */
+        int tmp = newKey;
+	newKey = 0;
+	
+	usleep(1000000/100);
+	
+	return tmp;
+    }   
+
+    return 0;
+}
+/* Local Variables: */
+/* indent-tabs-mode:t */
+/* tab-width:3 */
+/* c-basic-offset:3 */
+/* comment-column:0 */
+/* fill-column:120 */
+/* End: */
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.cfg enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.cfg
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.cfg	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.cfg	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,8 @@
+type=2
+name=Teletext
+desc=Software Decoder
+needfb=1
+needlcd=1
+needrc=1
+needvtxtpid=1
+needoffsets=1
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_common.h enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_common.h
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_common.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_common.h	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,1816 @@
+#ifndef tuxtxt_common_123
+#define tuxtxt_common_123
+
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include "tuxtxt_def.h"
+#if TUXTXT_COMPRESS == 1
+#include <zlib.h>
+#endif
+
+
+/* shapes */
+enum
+{
+	S_END = 0,
+	S_FHL, /* full horizontal line: y-offset */
+	S_FVL, /* full vertical line: x-offset */
+	S_BOX, /* rectangle: x-offset, y-offset, width, height */
+	S_TRA, /* trapez: x0, y0, l0, x1, y1, l1 */
+	S_BTR, /* trapez in bgcolor: x0, y0, l0, x1, y1, l1 */
+	S_INV, /* invert */
+	S_LNK, /* call other shape: shapenumber */
+	S_CHR, /* Character from freetype hibyte, lowbyte */
+	S_ADT, /* Character 2F alternating raster */
+	S_FLH, /* flip horizontal */
+	S_FLV  /* flip vertical */
+};
+
+/* shape coordinates */
+enum
+{
+	S_W13 = 5, /* width*1/3 */
+	S_W12, /* width*1/2 */
+	S_W23, /* width*2/3 */
+	S_W11, /* width */
+	S_WM3, /* width-3 */
+	S_H13, /* height*1/3 */
+	S_H12, /* height*1/2 */
+	S_H23, /* height*2/3 */
+	S_H11, /* height */
+	S_NrShCoord
+};
+
+/* G3 characters */
+unsigned char aG3_20[] = { S_TRA, 0, S_H23, 1, 0, S_H11, S_W12, S_END };
+unsigned char aG3_21[] = { S_TRA, 0, S_H23, 1, 0, S_H11, S_W11, S_END };
+unsigned char aG3_22[] = { S_TRA, 0, S_H12, 1, 0, S_H11, S_W12, S_END };
+unsigned char aG3_23[] = { S_TRA, 0, S_H12, 1, 0, S_H11, S_W11, S_END };
+unsigned char aG3_24[] = { S_TRA, 0, 0, 1, 0, S_H11, S_W12, S_END };
+unsigned char aG3_25[] = { S_TRA, 0, 0, 1, 0, S_H11, S_W11, S_END };
+unsigned char aG3_26[] = { S_INV, S_LNK, 0x66, S_END };
+unsigned char aG3_27[] = { S_INV, S_LNK, 0x67, S_END };
+unsigned char aG3_28[] = { S_INV, S_LNK, 0x68, S_END };
+unsigned char aG3_29[] = { S_INV, S_LNK, 0x69, S_END };
+unsigned char aG3_2a[] = { S_INV, S_LNK, 0x6a, S_END };
+unsigned char aG3_2b[] = { S_INV, S_LNK, 0x6b, S_END };
+unsigned char aG3_2c[] = { S_INV, S_LNK, 0x6c, S_END };
+unsigned char aG3_2d[] = { S_INV, S_LNK, 0x6d, S_END };
+unsigned char aG3_2e[] = { S_BOX, 2, 0, 3, S_H11, S_END };
+unsigned char aG3_2f[] = { S_ADT };
+unsigned char aG3_30[] = { S_LNK, 0x20, S_FLH, S_END };
+unsigned char aG3_31[] = { S_LNK, 0x21, S_FLH, S_END };
+unsigned char aG3_32[] = { S_LNK, 0x22, S_FLH, S_END };
+unsigned char aG3_33[] = { S_LNK, 0x23, S_FLH, S_END };
+unsigned char aG3_34[] = { S_LNK, 0x24, S_FLH, S_END };
+unsigned char aG3_35[] = { S_LNK, 0x25, S_FLH, S_END };
+unsigned char aG3_36[] = { S_INV, S_LNK, 0x76, S_END };
+unsigned char aG3_37[] = { S_INV, S_LNK, 0x77, S_END };
+unsigned char aG3_38[] = { S_INV, S_LNK, 0x78, S_END };
+unsigned char aG3_39[] = { S_INV, S_LNK, 0x79, S_END };
+unsigned char aG3_3a[] = { S_INV, S_LNK, 0x7a, S_END };
+unsigned char aG3_3b[] = { S_INV, S_LNK, 0x7b, S_END };
+unsigned char aG3_3c[] = { S_INV, S_LNK, 0x7c, S_END };
+unsigned char aG3_3d[] = { S_INV, S_LNK, 0x7d, S_END };
+unsigned char aG3_3e[] = { S_LNK, 0x2e, S_FLH, S_END };
+unsigned char aG3_3f[] = { S_BOX, 0, 0, S_W11, S_H11, S_END };
+unsigned char aG3_40[] = { S_BOX, 0, S_H13, S_W11, S_H13, S_LNK, 0x7e, S_END };
+unsigned char aG3_41[] = { S_BOX, 0, S_H13, S_W11, S_H13, S_LNK, 0x7e, S_FLV, S_END };
+unsigned char aG3_42[] = { S_LNK, 0x50, S_BOX, S_W12, S_H13, S_W12, S_H13, S_END };
+unsigned char aG3_43[] = { S_LNK, 0x50, S_BOX, 0, S_H13, S_W12, S_H13, S_END };
+unsigned char aG3_44[] = { S_LNK, 0x48, S_FLV, S_LNK, 0x48, S_END };
+unsigned char aG3_45[] = { S_LNK, 0x44, S_FLH, S_END };
+unsigned char aG3_46[] = { S_LNK, 0x47, S_FLV, S_END };
+unsigned char aG3_47[] = { S_LNK, 0x48, S_FLH, S_LNK, 0x48, S_END };
+unsigned char aG3_48[] = { S_TRA, 0, 0, S_W23, 0, S_H23, 0, S_BTR, 0, 0, S_W13, 0, S_H13, 0, S_END };
+unsigned char aG3_49[] = { S_LNK, 0x48, S_FLH, S_END };
+unsigned char aG3_4a[] = { S_LNK, 0x48, S_FLV, S_END };
+unsigned char aG3_4b[] = { S_LNK, 0x48, S_FLH, S_FLV, S_END };
+unsigned char aG3_4c[] = { S_LNK, 0x50, S_BOX, 0, S_H13, S_W11, S_H13, S_END };
+unsigned char aG3_4d[] = { S_CHR, 0x25, 0xE6 };
+unsigned char aG3_4e[] = { S_CHR, 0x25, 0xCF };
+unsigned char aG3_4f[] = { S_CHR, 0x25, 0xCB };
+unsigned char aG3_50[] = { S_BOX, S_W12, 0, 2, S_H11, S_FLH, S_BOX, S_W12, 0, 2, S_H11,S_END };
+unsigned char aG3_51[] = { S_BOX, 0, S_H12, S_W11, 2, S_FLV, S_BOX, 0, S_H12, S_W11, 2,S_END };
+unsigned char aG3_52[] = { S_LNK, 0x55, S_FLH, S_FLV, S_END };
+unsigned char aG3_53[] = { S_LNK, 0x55, S_FLV, S_END };
+unsigned char aG3_54[] = { S_LNK, 0x55, S_FLH, S_END };
+unsigned char aG3_55[] = { S_LNK, 0x7e, S_FLV, S_BOX, 0, S_H12, S_W12, 2, S_FLV, S_BOX, 0, S_H12, S_W12, 2, S_END };
+unsigned char aG3_56[] = { S_LNK, 0x57, S_FLH, S_END};
+unsigned char aG3_57[] = { S_LNK, 0x55, S_LNK, 0x50 , S_END};
+unsigned char aG3_58[] = { S_LNK, 0x59, S_FLV, S_END};
+unsigned char aG3_59[] = { S_LNK, 0x7e, S_LNK, 0x51 , S_END};
+unsigned char aG3_5a[] = { S_LNK, 0x50, S_LNK, 0x51 , S_END};
+unsigned char aG3_5b[] = { S_CHR, 0x21, 0x92};
+unsigned char aG3_5c[] = { S_CHR, 0x21, 0x90};
+unsigned char aG3_5d[] = { S_CHR, 0x21, 0x91};
+unsigned char aG3_5e[] = { S_CHR, 0x21, 0x93};
+unsigned char aG3_5f[] = { S_CHR, 0x00, 0x20};
+unsigned char aG3_60[] = { S_INV, S_LNK, 0x20, S_END };
+unsigned char aG3_61[] = { S_INV, S_LNK, 0x21, S_END };
+unsigned char aG3_62[] = { S_INV, S_LNK, 0x22, S_END };
+unsigned char aG3_63[] = { S_INV, S_LNK, 0x23, S_END };
+unsigned char aG3_64[] = { S_INV, S_LNK, 0x24, S_END };
+unsigned char aG3_65[] = { S_INV, S_LNK, 0x25, S_END };
+unsigned char aG3_66[] = { S_LNK, 0x20, S_FLV, S_END };
+unsigned char aG3_67[] = { S_LNK, 0x21, S_FLV, S_END };
+unsigned char aG3_68[] = { S_LNK, 0x22, S_FLV, S_END };
+unsigned char aG3_69[] = { S_LNK, 0x23, S_FLV, S_END };
+unsigned char aG3_6a[] = { S_LNK, 0x24, S_FLV, S_END };
+unsigned char aG3_6b[] = { S_BOX, 0, 0, S_W11, S_H13, S_TRA, 0, S_H13, S_W11, 0, S_H23, 1, S_END };
+unsigned char aG3_6c[] = { S_TRA, 0, 0, 1, 0, S_H12, S_W12, S_FLV, S_TRA, 0, 0, 1, 0, S_H12, S_W12, S_BOX, 0, S_H12, S_W12,1, S_END };
+unsigned char aG3_6d[] = { S_TRA, 0, 0, S_W12, S_W12, S_H12, 0, S_FLH, S_TRA, 0, 0, S_W12, S_W12, S_H12, 0, S_END };
+unsigned char aG3_6e[] = { S_CHR, 0x00, 0x20};
+unsigned char aG3_6f[] = { S_CHR, 0x00, 0x20};
+unsigned char aG3_70[] = { S_INV, S_LNK, 0x30, S_END };
+unsigned char aG3_71[] = { S_INV, S_LNK, 0x31, S_END };
+unsigned char aG3_72[] = { S_INV, S_LNK, 0x32, S_END };
+unsigned char aG3_73[] = { S_INV, S_LNK, 0x33, S_END };
+unsigned char aG3_74[] = { S_INV, S_LNK, 0x34, S_END };
+unsigned char aG3_75[] = { S_INV, S_LNK, 0x35, S_END };
+unsigned char aG3_76[] = { S_LNK, 0x66, S_FLH, S_END };
+unsigned char aG3_77[] = { S_LNK, 0x67, S_FLH, S_END };
+unsigned char aG3_78[] = { S_LNK, 0x68, S_FLH, S_END };
+unsigned char aG3_79[] = { S_LNK, 0x69, S_FLH, S_END };
+unsigned char aG3_7a[] = { S_LNK, 0x6a, S_FLH, S_END };
+unsigned char aG3_7b[] = { S_LNK, 0x6b, S_FLH, S_END };
+unsigned char aG3_7c[] = { S_LNK, 0x6c, S_FLH, S_END };
+unsigned char aG3_7d[] = { S_LNK, 0x6d, S_FLV, S_END };
+unsigned char aG3_7e[] = { S_BOX, S_W12, 0, 2, S_H12, S_FLH, S_BOX, S_W12, 0, 2, S_H12, S_END };// help char, not printed directly (only by S_LNK)
+
+unsigned char *aShapes[] =
+{
+	aG3_20, aG3_21, aG3_22, aG3_23, aG3_24, aG3_25, aG3_26, aG3_27, aG3_28, aG3_29, aG3_2a, aG3_2b, aG3_2c, aG3_2d, aG3_2e, aG3_2f,
+	aG3_30, aG3_31, aG3_32, aG3_33, aG3_34, aG3_35, aG3_36, aG3_37, aG3_38, aG3_39, aG3_3a, aG3_3b, aG3_3c, aG3_3d, aG3_3e, aG3_3f,
+	aG3_40, aG3_41, aG3_42, aG3_43, aG3_44, aG3_45, aG3_46, aG3_47, aG3_48, aG3_49, aG3_4a, aG3_4b, aG3_4c, aG3_4d, aG3_4e, aG3_4f,
+	aG3_50, aG3_51, aG3_52, aG3_53, aG3_54, aG3_55, aG3_56, aG3_57, aG3_58, aG3_59, aG3_5a, aG3_5b, aG3_5c, aG3_5d, aG3_5e, aG3_5f,
+	aG3_60, aG3_61, aG3_62, aG3_63, aG3_64, aG3_65, aG3_66, aG3_67, aG3_68, aG3_69, aG3_6a, aG3_6b, aG3_6c, aG3_6d, aG3_6e, aG3_6f,
+	aG3_70, aG3_71, aG3_72, aG3_73, aG3_74, aG3_75, aG3_76, aG3_77, aG3_78, aG3_79, aG3_7a, aG3_7b, aG3_7c, aG3_7d, aG3_7e
+};
+
+tuxtxt_cache_struct tuxtxt_cache;
+static pthread_mutex_t tuxtxt_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+int tuxtxt_get_zipsize(int p,int sp)
+{
+    tstCachedPage* pg = tuxtxt_cache.astCachetable[p][sp];
+    if (!pg) return 0;
+#if TUXTXT_COMPRESS == 1
+	return pg->ziplen;
+#elif TUXTXT_COMPRESS == 2
+	pthread_mutex_lock(&tuxtxt_cache_lock);
+	int zipsize = 0,i,j;
+	for (i = 0; i < 23*5; i++)
+		for (j = 0; j < 8; j++)
+		zipsize += pg->bitmask[i]>>j & 0x01;
+
+	zipsize+=23*5;//bitmask
+	pthread_mutex_unlock(&tuxtxt_cache_lock);
+	return zipsize;
+#else
+	return 23*40;
+#endif
+}
+void tuxtxt_compress_page(int p, int sp, unsigned char* buffer)
+{
+	pthread_mutex_lock(&tuxtxt_cache_lock);
+	tstCachedPage* pg = tuxtxt_cache.astCachetable[p][sp];
+	if (!pg)
+	{
+		printf("tuxtxt: trying to compress a not allocated page!!\n");
+		pthread_mutex_unlock(&tuxtxt_cache_lock);
+		return;
+	}
+
+#if TUXTXT_COMPRESS == 1
+	unsigned char pagecompressed[23*40];
+	uLongf comprlen = 23*40;
+	if (compress2(pagecompressed,&comprlen,buffer,23*40,Z_BEST_SPEED) == Z_OK)
+	{
+		if (pg->pData)
+			pg->pData = realloc(pg->pData,comprlen); 
+		else
+			pg->pData = malloc(comprlen);
+		pg->ziplen = 0;
+		if (pg->pData)
+		{
+			pg->ziplen = comprlen;
+			memcpy(pg->pData,pagecompressed,comprlen);
+		}
+	}
+#elif TUXTXT_COMPRESS == 2
+	int i,j=0;
+	unsigned char cbuf[23*40];
+	memset(pg->bitmask,0,sizeof(pg->bitmask));
+	for (i = 0; i < 23*40; i++)
+	{
+		if (i && buffer[i] == buffer[i-1])
+		    continue;
+		pg->bitmask[i>>3] |= 0x80>>(i&0x07);
+		cbuf[j++]=buffer[i];
+	}
+	if (pg->pData)
+		pg->pData = realloc(pg->pData,j); 
+	else
+		pg->pData = malloc(j);
+	if (pg->pData)
+	{
+		memcpy(pg->pData,cbuf,j);
+	}
+	else
+		memset(pg->bitmask,0,sizeof(pg->bitmask));
+
+#else
+	memcpy(pg->data,buffer,23*40);
+#endif
+	pthread_mutex_unlock(&tuxtxt_cache_lock);
+
+}
+void tuxtxt_decompress_page(int p, int sp, unsigned char* buffer)
+{
+	pthread_mutex_lock(&tuxtxt_cache_lock);
+    tstCachedPage* pg = tuxtxt_cache.astCachetable[p][sp];
+	memset(buffer,' ',23*40);
+    if (!pg)
+    {
+		printf("tuxtxt: trying to decompress a not allocated page!!\n");
+		pthread_mutex_unlock(&tuxtxt_cache_lock);
+		return;
+    }
+	if (pg->pData)
+	{
+#if TUXTXT_COMPRESS == 1
+		if (pg->ziplen)
+		{
+			uLongf comprlen = 23*40;
+			uncompress(buffer,&comprlen,pg->pData,pg->ziplen);
+		}
+
+#elif TUXTXT_COMPRESS == 2
+		int i,j=0;
+		char c=0x20;
+		for (i = 0; i < 23*40; i++)
+		{
+		    if (pg->bitmask[i>>3] & 0x80>>(i&0x07))
+				c = pg->pData[j++];
+		    buffer[i] = c;
+		}
+#else
+		memcpy(buffer,pg->data,23*40);
+#endif
+	}
+	pthread_mutex_unlock(&tuxtxt_cache_lock);
+}
+void tuxtxt_next_dec(int *i) /* skip to next decimal */
+{
+	(*i)++;
+
+	if ((*i & 0x0F) > 0x09)
+		*i += 0x06;
+
+	if ((*i & 0xF0) > 0x90)
+		*i += 0x60;
+
+	if (*i > 0x899)
+		*i = 0x100;
+}
+
+void tuxtxt_prev_dec(int *i)           /* counting down */
+{
+	(*i)--;
+
+	if ((*i & 0x0F) > 0x09)
+		*i -= 0x06;
+
+	if ((*i & 0xF0) > 0x90)
+		*i -= 0x60;
+
+	if (*i < 0x100)
+		*i = 0x899;
+}
+
+int tuxtxt_is_dec(int i)
+{
+	return ((i & 0x00F) <= 9) && ((i & 0x0F0) <= 0x90);
+}
+
+int tuxtxt_next_hex(int i) /* return next existing non-decimal page number */
+{
+	int startpage = i;
+	if (startpage < 0x100)
+		startpage = 0x100;
+
+	do
+	{
+		i++;
+		if (i > 0x8FF)
+			i = 0x100;
+		if (i == startpage)
+			break;
+	}  while ((tuxtxt_cache.subpagetable[i] == 0xFF) || tuxtxt_is_dec(i));
+	return i;
+}
+#define number2char(c) ((c) + (((c) <= 9) ? '0' : ('A' - 10)))
+/* print hex-number into string, s points to last digit, caller has to provide enough space, no termination */
+void tuxtxt_hex2str(char *s, unsigned int n)
+{
+	do {
+		char c = (n & 0xF);
+		*s-- = number2char(c);
+		n >>= 4;
+	} while (n);
+}
+/*
+ * TOP-Text
+ * Info entnommen aus videotext-0.6.19991029,
+ * Copyright (c) 1994-96 Martin Buck  <martin-2.buck@student.uni-ulm.de>
+ */
+void tuxtxt_decode_btt()
+{
+	/* basic top table */
+	int i, current, b1, b2, b3, b4;
+	unsigned char btt[23*40];
+
+	if (tuxtxt_cache.subpagetable[0x1f0] == 0xff || 0 == tuxtxt_cache.astCachetable[0x1f0][tuxtxt_cache.subpagetable[0x1f0]]) /* not yet received */
+		return;
+	tuxtxt_decompress_page(0x1f0,tuxtxt_cache.subpagetable[0x1f0],btt);
+	if (btt[799] == ' ') /* not completely received or error */
+		return;
+
+	current = 0x100;
+	for (i = 0; i < 800; i++)
+	{
+		b1 = btt[i];
+		if (b1 == ' ')
+			b1 = 0;
+		else
+		{
+			b1 = dehamming[b1];
+			if (b1 == 0xFF) /* hamming error in btt */
+			{
+				btt[799] = ' '; /* mark btt as not received */
+				return;
+			}
+		}
+		tuxtxt_cache.basictop[current] = b1;
+		tuxtxt_next_dec(&current);
+	}
+	/* page linking table */
+	tuxtxt_cache.maxadippg = -1; /* rebuild table of adip pages */
+	for (i = 0; i < 10; i++)
+	{
+		b1 = dehamming[btt[800 + 8*i +0]];
+
+		if (b1 == 0xE)
+			continue; /* unused */
+		else if (b1 == 0xF)
+			break; /* end */
+
+		b4 = dehamming[btt[800 + 8*i +7]];
+
+		if (b4 != 2) /* only adip, ignore multipage (1) */
+			continue;
+
+		b2 = dehamming[btt[800 + 8*i +1]];
+		b3 = dehamming[btt[800 + 8*i +2]];
+
+		if (b1 == 0xFF || b2 == 0xFF || b3 == 0xFF)
+		{
+			printf("TuxTxt <Biterror in btt/plt index %d>\n", i);
+			btt[799] = ' '; /* mark btt as not received */
+			return;
+		}
+
+		b1 = b1<<8 | b2<<4 | b3; /* page number */
+		tuxtxt_cache.adippg[++tuxtxt_cache.maxadippg] = b1;
+	}
+#ifdef DEBUG
+	printf("TuxTxt <BTT decoded>\n");
+#endif
+	tuxtxt_cache.bttok = 1;
+}
+
+void tuxtxt_decode_adip() /* additional information table */
+{
+	int i, p, j, b1, b2, b3, charfound;
+	unsigned char padip[23*40];
+
+	for (i = 0; i <= tuxtxt_cache.maxadippg; i++)
+	{
+		p = tuxtxt_cache.adippg[i];
+		if (!p || tuxtxt_cache.subpagetable[p] == 0xff || 0 == tuxtxt_cache.astCachetable[p][tuxtxt_cache.subpagetable[p]]) /* not cached (avoid segfault) */
+			continue;
+
+		tuxtxt_decompress_page(p,tuxtxt_cache.subpagetable[p],padip);
+		for (j = 0; j < 44; j++)
+		{
+			b1 = dehamming[padip[20*j+0]];
+			if (b1 == 0xE)
+				continue; /* unused */
+
+			if (b1 == 0xF)
+				break; /* end */
+
+			b2 = dehamming[padip[20*j+1]];
+			b3 = dehamming[padip[20*j+2]];
+
+			if (b1 == 0xFF || b2 == 0xFF || b3 == 0xFF)
+			{
+				printf("TuxTxt <Biterror in ait %03x %d %02x %02x %02x %02x %02x %02x>\n", p, j,
+						 padip[20*j+0],
+						 padip[20*j+1],
+						 padip[20*j+2],
+						 b1, b2, b3
+						 );
+				return;
+			}
+
+			if (b1>8 || b2>9 || b3>9) /* ignore extries with invalid or hex page numbers */
+			{
+				continue;
+			}
+
+			b1 = b1<<8 | b2<<4 | b3; /* page number */
+			charfound = 0; /* flag: no printable char found */
+
+			for (b2 = 11; b2 >= 0; b2--)
+			{
+				b3 = deparity[padip[20*j + 8 + b2]];
+				if (b3 < ' ')
+					b3 = ' ';
+
+				if (b3 == ' ' && !charfound)
+					tuxtxt_cache.adip[b1][b2] = '\0';
+				else
+				{
+					tuxtxt_cache.adip[b1][b2] = b3;
+					charfound = 1;
+				}
+			}
+		} /* next link j */
+		tuxtxt_cache.adippg[i] = 0; /* completely decoded: clear entry */
+#ifdef DEBUG
+		printf("TuxTxt <ADIP %03x decoded>\n", p);
+#endif
+	} /* next adip page i */
+
+	while (!tuxtxt_cache.adippg[tuxtxt_cache.maxadippg] && (tuxtxt_cache.maxadippg >= 0)) /* and shrink table */
+		tuxtxt_cache.maxadippg--;
+}
+/******************************************************************************
+ * GetSubPage                                                                 *
+ ******************************************************************************/
+int tuxtxt_GetSubPage(int page, int subpage, int offset)
+{
+	int loop;
+
+
+	for (loop = subpage + offset; loop != subpage; loop += offset)
+	{
+		if (loop < 0)
+			loop = 0x79;
+		else if (loop > 0x79)
+			loop = 0;
+		if (loop == subpage)
+			break;
+
+		if (tuxtxt_cache.astCachetable[page][loop])
+		{
+#ifdef DEBUG
+			printf("TuxTxt <NextSubPage: %.3X-%.2X>\n", page, subpage);
+#endif
+			return loop;
+		}
+	}
+
+#ifdef DEBUG
+	printf("TuxTxt <NextSubPage: no other SubPage>\n");
+#endif
+	return subpage;
+}
+
+/******************************************************************************
+ * clear_cache                                                                *
+ ******************************************************************************/
+
+void tuxtxt_clear_cache()
+{
+	pthread_mutex_lock(&tuxtxt_cache_lock);
+	int clear_page, clear_subpage, d26;
+	tuxtxt_cache.maxadippg  = -1;
+	tuxtxt_cache.bttok      = 0;
+	tuxtxt_cache.cached_pages  = 0;
+	tuxtxt_cache.page_receiving = -1;
+	tuxtxt_cache.vtxtpid = -1;
+	memset(&tuxtxt_cache.subpagetable, 0xFF, sizeof(tuxtxt_cache.subpagetable));
+	memset(&tuxtxt_cache.basictop, 0, sizeof(tuxtxt_cache.basictop));
+	memset(&tuxtxt_cache.adip, 0, sizeof(tuxtxt_cache.adip));
+	memset(&tuxtxt_cache.flofpages, 0 , sizeof(tuxtxt_cache.flofpages));
+	memset(&tuxtxt_cache.timestring, 0x20, 8);
+ 	unsigned char magazine;
+	for (magazine = 1; magazine < 9; magazine++)
+	{
+		tuxtxt_cache.current_page  [magazine] = -1;
+		tuxtxt_cache.current_subpage [magazine] = -1;
+	}
+
+	for (clear_page = 0; clear_page < 0x900; clear_page++)
+		for (clear_subpage = 0; clear_subpage < 0x80; clear_subpage++)
+			if (tuxtxt_cache.astCachetable[clear_page][clear_subpage])
+			{
+				tstPageinfo *p = &(tuxtxt_cache.astCachetable[clear_page][clear_subpage]->pageinfo);
+				if (p->p24)
+					free(p->p24);
+				if (p->ext)
+				{
+					if (p->ext->p27)
+						free(p->ext->p27);
+					for (d26=0; d26 < 16; d26++)
+						if (p->ext->p26[d26])
+							free(p->ext->p26[d26]);
+					free(p->ext);
+				}
+#if TUXTXT_COMPRESS >0
+				if (tuxtxt_cache.astCachetable[clear_page][clear_subpage]->pData)
+					free(tuxtxt_cache.astCachetable[clear_page][clear_subpage]->pData);
+#endif
+				free(tuxtxt_cache.astCachetable[clear_page][clear_subpage]);
+				tuxtxt_cache.astCachetable[clear_page][clear_subpage] = 0;
+			}
+	for (clear_page = 0; clear_page < 9; clear_page++)
+	{
+		if (tuxtxt_cache.astP29[clear_page])
+		{
+		    if (tuxtxt_cache.astP29[clear_page]->p27)
+			free(tuxtxt_cache.astP29[clear_page]->p27);
+		    for (d26=0; d26 < 16; d26++)
+			if (tuxtxt_cache.astP29[clear_page]->p26[d26])
+			    free(tuxtxt_cache.astP29[clear_page]->p26[d26]);
+		    free(tuxtxt_cache.astP29[clear_page]);
+		    tuxtxt_cache.astP29[clear_page] = 0;
+		}
+		tuxtxt_cache.current_page  [clear_page] = -1;
+		tuxtxt_cache.current_subpage [clear_page] = -1;
+	}
+	memset(&tuxtxt_cache.astCachetable, 0, sizeof(tuxtxt_cache.astCachetable));
+	memset(&tuxtxt_cache.astP29, 0, sizeof(tuxtxt_cache.astP29));
+#ifdef DEBUG
+	printf("TuxTxt cache cleared\n");
+#endif
+	pthread_mutex_unlock(&tuxtxt_cache_lock);
+}
+/******************************************************************************
+ * init_demuxer                                                               *
+ ******************************************************************************/
+
+int tuxtxt_init_demuxer()
+{
+	/* open demuxer */
+	if ((tuxtxt_cache.dmx = open(DMX, O_RDWR)) == -1)
+	{
+		perror("TuxTxt <open DMX>");
+		return 0;
+	}
+
+
+	if (ioctl(tuxtxt_cache.dmx, DMX_SET_BUFFER_SIZE, 64*1024) < 0)
+	{
+		perror("TuxTxt <DMX_SET_BUFFERSIZE>");
+		return 0;
+	}
+#ifdef DEBUG
+	printf("TuxTxt: initialized\n");
+#endif
+	/* init successfull */
+
+	return 1;
+}
+/******************************************************************************
+ * CacheThread support functions                                              *
+ ******************************************************************************/
+
+void tuxtxt_decode_p2829(unsigned char *vtxt_row, tstExtData **ptExtData)
+{
+	int bitsleft, colorindex;
+	unsigned char *p;
+	int t1 = deh24(&vtxt_row[7-4]);
+	int t2 = deh24(&vtxt_row[10-4]);
+
+	if (t1 < 0 || t2 < 0)
+	{
+#ifdef DEBUG
+		printf("TuxTxt <Biterror in p28>\n");
+#endif
+		return;
+	}
+
+	if (!(*ptExtData))
+		(*ptExtData) = calloc(1, sizeof(tstExtData));
+	if (!(*ptExtData))
+		return;
+
+	(*ptExtData)->p28Received = 1;
+	(*ptExtData)->DefaultCharset = (t1>>7) & 0x7f;
+	(*ptExtData)->SecondCharset = ((t1>>14) & 0x0f) | ((t2<<4) & 0x70);
+	(*ptExtData)->LSP = !!(t2 & 0x08);
+	(*ptExtData)->RSP = !!(t2 & 0x10);
+	(*ptExtData)->SPL25 = !!(t2 & 0x20);
+	(*ptExtData)->LSPColumns = (t2>>6) & 0x0f;
+
+	bitsleft = 8; /* # of bits not evaluated in val */
+	t2 >>= 10; /* current data */
+	p = &vtxt_row[13-4];	/* pointer to next data triplet */
+	for (colorindex = 0; colorindex < 16; colorindex++)
+	{
+		if (bitsleft < 12)
+		{
+			t2 |= deh24(p) << bitsleft;
+			if (t2 < 0)	/* hamming error */
+				break;
+			p += 3;
+			bitsleft += 18;
+		}
+		(*ptExtData)->bgr[colorindex] = t2 & 0x0fff;
+		bitsleft -= 12;
+		t2 >>= 12;
+	}
+	if (t2 < 0 || bitsleft != 14)
+	{
+#ifdef DEBUG
+		printf("TuxTxt <Biterror in p28/29 t2=%d b=%d>\n", t2, bitsleft);
+#endif
+		(*ptExtData)->p28Received = 0;
+		return;
+	}
+	(*ptExtData)->DefScreenColor = t2 & 0x1f;
+	t2 >>= 5;
+	(*ptExtData)->DefRowColor = t2 & 0x1f;
+	(*ptExtData)->BlackBgSubst = !!(t2 & 0x20);
+	t2 >>= 6;
+	(*ptExtData)->ColorTableRemapping = t2 & 0x07;
+}
+
+void tuxtxt_erase_page(int magazine)
+{
+	pthread_mutex_lock(&tuxtxt_cache_lock);
+    tstCachedPage* pg = tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]];
+	if (pg)
+	{
+		memset(&(pg->pageinfo), 0, sizeof(tstPageinfo));	/* struct pageinfo */
+		memset(pg->p0, ' ', 24);
+#if TUXTXT_COMPRESS == 1
+    	if (pg->pData) {free(pg->pData); pg->pData = NULL;}
+#elif TUXTXT_COMPRESS == 2
+		memset(pg->bitmask, 0, 23*5);
+#else
+		memset(pg->data, ' ', 23*40);
+#endif
+	}
+	pthread_mutex_unlock(&tuxtxt_cache_lock);
+}
+
+void tuxtxt_allocate_cache(int magazine)
+{
+	/* check cachetable and allocate memory if needed */
+	if (tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]] == 0)
+	{
+
+		tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]] = malloc(sizeof(tstCachedPage));
+		if (tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]] )
+		{
+#if TUXTXT_COMPRESS >0
+			tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->pData = 0;
+#endif
+			tuxtxt_erase_page(magazine);
+			tuxtxt_cache.cached_pages++;
+		}
+	}
+}
+/******************************************************************************
+ * CacheThread                                                                *
+ ******************************************************************************/
+#define DEBUG
+void *tuxtxt_CacheThread(void *arg)
+{
+	const unsigned char rev_lut[32] = {
+		0x00,0x08,0x04,0x0c, /*  upper nibble */
+		0x02,0x0a,0x06,0x0e,
+		0x01,0x09,0x05,0x0d,
+		0x03,0x0b,0x07,0x0f,
+		0x00,0x80,0x40,0xc0, /*  lower nibble */
+		0x20,0xa0,0x60,0xe0,
+		0x10,0x90,0x50,0xd0,
+		0x30,0xb0,0x70,0xf0 };
+	unsigned char pes_packet[184];
+	unsigned char vtxt_row[42];
+	int line, byte/*, bit*/;
+	int b1, b2, b3, b4;
+	int packet_number;
+	int doupdate=0;
+	unsigned char magazine = 0xff;
+	unsigned char pagedata[9][23*40];
+	tstPageinfo *pageinfo_thread;
+
+	printf("TuxTxt running thread...(%03x)\n",tuxtxt_cache.vtxtpid);
+	tuxtxt_cache.receiving = 1;
+
+	nice(3);
+	
+	while (1)
+	{
+		/* check stopsignal */
+		pthread_testcancel();
+		if (!tuxtxt_cache.receiving) continue;
+
+		/* read packet */
+		ssize_t readcnt;
+		readcnt = read(tuxtxt_cache.dmx, &pes_packet, sizeof(pes_packet));
+
+		if (readcnt != sizeof(pes_packet))
+		{
+#ifdef DEBUG
+			printf ("TuxTxt: readerror\n");
+#endif
+			continue;
+		}
+
+		/* analyze it */
+		for (line = 0; line < 4; line++)
+		{
+			unsigned char *vtx_rowbyte = &pes_packet[line*0x2e];
+			if ((vtx_rowbyte[0] == 0x02 || vtx_rowbyte[0] == 0x03) && (vtx_rowbyte[1] == 0x2C))
+			{
+				/* clear rowbuffer */
+				/* convert row from lsb to msb (begin with magazin number) */
+				for (byte = 4; byte < 46; byte++)
+				{
+					unsigned char upper,lower;
+					upper = (vtx_rowbyte[byte] >> 4) & 0xf;
+					lower = vtx_rowbyte[byte] & 0xf;
+					vtxt_row[byte-4] = (rev_lut[upper]) | (rev_lut[lower+16]);
+				}
+
+				/* get packet number */
+				b1 = dehamming[vtxt_row[0]];
+				b2 = dehamming[vtxt_row[1]];
+
+				if (b1 == 0xFF || b2 == 0xFF)
+				{
+#ifdef DEBUG
+					printf("TuxTxt <Biterror in Packet>\n");
+#endif
+					continue;
+				}
+
+				b1 &= 8;
+
+				packet_number = b1>>3 | b2<<1;
+
+				/* get magazine number */
+				magazine = dehamming[vtxt_row[0]] & 7;
+				if (!magazine) magazine = 8;
+
+				if (packet_number == 0 && tuxtxt_cache.current_page[magazine] != -1 && tuxtxt_cache.current_subpage[magazine] != -1)
+ 				    tuxtxt_compress_page(tuxtxt_cache.current_page[magazine],tuxtxt_cache.current_subpage[magazine],pagedata[magazine]);
+
+//printf("receiving packet %d %03x/%02x\n",packet_number, tuxtxt_cache.current_page[magazine],tuxtxt_cache.current_subpage[magazine]);
+
+				/* analyze row */
+				if (packet_number == 0)
+				{
+    					/* get pagenumber */
+					b2 = dehamming[vtxt_row[3]];
+					b3 = dehamming[vtxt_row[2]];
+
+					if (b2 == 0xFF || b3 == 0xFF)
+					{
+						tuxtxt_cache.current_page[magazine] = tuxtxt_cache.page_receiving = -1;
+#ifdef DEBUG
+						printf("TuxTxt <Biterror in Page>\n");
+#endif
+						continue;
+					}
+
+					tuxtxt_cache.current_page[magazine] = tuxtxt_cache.page_receiving = magazine<<8 | b2<<4 | b3;
+
+					if (b2 == 0x0f && b3 == 0x0f)
+					{
+						tuxtxt_cache.current_subpage[magazine] = -1; /* ?ff: ignore data transmissions */
+						continue;
+					}
+
+					/* get subpagenumber */
+					b1 = dehamming[vtxt_row[7]];
+					b2 = dehamming[vtxt_row[6]];
+					b3 = dehamming[vtxt_row[5]];
+					b4 = dehamming[vtxt_row[4]];
+
+					if (b1 == 0xFF || b2 == 0xFF || b3 == 0xFF || b4 == 0xFF)
+					{
+#ifdef DEBUG
+						printf("TuxTxt <Biterror in SubPage>\n");
+#endif
+						tuxtxt_cache.current_subpage[magazine] = -1;
+						continue;
+					}
+
+					b1 &= 3;
+					b3 &= 7;
+
+					if (tuxtxt_is_dec(tuxtxt_cache.page_receiving)) /* ignore other subpage bits for hex pages */
+					{
+#if 0	/* ? */
+						if (b1 != 0 || b2 != 0)
+						{
+#ifdef DEBUG
+							printf("TuxTxt <invalid subpage data p%03x %02x %02x %02x %02x>\n", tuxtxt_cache.page_receiving, b1, b2, b3, b4);
+#endif
+							tuxtxt_cache.current_subpage[magazine] = -1;
+							continue;
+						}
+						else
+#endif
+							tuxtxt_cache.current_subpage[magazine] = b3<<4 | b4;
+					}
+					else
+						tuxtxt_cache.current_subpage[magazine] = b4; /* max 16 subpages for hex pages */
+
+					/* store current subpage for this page */
+					tuxtxt_cache.subpagetable[tuxtxt_cache.current_page[magazine]] = tuxtxt_cache.current_subpage[magazine];
+
+					tuxtxt_allocate_cache(magazine);
+					tuxtxt_decompress_page(tuxtxt_cache.current_page[magazine],tuxtxt_cache.current_subpage[magazine],pagedata[magazine]);
+					pageinfo_thread = &(tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->pageinfo);
+
+					if ((tuxtxt_cache.page_receiving & 0xff) == 0xfe) /* ?fe: magazine organization table (MOT) */
+						pageinfo_thread->function = FUNC_MOT;
+
+					/* check controlbits */
+					if (dehamming[vtxt_row[5]] & 8)   /* C4 -> erase page */
+					{
+#if TUXTXT_COMPRESS == 1
+						tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->ziplen = 0;
+#elif TUXTXT_COMPRESS == 2
+						memset(tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->bitmask, 0, 23*5);
+#else
+						memset(tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->data, ' ', 23*40);
+#endif
+						memset(pagedata[magazine],' ', 23*40);
+					}
+					if (dehamming[vtxt_row[9]] & 8)   /* C8 -> update page */
+						doupdate = tuxtxt_cache.page_receiving;
+
+					pageinfo_thread->boxed = !!(dehamming[vtxt_row[7]] & 0x0c);
+
+					/* get country control bits */
+					b1 = dehamming[vtxt_row[9]];
+					if (b1 == 0xFF)
+					{
+#ifdef DEBUG
+						printf("TuxTxt <Biterror in CountryFlags>\n");
+#endif
+					}
+					else
+					{
+						pageinfo_thread->nationalvalid = 1;
+						pageinfo_thread->national = rev_lut[b1] & 0x07;
+					}
+
+					/* check parity, copy line 0 to cache (start and end 8 bytes are not needed and used otherwise) */
+					unsigned char *p = tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->p0;
+					for (byte = 10; byte < 42-8; byte++)
+						*p++ = deparity[vtxt_row[byte]];
+
+					if (!tuxtxt_is_dec(tuxtxt_cache.page_receiving))
+						continue; /* valid hex page number: just copy headline, ignore timestring */
+
+					/* copy timestring */
+					p = tuxtxt_cache.timestring;
+					for (; byte < 42; byte++)
+						*p++ = deparity[vtxt_row[byte]];
+				} /* (packet_number == 0) */
+				else if (packet_number == 29 && dehamming[vtxt_row[2]]== 0) /* packet 29/0 replaces 28/0 for a whole magazine */
+				{
+					tuxtxt_decode_p2829(vtxt_row, &(tuxtxt_cache.astP29[magazine]));
+				}
+				else if (tuxtxt_cache.current_page[magazine] != -1 && tuxtxt_cache.current_subpage[magazine] != -1)
+					/* packet>0, 0 has been correctly received, buffer allocated */
+				{
+					pageinfo_thread = &(tuxtxt_cache.astCachetable[tuxtxt_cache.current_page[magazine]][tuxtxt_cache.current_subpage[magazine]]->pageinfo);
+					/* pointer to current info struct */
+
+					if (packet_number <= 25)
+					{
+						unsigned char *p = NULL;
+						if (packet_number < 24)
+							p = pagedata[magazine] + 40*(packet_number-1);
+						else
+						{
+							if (!(pageinfo_thread->p24))
+								pageinfo_thread->p24 = calloc(2, 40);
+							if (pageinfo_thread->p24)
+								p = pageinfo_thread->p24 + (packet_number - 24) * 40;
+						}
+						if (p)
+						{
+							if (tuxtxt_is_dec(tuxtxt_cache.current_page[magazine]))
+								for (byte = 2; byte < 42; byte++)
+									*p++ = deparity[vtxt_row[byte]]; /* check/remove parity bit */
+							else if ((tuxtxt_cache.current_page[magazine] & 0xff) == 0xfe)
+								for (byte = 2; byte < 42; byte++)
+									*p++ = dehamming[vtxt_row[byte]]; /* decode hamming 8/4 */
+							else /* other hex page: no parity check, just copy */
+								memcpy(p, &vtxt_row[2], 40);
+						}
+					}
+					else if (packet_number == 27)
+					{
+						int descode = dehamming[vtxt_row[2]]; /* designation code (0..15) */
+
+						if (descode == 0xff)
+						{
+#ifdef DEBUG
+							printf("TuxTxt <Biterror in p27>\n");
+#endif
+							continue;
+						}
+						if (descode == 0) // reading FLOF-Pagelinks
+						{
+							b1 = dehamming[vtxt_row[0]];
+							if (b1 != 0xff)
+							{
+								b1 &= 7;
+
+								for (byte = 0; byte < FLOFSIZE; byte++)
+								{
+									b2 = dehamming[vtxt_row[4+byte*6]];
+									b3 = dehamming[vtxt_row[3+byte*6]];
+
+									if (b2 != 0xff && b3 != 0xff)
+									{
+										b4 = ((b1 ^ (dehamming[vtxt_row[8+byte*6]]>>1)) & 6) |
+											((b1 ^ (dehamming[vtxt_row[6+byte*6]]>>3)) & 1);
+										if (b4 == 0)
+											b4 = 8;
+										if (b2 <= 9 && b3 <= 9)
+											tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine] ][byte] = b4<<8 | b2<<4 | b3;
+									}
+								}
+
+								/* copy last 2 links to adip for TOP-Index */
+								if (pageinfo_thread->p24) /* packet 24 received */
+								{
+									int a, a1, e=39, l=3;
+									char *p = (char*) pageinfo_thread->p24;
+									do
+									{
+										for (;
+											  l >= 2 && 0 == tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine]][l];
+											  l--)
+											; /* find used linkindex */
+										for (;
+											  e >= 1 && !isalnum(p[e]);
+											  e--)
+											; /* find end */
+										for (a = a1 = e - 1;
+											  a >= 0 && p[a] >= ' ';
+											  a--) /* find start */
+											if (p[a] > ' ')
+											a1 = a; /* first non-space */
+										if (a >= 0 && l >= 2)
+										{
+											strncpy((char*) tuxtxt_cache.adip[tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine]][l]],
+													  &p[a1],
+													  12);
+											if (e-a1 < 11)
+												tuxtxt_cache.adip[tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine]][l]][e-a1+1] = '\0';
+#if 0 //DEBUG
+											printf(" %03x/%02x %d %d %d %d %03x %s\n",
+													 tuxtxt_cache.current_page[magazine], tuxtxt_cache.current_subpage[magazine],
+													 l, a, a1, e,
+													 tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine]][l],
+													 tuxtxt_cache.adip[tuxtxt_cache.flofpages[tuxtxt_cache.current_page[magazine]][l]]
+													 );
+#endif
+										}
+										e = a - 1;
+										l--;
+									} while (l >= 2);
+								}
+							}
+						}
+						else if (descode == 4)	/* level 2.5 links (ignore level 3.5 links of /4 and /5) */
+						{
+							int i;
+							tstp27 *p;
+
+							if (!pageinfo_thread->ext)
+								pageinfo_thread->ext = calloc(1, sizeof(tstExtData));
+							if (!pageinfo_thread->ext)
+								continue;
+							if (!(pageinfo_thread->ext->p27))
+								pageinfo_thread->ext->p27 = calloc(4, sizeof(tstp27));
+							if (!(pageinfo_thread->ext->p27))
+								continue;
+							p = pageinfo_thread->ext->p27;
+							for (i = 0; i < 4; i++)
+							{
+								int d1 = deh24(&vtxt_row[6*i + 3]);
+								int d2 = deh24(&vtxt_row[6*i + 6]);
+								if (d1 < 0 || d2 < 0)
+								{
+#ifdef DEBUG
+									printf("TuxTxt <Biterror in p27/4-5>\n");
+#endif
+									continue;
+								}
+								p->local = i & 0x01;
+								p->drcs = !!(i & 0x02);
+								p->l25 = !!(d1 & 0x04);
+								p->l35 = !!(d1 & 0x08);
+								p->page =
+									(((d1 & 0x000003c0) >> 6) |
+									 ((d1 & 0x0003c000) >> (14-4)) |
+									 ((d1 & 0x00003800) >> (11-8))) ^
+									(dehamming[vtxt_row[0]] << 8);
+								if (p->page < 0x100)
+									p->page += 0x800;
+								p->subpage = d2 >> 2;
+								if ((p->page & 0xff) == 0xff)
+									p->page = 0;
+								else if (p->page > 0x899)
+								{
+									// workaround for crash on RTL Shop ...
+									// sorry.. i dont understand whats going wrong here :)
+									printf("[TuxTxt] page > 0x899 ... ignore!!!!!!\n");
+									continue;
+								}
+								else if (tuxtxt_cache.astCachetable[p->page][0])	/* link valid && linked page cached */
+								{
+									tstPageinfo *pageinfo_link = &(tuxtxt_cache.astCachetable[p->page][0]->pageinfo);
+									if (p->local)
+										pageinfo_link->function = p->drcs ? FUNC_DRCS : FUNC_POP;
+									else
+										pageinfo_link->function = p->drcs ? FUNC_GDRCS : FUNC_GPOP;
+								}
+								p++; /*  */
+							}
+						}
+					}
+
+					else if (packet_number == 26)
+					{
+						int descode = dehamming[vtxt_row[2]]; /* designation code (0..15) */
+
+						if (descode == 0xff)
+						{
+#ifdef DEBUG
+							printf("TuxTxt <Biterror in p26>\n");
+#endif
+							continue;
+						}
+						if (!pageinfo_thread->ext)
+							pageinfo_thread->ext = calloc(1, sizeof(tstExtData));
+						if (!pageinfo_thread->ext)
+							continue;
+						if (!(pageinfo_thread->ext->p26[descode]))
+							pageinfo_thread->ext->p26[descode] = malloc(13 * 3);
+						if (pageinfo_thread->ext->p26[descode])
+							memcpy(pageinfo_thread->ext->p26[descode], &vtxt_row[3], 13 * 3);
+#if 0//DEBUG
+						int i, t, m;
+
+						printf("P%03x/%02x %02d/%x",
+								 tuxtxt_cache.current_page[magazine], tuxtxt_cache.current_subpage[magazine],
+								 packet_number, dehamming[vtxt_row[2]]);
+						for (i=7-4; i <= 45-4; i+=3) /* dump all triplets */
+						{
+							t = deh24(&vtxt_row[i]); /* mode/adr/data */
+							m = (t>>6) & 0x1f;
+							printf(" M%02xA%02xD%03x", m, t & 0x3f, (t>>11) & 0x7f);
+							if (m == 0x1f)	/* terminator */
+								break;
+						}
+						putchar('\n');
+#endif
+					}
+					else if (packet_number == 28)
+					{
+						int descode = dehamming[vtxt_row[2]]; /* designation code (0..15) */
+
+						if (descode == 0xff)
+						{
+#ifdef DEBUG
+							printf("TuxTxt <Biterror in p28>\n");
+#endif
+							continue;
+						}
+						if (descode != 2)
+						{
+							int t1 = deh24(&vtxt_row[7-4]);
+							pageinfo_thread->function = t1 & 0x0f;
+							if (!pageinfo_thread->nationalvalid)
+							{
+								pageinfo_thread->nationalvalid = 1;
+								pageinfo_thread->national = (t1>>4) & 0x07;
+							}
+						}
+
+						switch (descode) /* designation code */
+						{
+						case 0: /* basic level 1 page */
+						{
+							tuxtxt_decode_p2829(vtxt_row, &(pageinfo_thread->ext));
+							break;
+						}
+						case 1: /* G0/G1 designation for older decoders, level 3.5: DCLUT4/16, colors for multicolored bitmaps */
+						{
+							break; /* ignore */
+						}
+						case 2: /* page key */
+						{
+							break; /* ignore */
+						}
+						case 3: /* types of PTUs in DRCS */
+						{
+							break; /* TODO */
+						}
+						case 4: /* CLUTs 0/1, only level 3.5 */
+						{
+							break; /* ignore */
+						}
+						default:
+						{
+							break; /* invalid, ignore */
+						}
+						} /* switch designation code */
+					}
+					else if (packet_number == 30)
+					{
+#if 0//DEBUG
+						int i;
+
+						printf("p%03x/%02x %02d/%x ",
+								 tuxtxt_cache.current_page[magazine], tuxtxt_cache.current_subpage[magazine],
+								 packet_number, dehamming[vtxt_row[2]]);
+						for (i=26-4; i <= 45-4; i++) /* station ID */
+							putchar(deparity[vtxt_row[i]]);
+						putchar('\n');
+#endif
+					}
+				}
+				/* set update flag */
+				if (tuxtxt_cache.current_page[magazine] == tuxtxt_cache.page && tuxtxt_cache.current_subpage[magazine] != -1)
+				{
+ 				    tuxtxt_compress_page(tuxtxt_cache.current_page[magazine],tuxtxt_cache.current_subpage[magazine],pagedata[magazine]);
+					tuxtxt_cache.pageupdate = 1+(doupdate == tuxtxt_cache.page ? 1: 0);
+					doupdate=0;
+					if (!tuxtxt_cache.zap_subpage_manual)
+						tuxtxt_cache.subpage = tuxtxt_cache.current_subpage[magazine];
+				}
+			}
+		}
+	}
+	return 0;
+}
+/******************************************************************************
+ * start_thread                                                               *
+ ******************************************************************************/
+int tuxtxt_start_thread()
+{
+	if (tuxtxt_cache.vtxtpid == -1) return 0;
+
+
+	tuxtxt_cache.thread_starting = 1;
+	struct dmx_pes_filter_params dmx_flt;
+
+	/* set filter & start demuxer */
+	dmx_flt.pid      = tuxtxt_cache.vtxtpid;
+	dmx_flt.input    = DMX_IN_FRONTEND;
+	dmx_flt.output   = DMX_OUT_TAP;
+	dmx_flt.pes_type = DMX_PES_OTHER;
+	dmx_flt.flags    = DMX_IMMEDIATE_START;
+
+	if (tuxtxt_cache.dmx == -1) tuxtxt_init_demuxer();
+
+	if (ioctl(tuxtxt_cache.dmx, DMX_SET_PES_FILTER, &dmx_flt) == -1)
+	{
+		perror("TuxTxt <DMX_SET_PES_FILTER>");
+		tuxtxt_cache.thread_starting = 0;
+		return 0;
+	}
+
+	/* create decode-thread */
+	if (pthread_create(&tuxtxt_cache.thread_id, NULL, tuxtxt_CacheThread, NULL) != 0)
+	{
+		perror("TuxTxt <pthread_create>");
+		tuxtxt_cache.thread_starting = 0;
+		tuxtxt_cache.thread_id = 0;
+		return 0;
+	}
+#if 1//DEBUG
+	printf("TuxTxt service started %x\n", tuxtxt_cache.vtxtpid);
+#endif
+	tuxtxt_cache.receiving = 1;
+	tuxtxt_cache.thread_starting = 0;
+	return 1;
+}
+/******************************************************************************
+ * stop_thread                                                                *
+ ******************************************************************************/
+
+int tuxtxt_stop_thread()
+{
+
+	/* stop decode-thread */
+	if (tuxtxt_cache.thread_id != 0)
+	{
+		if (pthread_cancel(tuxtxt_cache.thread_id) != 0)
+		{
+			perror("TuxTxt <pthread_cancel>");
+			return 0;
+		}
+
+		if (pthread_join(tuxtxt_cache.thread_id, &tuxtxt_cache.thread_result) != 0)
+		{
+			perror("TuxTxt <pthread_join>");
+			return 0;
+		}
+		tuxtxt_cache.thread_id = 0;
+	}
+	if (tuxtxt_cache.dmx != -1)
+	{
+		ioctl(tuxtxt_cache.dmx, DMX_STOP);
+//        close(tuxtxt_cache.dmx);
+  	}
+//	tuxtxt_cache.dmx = -1;
+#if 1//DEBUG
+	printf("TuxTxt stopped service %x\n", tuxtxt_cache.vtxtpid);
+#endif
+	return 1;
+}
+
+/******************************************************************************
+ * decode Level2.5                                                            *
+ ******************************************************************************/
+int tuxtxt_eval_triplet(int iOData, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  unsigned char *drcssubp, unsigned char *gdrcssubp,
+					  signed char *endcol, tstPageAttr *attrPassive, unsigned char* pagedata, unsigned char* page_char, tstPageAttr* page_atrb);
+
+/* get object data */
+/* in: absolute triplet number (0..506, start at packet 3 byte 1) */
+/* in: pointer to cache struct of page data */
+/* out: 18 bit triplet data, <0 if invalid number, not cached, or hamming error */
+int tuxtxt_iTripletNumber2Data(int iONr, tstCachedPage *pstCachedPage, unsigned char* pagedata)
+{
+	if (iONr > 506 || 0 == pstCachedPage)
+		return -1;
+
+	unsigned char *p;
+	int packet = (iONr / 13) + 3;
+	int packetoffset = 3 * (iONr % 13);
+
+fprintf(stderr, "%s\n", __func__);
+
+	if (packet <= 23)
+		p = pagedata + 40*(packet-1) + packetoffset + 1;
+	else if (packet <= 25)
+	{
+		if (0 == pstCachedPage->pageinfo.p24)
+			return -1;
+		p = pstCachedPage->pageinfo.p24 + 40*(packet-24) + packetoffset + 1;
+	}
+	else
+	{
+		int descode = packet - 26;
+		if (0 == pstCachedPage->pageinfo.ext)
+			return -1;
+		if (0 == pstCachedPage->pageinfo.ext->p26[descode])
+			return -1;
+		p = pstCachedPage->pageinfo.ext->p26[descode] + packetoffset;	/* first byte (=designation code) is not cached */
+	}
+	return deh24(p);
+}
+
+#define RowAddress2Row(row) ((row == 40) ? 24 : (row - 40))
+
+/* dump interpreted object data to stdout */
+/* in: 18 bit object data */
+/* out: termination info, >0 if end of object */
+void tuxtxt_eval_object(int iONr, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  tObjType ObjType, unsigned char* pagedata, unsigned char* page_char, tstPageAttr* page_atrb)
+{
+	int iOData;
+	int iONr1 = iONr + 1; /* don't terminate after first triplet */
+	unsigned char drcssubp=0, gdrcssubp=0;
+	signed char endcol = -1; /* last column to which to extend attribute changes */
+	tstPageAttr attrPassive = { white  , black , C_G0P, 0, 0, 1 ,0, 0, 0, 0, 0, 0, 0, 0x3f}; /* current attribute for passive objects */
+
+fprintf(stderr, "%s\n", __func__);
+	do
+	{
+		iOData = tuxtxt_iTripletNumber2Data(iONr, pstCachedPage,pagedata);	/* get triplet data, next triplet */
+		if (iOData < 0) /* invalid number, not cached, or hamming error: terminate */
+			break;
+
+		if (endcol < 0)
+		{
+			if (ObjType == OBJ_ACTIVE)
+			{
+				endcol = 40;
+			}
+			else if (ObjType == OBJ_ADAPTIVE) /* search end of line */
+			{
+				int i;
+				for (i = iONr; i <= 506; i++)
+				{
+					int iTempOData = tuxtxt_iTripletNumber2Data(i, pstCachedPage,pagedata); /* get triplet data, next triplet */
+					int iAddress = (iTempOData      ) & 0x3f;
+					int iMode    = (iTempOData >>  6) & 0x1f;
+					//int iData    = (iTempOData >> 11) & 0x7f;
+					if (iTempOData < 0 || /* invalid number, not cached, or hamming error: terminate */
+						 (iAddress >= 40	/* new row: row address and */
+						 && (iMode == 0x01 || /* Full Row Color or */
+							  iMode == 0x04 || /* Set Active Position */
+							  (iMode >= 0x15 && iMode <= 0x17) || /* Object Definition */
+							  iMode == 0x17))) /* Object Termination */
+						break;
+					if (iAddress < 40 && iMode != 0x06)
+						endcol = iAddress;
+				}
+
+			}
+		}
+		iONr++;
+	}
+	while (0 == tuxtxt_eval_triplet(iOData, pstCachedPage, pAPx, pAPy, pAPx0, pAPy0, &drcssubp, &gdrcssubp, &endcol, &attrPassive, pagedata, page_char, page_atrb)
+			 || iONr1 == iONr); /* repeat until termination reached */
+}
+
+void tuxtxt_eval_NumberedObject(int p, int s, int packet, int triplet, int high,
+								 unsigned char *pAPx, unsigned char *pAPy,
+								 unsigned char *pAPx0, unsigned char *pAPy0, unsigned char* page_char, tstPageAttr* page_atrb)
+{
+fprintf(stderr, "%s\n", __func__);
+	if (!packet || 0 == tuxtxt_cache.astCachetable[p][s])
+		return;
+	unsigned char pagedata[23*40];
+	tuxtxt_decompress_page(p, s,pagedata);
+
+
+	int idata = deh24(pagedata + 40*(packet-1) + 1 + 3*triplet);
+	int iONr;
+
+	if (idata < 0)	/* hamming error: ignore triplet */
+		return;
+	if (high)
+		iONr = idata >> 9; /* triplet number of odd object data */
+	else
+		iONr = idata & 0x1ff; /* triplet number of even object data */
+	if (iONr <= 506)
+	{
+
+		tuxtxt_eval_object(iONr, tuxtxt_cache.astCachetable[p][s], pAPx, pAPy, pAPx0, pAPy0, (tObjType)(triplet % 3),pagedata, page_char, page_atrb);
+	}
+}
+
+int tuxtxt_eval_triplet(int iOData, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  unsigned char *drcssubp, unsigned char *gdrcssubp,
+					  signed char *endcol, tstPageAttr *attrPassive, unsigned char* pagedata, unsigned char* page_char, tstPageAttr* page_atrb)
+{
+	int iAddress = (iOData      ) & 0x3f;
+	int iMode    = (iOData >>  6) & 0x1f;
+	int iData    = (iOData >> 11) & 0x7f;
+
+fprintf(stderr, "%s\n", __func__);
+
+	if (iAddress < 40) /* column addresses */
+	{
+		int offset;	/* offset to page_char and page_atrb */
+
+		if (iMode != 0x06)
+			*pAPx = iAddress;	/* new Active Column */
+		offset = (*pAPy0 + *pAPy) * 40 + *pAPx0 + *pAPx;	/* offset to page_char and page_atrb */
+
+
+		switch (iMode)
+		{
+		case 0x00:
+			if (0 == (iData>>5))
+			{
+				int newcolor = iData & 0x1f;
+				if (*endcol < 0) /* passive object */
+					attrPassive->fg = newcolor;
+				else if (*endcol == 40) /* active object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int oldcolor = (p)->fg; /* current color (set-after) */
+					int c = *pAPx0 + *pAPx;	/* current column absolute */
+					do
+					{
+						p->fg = newcolor;
+						p++;
+						c++;
+					} while (c < 40 && p->fg == oldcolor);	/* stop at change by level 1 page */
+				}
+				else /* adaptive object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int c = *pAPx;	/* current column relative to object origin */
+					do
+					{
+						p->fg = newcolor;
+						p++;
+						c++;
+					} while (c <= *endcol);
+				}
+
+			}
+			break;
+		case 0x01:
+			if (iData >= 0x20)
+			{
+
+				page_char[offset] = iData;
+				if (*endcol < 0) /* passive object */
+				{
+					attrPassive->charset = C_G1C; /* FIXME: separated? */
+					page_atrb[offset] = *attrPassive;
+				}
+				else if (page_atrb[offset].charset != C_G1S)
+					page_atrb[offset].charset = C_G1C; /* FIXME: separated? */
+			}
+			break;
+		case 0x02:
+		case 0x0b:
+
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G3;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_G3;
+			break;
+		case 0x03:
+			if (0 == (iData>>5))
+			{
+				int newcolor = iData & 0x1f;
+				if (*endcol < 0) /* passive object */
+					attrPassive->bg = newcolor;
+				else if (*endcol == 40) /* active object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int oldcolor = (p)->bg; /* current color (set-after) */
+					int c = *pAPx0 + *pAPx;	/* current column absolute */
+					do
+					{
+						p->bg = newcolor;
+						if (newcolor == black)
+							p->IgnoreAtBlackBgSubst = 1;
+						p++;
+						c++;
+					} while (c < 40 && p->bg == oldcolor);	/* stop at change by level 1 page */
+				}
+				else /* adaptive object */
+				{
+					tstPageAttr *p = &page_atrb[offset];
+					int c = *pAPx;	/* current column relative to object origin */
+					do
+					{
+						p->bg = newcolor;
+						if (newcolor == black)
+							p->IgnoreAtBlackBgSubst = 1;
+						p++;
+						c++;
+					} while (c <= *endcol);
+				}
+
+			}
+			break;
+		case 0x06:
+
+			/* ignore */
+			break;
+		case 0x07:
+
+			if ((iData & 0x60) != 0) break; // reserved data field
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->flashing=iData & 0x1f;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].flashing=iData & 0x1f;
+			break;
+		case 0x08:
+
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->setG0G2=iData & 0x3f;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].setG0G2=iData & 0x3f;
+			break;
+		case 0x09:
+
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G0P; /* FIXME: secondary? */
+				attrPassive->setX26  = 1;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+			{
+				page_atrb[offset].charset = C_G0P; /* FIXME: secondary? */
+				page_atrb[offset].setX26  = 1;
+			}
+			break;
+//		case 0x0b: (see 0x02)
+		case 0x0c:
+		{
+
+			int conc = (iData & 0x04);
+			int inv  = (iData & 0x10);
+			int dw   = (iData & 0x40 ?1:0);
+			int dh   = (iData & 0x01 ?1:0);
+			int sep  = (iData & 0x20);
+			int bw   = (iData & 0x02 ?1:0);
+			if (*endcol < 0) /* passive object */
+			{
+				if (conc)
+				{
+					attrPassive->concealed = 1;
+					attrPassive->fg = attrPassive->bg;
+				}
+				attrPassive->inverted = (inv ? 1- attrPassive->inverted : 0);
+				attrPassive->doubleh = dh;
+				attrPassive->doublew = dw;
+				attrPassive->boxwin = bw;
+				if (bw) attrPassive->IgnoreAtBlackBgSubst = 0;
+				if (sep)
+				{
+					if (attrPassive->charset == C_G1C)
+						attrPassive->charset = C_G1S;
+					else
+						attrPassive->underline = 1;
+				}
+				else
+				{
+					if (attrPassive->charset == C_G1S)
+						attrPassive->charset = C_G1C;
+					else
+						attrPassive->underline = 0;
+				}
+			}
+			else
+			{
+
+				int c = *pAPx0 + (*endcol == 40 ? *pAPx : 0);	/* current column */
+				int c1 = offset;
+				tstPageAttr *p = &page_atrb[offset];
+				do
+				{
+					p->inverted = (inv ? 1- p->inverted : 0);
+					if (conc)
+					{
+						p->concealed = 1;
+						p->fg = p->bg;
+					}
+					if (sep)
+					{
+						if (p->charset == C_G1C)
+							p->charset = C_G1S;
+						else
+							p->underline = 1;
+					}
+					else
+					{
+						if (p->charset == C_G1S)
+							p->charset = C_G1C;
+						else
+							p->underline = 0;
+					}
+					p->doublew = dw;
+					p->doubleh = dh;
+					p->boxwin = bw;
+					if (bw) p->IgnoreAtBlackBgSubst = 0;
+					p++;
+					c++;
+					c1++;
+				} while (c < *endcol);
+			}
+			break;
+		}
+		case 0x0d:
+
+			page_char[offset] = iData & 0x3f;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_OFFSET_DRCS + ((iData & 0x40) ? (0x10 + *drcssubp) : *gdrcssubp);
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_OFFSET_DRCS + ((iData & 0x40) ? (0x10 + *drcssubp) : *gdrcssubp);
+			break;
+		case 0x0f:
+
+			page_char[offset] = iData;
+			if (*endcol < 0) /* passive object */
+			{
+				attrPassive->charset = C_G2;
+				page_atrb[offset] = *attrPassive;
+			}
+			else
+				page_atrb[offset].charset = C_G2;
+			break;
+		default:
+			if (iMode == 0x10 && iData == 0x2a)
+				iData = '@';
+			if (iMode >= 0x10)
+			{
+
+				page_char[offset] = iData;
+				if (*endcol < 0) /* passive object */
+				{
+					attrPassive->charset = C_G0P;
+					attrPassive->diacrit = iMode & 0x0f;
+					attrPassive->setX26  = 1;
+					page_atrb[offset] = *attrPassive;
+				}
+				else
+				{
+					page_atrb[offset].charset = C_G0P;
+					page_atrb[offset].diacrit = iMode & 0x0f;
+					page_atrb[offset].setX26  = 1;
+				}
+			}
+			break; /* unsupported or not yet implemented mode: ignore */
+		} /* switch (iMode) */
+	}
+	else /* ================= (iAddress >= 40): row addresses ====================== */
+	{
+
+		switch (iMode)
+		{
+		case 0x00:
+			if (0 == (iData>>5))
+			{
+
+				tuxtxt_cache.FullScrColor = iData & 0x1f;
+			}
+			break;
+		case 0x01:
+			if (*endcol == 40) /* active object */
+			{
+				*pAPy = RowAddress2Row(iAddress);	/* new Active Row */
+
+				int color = iData & 0x1f;
+				int row = *pAPy0 + *pAPy;
+				int maxrow;
+
+				if (row <= 24 && 0 == (iData>>5))
+					maxrow = row;
+				else if (3 == (iData>>5))
+					maxrow = 24;
+				else
+					maxrow = -1;
+				for (; row <= maxrow; row++)
+					tuxtxt_cache.FullRowColor[row] = color;
+				*endcol = -1;
+			}
+			break;
+		case 0x04:
+
+			*pAPy = RowAddress2Row(iAddress); /* new Active Row */
+			if (iData < 40)
+				*pAPx = iData;	/* new Active Column */
+			*endcol = -1; /* FIXME: check if row changed? */
+			break;
+		case 0x07:
+
+			if (iAddress == 0x3f)
+			{
+				*pAPx = *pAPy = 0; /* new Active Position 0,0 */
+				if (*endcol == 40) /* active object */
+				{
+					int color = iData & 0x1f;
+					int row = *pAPy0; // + *pAPy;
+					int maxrow;
+
+					if (row <= 24 && 0 == (iData>>5))
+						maxrow = row;
+					else if (3 == (iData>>5))
+						maxrow = 24;
+					else
+						maxrow = -1;
+					for (; row <= maxrow; row++)
+						tuxtxt_cache.FullRowColor[row] = color;
+				}
+				*endcol = -1;
+			}
+			break;
+		case 0x08:
+		case 0x09:
+		case 0x0a:
+		case 0x0b:
+		case 0x0c:
+		case 0x0d:
+		case 0x0e:
+		case 0x0f:
+
+			/* ignore */
+			break;
+		case 0x10:
+
+			tuxtxt_cache.tAPy = iAddress - 40;
+			tuxtxt_cache.tAPx = iData;
+			break;
+		case 0x11:
+		case 0x12:
+		case 0x13:
+			if (iAddress & 0x10)	/* POP or GPOP */
+			{
+				unsigned char APx = 0, APy = 0;
+				unsigned char APx0 = *pAPx0 + *pAPx + tuxtxt_cache.tAPx, APy0 = *pAPy0 + *pAPy + tuxtxt_cache.tAPy;
+				int triplet = 3 * ((iData >> 5) & 0x03) + (iMode & 0x03);
+				int packet = (iAddress & 0x03) + 1;
+				int subp = iData & 0x0f;
+				int high = (iData >> 4) & 0x01;
+
+
+				if (APx0 < 40) /* not in side panel */
+				{
+
+					tuxtxt_eval_NumberedObject((iAddress & 0x08) ? tuxtxt_cache.gpop : tuxtxt_cache.pop, subp, packet, triplet, high, &APx, &APy, &APx0, &APy0, page_char,page_atrb);
+
+				}
+
+			}
+			else if (iAddress & 0x08)	/* local: eval invoked object */
+			{
+				unsigned char APx = 0, APy = 0;
+				unsigned char APx0 = *pAPx0 + *pAPx + tuxtxt_cache.tAPx, APy0 = *pAPy0 + *pAPy + tuxtxt_cache.tAPy;
+				int descode = ((iAddress & 0x01) << 3) | (iData >> 4);
+				int triplet = iData & 0x0f;
+
+				if (APx0 < 40) /* not in side panel */
+				{
+
+					tuxtxt_eval_object(13 * 23 + 13 * descode + triplet, pstCachedPage, &APx, &APy, &APx0, &APy0, (tObjType)(triplet % 3), pagedata, page_char, page_atrb);
+
+				}
+
+			}
+			break;
+		case 0x15:
+		case 0x16:
+		case 0x17:
+			if (0 == (iAddress & 0x08))	/* Object Definition illegal or only level 3.5 */
+				break; /* ignore */
+
+			tuxtxt_cache.tAPx = tuxtxt_cache.tAPy = 0;
+			*endcol = -1;
+			return 0xFF; /* termination by object definition */
+			break;
+		case 0x18:
+			if (0 == (iData & 0x10)) /* DRCS Mode reserved or only level 3.5 */
+				break; /* ignore */
+
+			if (iData & 0x40)
+				*drcssubp = iData & 0x0f;
+			else
+				*gdrcssubp = iData & 0x0f;
+			break;
+		case 0x1f:
+
+			tuxtxt_cache.tAPx = tuxtxt_cache.tAPy = 0;
+			*endcol = -1;
+			return 0x80 | iData; /* explicit termination */
+			break;
+		default:
+			break; /* unsupported or not yet implemented mode: ignore */
+		} /* switch (iMode) */
+	} /* (iAddress >= 40): row addresses */
+
+	if (iAddress < 40 || iMode != 0x10) /* leave temp. AP-Offset unchanged only immediately after definition */
+		tuxtxt_cache.tAPx = tuxtxt_cache.tAPy = 0;
+
+
+	return 0; /* normal exit, no termination */
+}
+#endif
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.conf enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.conf
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.conf	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.conf	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,5 @@
+ScreenMode16x9Normal 0
+ScreenMode16x9Divided 0
+ColorDimmed 1
+AutoNational 1
+NationalSubset 4
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_def.h enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_def.h
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_def.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt_def.h	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,644 @@
+/******************************************************************************
+ * definitions for plugin and lib                                             *
+ ******************************************************************************/
+#ifndef TUXTXT_DEF_H
+#define TUXTXT_DEF_H
+
+#ifdef HAVE_DREAMBOX_HARDWARE
+ #define TUXTXT_COMPRESS 1 // compress page data: 0 no compression, 1 with zlib, 2 with own algorithm
+#else
+ #define TUXTXT_COMPRESS 2
+#endif
+
+#include <linux/dvb/dmx.h>
+
+#define DMX "/dev/dvb/adapter0/demux0"
+
+#define FLOFSIZE 4
+
+#define PAGESIZE (40*25)
+
+/* spacing attributes */
+#define alpha_black         0x00
+#define alpha_red           0x01
+#define alpha_green         0x02
+#define alpha_yellow        0x03
+#define alpha_blue          0x04
+#define alpha_magenta       0x05
+#define alpha_cyan          0x06
+#define alpha_white         0x07
+#define flash               0x08
+#define steady              0x09
+#define end_box             0x0A
+#define start_box           0x0B
+#define normal_size         0x0C
+#define double_height       0x0D
+#define double_width        0x0E
+#define double_size         0x0F
+#define mosaic_black        0x10
+#define mosaic_red          0x11
+#define mosaic_green        0x12
+#define mosaic_yellow       0x13
+#define mosaic_blue         0x14
+#define mosaic_magenta      0x15
+#define mosaic_cyan         0x16
+#define mosaic_white        0x17
+#define conceal             0x18
+#define contiguous_mosaic   0x19
+#define separated_mosaic    0x1A
+#define esc                 0x1B
+#define black_background    0x1C
+#define new_background      0x1D
+#define hold_mosaic         0x1E
+#define release_mosaic      0x1F
+
+char dumpl25;
+
+typedef enum /* object type */
+{
+	OBJ_PASSIVE,
+	OBJ_ACTIVE,
+	OBJ_ADAPTIVE
+} tObjType;
+
+const char *ObjectSource[] =
+{
+	"(illegal)",
+	"Local",
+	"POP",
+	"GPOP"
+};
+const char *ObjectType[] =
+{
+	"Passive",
+	"Active",
+	"Adaptive",
+	"Passive"
+};
+
+enum
+{
+	NAT_DEFAULT = 0,
+	NAT_CZ = 1,
+	NAT_UK = 2,
+	NAT_ET = 3,
+	NAT_FR = 4,
+	NAT_DE = 5,
+	NAT_IT = 6,
+	NAT_LV = 7,
+	NAT_PL = 8,
+	NAT_SP = 9,
+	NAT_RO = 10,
+	NAT_SR = 11,
+	NAT_SW = 12,
+	NAT_TR = 13,
+	NAT_MAX_FROM_HEADER = 13,
+	NAT_RU = 14,
+	NAT_GR = 15
+};
+const unsigned char countryconversiontable[] = { NAT_UK, NAT_DE, NAT_SW, NAT_IT, NAT_FR, NAT_SP, NAT_CZ, NAT_RO};
+/* tables for color table remapping, first entry (no remapping) skipped, offsets for color index */
+const unsigned char MapTblFG[] = {  0,  0,  8,  8, 16, 16, 16 };
+const unsigned char MapTblBG[] = {  8, 16,  8, 16,  8, 16, 24 };
+
+/* colortable */
+enum
+{
+	black = 0,
+	red, /* 1 */
+	green, /* 2 */
+	yellow, /* 3 */
+	blue,	/* 4 */
+	magenta,	/* 5 */
+	cyan,	/* 6 */
+	white, /* 7 */
+	menu1 = (4*8),
+	menu2,
+	menu3,
+	transp,
+	transp2,
+	SIZECOLTABLE
+};
+
+enum /* options for charset */
+{
+	C_G0P = 0, /* primary G0 */
+	C_G0S, /* secondary G0 */
+	C_G1C, /* G1 contiguous */
+	C_G1S, /* G1 separate */
+	C_G2,
+	C_G3,
+	C_OFFSET_DRCS = 32
+	/* 32..47: 32+subpage# GDRCS (offset/20 in page_char) */
+	/* 48..63: 48+subpage#  DRCS (offset/20 in page_char) */
+};
+
+enum /* page function */
+{
+	FUNC_LOP = 0, /* Basic Level 1 Teletext page (LOP) */
+	FUNC_DATA, /* Data broadcasting page coded according to EN 300 708 [2] clause 4 */
+	FUNC_GPOP, /* Global Object definition page (GPOP) - (see clause 10.5.1) */
+	FUNC_POP, /* Normal Object definition page (POP) - (see clause 10.5.1) */
+	FUNC_GDRCS, /* Global DRCS downloading page (GDRCS) - (see clause 10.5.2) */
+	FUNC_DRCS, /* Normal DRCS downloading page (DRCS) - (see clause 10.5.2) */
+	FUNC_MOT, /* Magazine Organization table (MOT) - (see clause 10.6) */
+	FUNC_MIP, /* Magazine Inventory page (MIP) - (see clause 11.3) */
+	FUNC_BTT, /* Basic TOP table (BTT) } */
+	FUNC_AIT, /* Additional Information Table (AIT) } (see clause 11.2) */
+	FUNC_MPT, /* Multi-page table (MPT) } */
+	FUNC_MPTEX, /* Multi-page extension table (MPT-EX) } */
+	FUNC_TRIGGER /* Page contain trigger messages defined according to [8] */
+};
+/* struct for page attributes */
+typedef struct
+{
+	unsigned char fg      :6; /* foreground color */
+	unsigned char bg      :6; /* background color */
+	unsigned char charset :6; /* see enum above */
+	unsigned char doubleh :1; /* double height */
+	unsigned char doublew :1; /* double width */
+	/* ignore at Black Background Color Substitution */
+	/* black background set by New Background ($1d) instead of start-of-row default or Black Backgr. ($1c) */
+	/* or black background set by level 2.5 extensions */
+	unsigned char IgnoreAtBlackBgSubst:1;
+	unsigned char concealed:1; /* concealed information */
+	unsigned char inverted :1; /* colors inverted */
+	unsigned char flashing :5; /* flash mode */
+	unsigned char diacrit  :4; /* diacritical mark */
+	unsigned char underline:1; /* Text underlined */
+	unsigned char boxwin   :1; /* Text boxed/windowed */
+	unsigned char setX26   :1; /* Char is set by packet X/26 (no national subset used) */
+	unsigned char setG0G2  :7; /* G0+G2 set designation  */
+} tstPageAttr;
+
+
+/* struct for (G)POP/(G)DRCS links for level 2.5, allocated at reception of p27/4 or /5, initialized with 0 after allocation */
+typedef struct
+{
+	short page; /* linked page number */
+	unsigned short subpage; /* 1 bit for each needed (1) subpage */
+	unsigned char l25:1; /* 1: page required at level 2.5 */
+	unsigned char l35:1; /* 1: page required at level 3.5 */
+	unsigned char drcs:1; /* 1: link to (G)DRCS, 0: (G)POP */
+	unsigned char local:1; /* 1: global (G*), 0: local */
+} tstp27;
+
+/* struct for extension data for level 2.5, allocated at reception, initialized with 0 after allocation */
+typedef struct
+{
+	unsigned char *p26[16]; /* array of pointers to max. 16 designation codes of packet 26 */
+	tstp27 *p27; /* array of 4 structs for (G)POP/(G)DRCS links for level 2.5 */
+	unsigned short bgr[16]; /* CLUT 2+3, 2*8 colors, 0x0bgr */
+	unsigned char DefaultCharset:7; /* default G0/G2 charset + national option */
+	unsigned char LSP:1; /* 1: left side panel to be displayed */
+	unsigned char SecondCharset:7; /* second G0 charset */
+	unsigned char RSP:1; /* 1: right side panel to be displayed */
+	unsigned char DefScreenColor:5; /* default screen color (above and below lines 0..24) */
+	unsigned char ColorTableRemapping:3; /* 1: index in table of CLUTs to use */
+	unsigned char DefRowColor:5; /* default row color (left and right to lines 0..24) */
+	unsigned char BlackBgSubst:1; /* 1: substitute black background (as result of start-of-line or 1c, not 00/10+1d) */
+	unsigned char SPL25:1; /* 1: side panel required at level 2.5 */
+	unsigned char p28Received:1; /* 1: extension data valid (p28/0 received) */
+	unsigned char LSPColumns:4; /* number of columns in left side panel, 0->16, rsp=16-lsp */
+} tstExtData;
+
+
+/* struct for pageinfo, max. 16 Bytes, at beginning of each cached page buffer, initialized with 0 after allocation */
+typedef struct
+{
+	unsigned char *p24; /* pointer to lines 25+26 (packets 24+25) (2*40 bytes) for FLOF or level 2.5 data */
+	tstExtData *ext; /* pointer to array[16] of data for level 2.5 */
+	unsigned char boxed         :1; /* p0: boxed (newsflash or subtitle) */
+	unsigned char nationalvalid :1; /* p0: national option character subset is valid (no biterror detected) */
+	unsigned char national      :3; /* p0: national option character subset */
+	unsigned char function      :3; /* p28/0: page function */
+} tstPageinfo;
+
+/* one cached page: struct for pageinfo, 24 lines page data */
+typedef struct
+{
+	tstPageinfo pageinfo;
+	unsigned char p0[24]; /* packet 0: center of headline */
+#if TUXTXT_COMPRESS == 1
+	unsigned char * pData;/* packet 1-23 */
+	unsigned short ziplen;
+#elif TUXTXT_COMPRESS == 2
+	unsigned char * pData;/* packet 1-23 */
+	unsigned char bitmask[23*5];
+#else
+	unsigned char data[23*40];	/* packet 1-23 */
+#endif
+} tstCachedPage;
+
+/* main data structure */
+typedef struct
+{
+	short flofpages[0x900][FLOFSIZE];
+	unsigned char adip[0x900][13];
+	unsigned char subpagetable[0x900];
+	int dmx;
+	int vtxtpid;
+	int cached_pages, page, subpage, pageupdate,page_receiving, current_page[9], current_subpage[9];
+	int receiving, thread_starting, zap_subpage_manual;
+	char bttok;
+	int adippg[10];
+	int maxadippg;
+	unsigned char basictop[0x900];
+
+	unsigned char  timestring[8];
+	/* cachetable for packets 29 (one for each magazine) */
+	tstExtData *astP29[9];
+	/* cachetable */
+	tstCachedPage *astCachetable[0x900][0x80];
+	pthread_t thread_id;
+	void *thread_result;
+	unsigned char FullRowColor[25];
+	unsigned char FullScrColor;
+	unsigned char tAPx, tAPy;	/* temporary offset to Active Position for objects */
+	short pop, gpop, drcs, gdrcs;
+	int national_subset, national_subset_secondary;
+	unsigned short *colortable;
+} tuxtxt_cache_struct;
+
+typedef struct
+{
+	unsigned char* page_char; // Character array (25*40) of decoded page
+	tstPageAttr* page_atrb;   // Attributes Array (25*40) of decoded page
+	int col;                  // current column (0..39 )
+	int row;                  // current row (0..23)
+	tstPageinfo* pageinfo;    // pageinfo of decoded page
+	unsigned short cstyles_n[1024];
+	unsigned short cstyles_d[1024];
+	unsigned short cstyles_g[32];
+	unsigned short cstyles_b[32];
+	unsigned short stylecount_n;
+	unsigned short stylecount_d;
+	unsigned short stylecount_g;
+	unsigned short stylecount_b;	
+} tstHTML;
+
+// G2 Charset (0 = Latin, 1 = Cyrillic, 2 = Greek)
+const unsigned short int G2table[3][6*16] =
+{
+	{ ' ' ,'' ,'' ,'' ,'$' ,'' ,'#' ,'' ,'' ,'\'','\"','' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'' ,'' ,'' ,'' ,'\'','\"','' ,'' ,'' ,'' ,'' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,' ' ,' ' ,' ' ,8539,8540,8541,8542,
+	  937 ,'' ,272 ,'' ,294 ,' ' ,306 ,319 ,321 ,'' ,338 ,'' ,'' ,358 ,330 ,329 ,
+	  1082,'' ,273 ,'' ,295 ,305 ,307 ,320 ,322 ,'' ,339 ,'' ,'' ,359 ,951 ,0x7F},
+	{ ' ' ,'' ,'' ,'' ,'$' ,'' ,' ' ,'' ,' ' ,'\'','\"','' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'' ,'' ,'' ,'' ,'\'','\"','' ,'' ,'' ,'' ,'' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,321 ,322 ,'' ,8539,8540,8541,8542,
+	  'D' ,'E' ,'F' ,'G' ,'I' ,'J' ,'K' ,'L' ,'N' ,'Q' ,'R' ,'S' ,'U' ,'V' ,'W' ,'Z' ,
+	  'd' ,'e' ,'f' ,'g' ,'i' ,'j' ,'k' ,'l' ,'n' ,'q' ,'r' ,'s' ,'u' ,'v' ,'w' ,'z' },
+	{ ' ' ,'a' ,'b' ,'' ,'e' ,'h' ,'i' ,'' ,':' ,'\'','\"','k' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'m' ,'n' ,'p' ,'' ,'\'','\"','t' ,'' ,'' ,'' ,'x' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '?' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,906 ,910 ,911 ,8539,8540,8541,8542,
+	  'C' ,'D' ,'F' ,'G' ,'J' ,'L' ,'Q' ,'R' ,'S' ,'U' ,'V' ,'W' ,'Y' ,'Z' ,902 ,905 ,
+	  'c' ,'d' ,'f' ,'g' ,'j' ,'l' ,'q' ,'r' ,'s' ,'u' ,'v' ,'w' ,'y' ,'z' ,904 ,0x7F}
+};
+// cyrillic G0 Charset
+// TODO: different maps for serbian/russian/ukrainian
+const unsigned short int G0tablecyrillic[6*16] =
+{
+	  ' ' ,'!' ,'\"','#' ,'$' ,'%' ,'&' ,'\'','(' ,')' ,'*' ,'+' ,',' ,'-' ,'.' ,'/' ,
+	  '0' ,'1' ,'2' ,'3' ,'4' ,'5' ,'6' ,'7' ,'8' ,'9' ,':' ,';' ,'<' ,'=' ,'>' ,'?' ,
+	  1063,1040,1041,1062,1044,1045,1060,1043,1061,1048,1032,1050,1051,1052,1053,1054,
+	  1055,1036,1056,1057,1058,1059,1042,1027,1033,1034,1047,1035,1046,1026,1064,1119,
+	  1095,1072,1073,1094,1076,1077,1092,1075,1093,1080,1112,1082,1083,1084,1085,1086,
+	  1087,1116,1088,1089,1090,1091,1074,1107,1113,1114,1079,1115,1078,1106,1096,0x7F
+};
+
+const unsigned short int nationaltable23[14][2] =
+{
+	{ '#', '' }, /* 0          */
+	{ '#', 367 }, /* 1  CS/SK   */
+	{ '', '$' }, /* 2    EN    */
+	{ '#', '' }, /* 3    ET    */
+	{ '', '' }, /* 4    FR    */
+	{ '#', '$' }, /* 5    DE    */
+	{ '', '$' }, /* 6    IT    */
+	{ '#', '$' }, /* 7  LV/LT   */
+	{ '#', 329 }, /* 8    PL    */
+	{ '', '$' }, /* 9  PT/ES   */
+	{ '#', '' }, /* A    RO    */
+	{ '#', '' }, /* B SR/HR/SL */
+	{ '#', '' }, /* C SV/FI/HU */
+	{ '', 287 }, /* D    TR   ? */
+};
+const unsigned short int nationaltable40[14] =
+{
+	'@', /* 0          */
+	269, /* 1  CS/SK   */
+	'@', /* 2    EN    */
+	352, /* 3    ET    */
+	'', /* 4    FR    */
+	'', /* 5    DE    */
+	'', /* 6    IT    */
+	352, /* 7  LV/LT   */
+	261, /* 8    PL    */
+	'', /* 9  PT/ES   */
+	354, /* A    RO    */
+	268, /* B SR/HR/SL */
+	'', /* C SV/FI/HU */
+	304, /* D    TR    */
+};
+const unsigned short int nationaltable5b[14][6] =
+{
+	{ '[','\\', ']', '^', '_', '`' }, /* 0          */
+	{ 357, 382, '', '', 345, '' }, /* 1  CS/SK   */
+	{8592, '',8594,8593, '#', 173 }, /* 2    EN    */
+	{ '', '', 381, '', '', 353 }, /* 3    ET    */
+	{ '', '', '', '', '#', '' }, /* 4    FR    */
+	{ '', '', '', '^', '_', '' }, /* 5    DE    */
+	{ '', '',8594,8593, '#', '' }, /* 6    IT    */
+	{ '', 553, 381, 269, 363, 353 }, /* 7  LV/LT   */
+	{ 437, 346, 321, 263, '', 281 }, /* 8    PL    */
+	{ '', '', '', '', '', '' }, /* 9  PT/ES   */
+	{ '', 350, 461, '', 305, 355 }, /* A    RO    */
+	{ 262, 381, 272, 352, '', 269 }, /* B SR/HR/SL */
+	{ '', '', '', '', '_', '' }, /* C SV/FI/HU */
+	{ 350, '', '', '', 486, 305 }, /* D    TR    */
+};
+const unsigned short int nationaltable7b[14][4] =
+{
+	{ '{', '|', '}', '~' }, /* 0          */
+	{ '', 283, '', 353 }, /* 1  CS/SK   */
+	{ '',8214, '', '' }, /* 2    EN    */
+	{ '', '', 382, '' }, /* 3    ET    */
+	{ '', '', '', '' }, /* 4    FR    */
+	{ '', '', '', '' }, /* 5    DE    */
+	{ '', '', '', '' }, /* 6    IT    */
+	{ 261, 371, 382, 303 }, /* 7  LV/LT   */
+	{ 380, 347, 322, 378 }, /* 8    PL    */
+	{ '', '', '', '' }, /* 9  PT/ES   */
+	{ '', 351, 462, '' }, /* A    RO    */
+	{ 263, 382, 273, 353 }, /* B SR/HR/SL */
+	{ '', '', '', '' }, /* C SV/FI/HU */
+	{ 351, '', 231, '' }, /* D    TR    */
+};
+const unsigned short int arrowtable[] =
+{
+	8592, 8594, 8593, 8595, 'O', 'K', 8592, 8592
+};
+
+/* hamming table */
+const unsigned char dehamming[] =
+{
+	0x01, 0xFF, 0x01, 0x01, 0xFF, 0x00, 0x01, 0xFF, 0xFF, 0x02, 0x01, 0xFF, 0x0A, 0xFF, 0xFF, 0x07,
+	0xFF, 0x00, 0x01, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x06, 0xFF, 0xFF, 0x0B, 0xFF, 0x00, 0x03, 0xFF,
+	0xFF, 0x0C, 0x01, 0xFF, 0x04, 0xFF, 0xFF, 0x07, 0x06, 0xFF, 0xFF, 0x07, 0xFF, 0x07, 0x07, 0x07,
+	0x06, 0xFF, 0xFF, 0x05, 0xFF, 0x00, 0x0D, 0xFF, 0x06, 0x06, 0x06, 0xFF, 0x06, 0xFF, 0xFF, 0x07,
+	0xFF, 0x02, 0x01, 0xFF, 0x04, 0xFF, 0xFF, 0x09, 0x02, 0x02, 0xFF, 0x02, 0xFF, 0x02, 0x03, 0xFF,
+	0x08, 0xFF, 0xFF, 0x05, 0xFF, 0x00, 0x03, 0xFF, 0xFF, 0x02, 0x03, 0xFF, 0x03, 0xFF, 0x03, 0x03,
+	0x04, 0xFF, 0xFF, 0x05, 0x04, 0x04, 0x04, 0xFF, 0xFF, 0x02, 0x0F, 0xFF, 0x04, 0xFF, 0xFF, 0x07,
+	0xFF, 0x05, 0x05, 0x05, 0x04, 0xFF, 0xFF, 0x05, 0x06, 0xFF, 0xFF, 0x05, 0xFF, 0x0E, 0x03, 0xFF,
+	0xFF, 0x0C, 0x01, 0xFF, 0x0A, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0A, 0x0A, 0x0A, 0xFF,
+	0x08, 0xFF, 0xFF, 0x0B, 0xFF, 0x00, 0x0D, 0xFF, 0xFF, 0x0B, 0x0B, 0x0B, 0x0A, 0xFF, 0xFF, 0x0B,
+	0x0C, 0x0C, 0xFF, 0x0C, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0C, 0x0F, 0xFF, 0x0A, 0xFF, 0xFF, 0x07,
+	0xFF, 0x0C, 0x0D, 0xFF, 0x0D, 0xFF, 0x0D, 0x0D, 0x06, 0xFF, 0xFF, 0x0B, 0xFF, 0x0E, 0x0D, 0xFF,
+	0x08, 0xFF, 0xFF, 0x09, 0xFF, 0x09, 0x09, 0x09, 0xFF, 0x02, 0x0F, 0xFF, 0x0A, 0xFF, 0xFF, 0x09,
+	0x08, 0x08, 0x08, 0xFF, 0x08, 0xFF, 0xFF, 0x09, 0x08, 0xFF, 0xFF, 0x0B, 0xFF, 0x0E, 0x03, 0xFF,
+	0xFF, 0x0C, 0x0F, 0xFF, 0x04, 0xFF, 0xFF, 0x09, 0x0F, 0xFF, 0x0F, 0x0F, 0xFF, 0x0E, 0x0F, 0xFF,
+	0x08, 0xFF, 0xFF, 0x05, 0xFF, 0x0E, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0x0E, 0x0E, 0xFF, 0x0E
+};
+
+/* odd parity table, error=0x20 (space) */
+const unsigned char deparity[] =
+{
+	' ' , 0x01, 0x02, ' ' , 0x04, ' ' , ' ' , 0x07, 0x08, ' ' , ' ' , 0x0b, ' ' , 0x0d, 0x0e, ' ' ,
+	0x10, ' ' , ' ' , 0x13, ' ' , 0x15, 0x16, ' ' , ' ' , 0x19, 0x1a, ' ' , 0x1c, ' ' , ' ' , 0x1f,
+	0x20, ' ' , ' ' , 0x23, ' ' , 0x25, 0x26, ' ' , ' ' , 0x29, 0x2a, ' ' , 0x2c, ' ' , ' ' , 0x2f,
+	' ' , 0x31, 0x32, ' ' , 0x34, ' ' , ' ' , 0x37, 0x38, ' ' , ' ' , 0x3b, ' ' , 0x3d, 0x3e, ' ' ,
+	0x40, ' ' , ' ' , 0x43, ' ' , 0x45, 0x46, ' ' , ' ' , 0x49, 0x4a, ' ' , 0x4c, ' ' , ' ' , 0x4f,
+	' ' , 0x51, 0x52, ' ' , 0x54, ' ' , ' ' , 0x57, 0x58, ' ' , ' ' , 0x5b, ' ' , 0x5d, 0x5e, ' ' ,
+	' ' , 0x61, 0x62, ' ' , 0x64, ' ' , ' ' , 0x67, 0x68, ' ' , ' ' , 0x6b, ' ' , 0x6d, 0x6e, ' ' ,
+	0x70, ' ' , ' ' , 0x73, ' ' , 0x75, 0x76, ' ' , ' ' , 0x79, 0x7a, ' ' , 0x7c, ' ' , ' ' , 0x7f,
+	0x00, ' ' , ' ' , 0x03, ' ' , 0x05, 0x06, ' ' , ' ' , 0x09, 0x0a, ' ' , 0x0c, ' ' , ' ' , 0x0f,
+	' ' , 0x11, 0x12, ' ' , 0x14, ' ' , ' ' , 0x17, 0x18, ' ' , ' ' , 0x1b, ' ' , 0x1d, 0x1e, ' ' ,
+	' ' , 0x21, 0x22, ' ' , 0x24, ' ' , ' ' , 0x27, 0x28, ' ' , ' ' , 0x2b, ' ' , 0x2d, 0x2e, ' ' ,
+	0x30, ' ' , ' ' , 0x33, ' ' , 0x35, 0x36, ' ' , ' ' , 0x39, 0x3a, ' ' , 0x3c, ' ' , ' ' , 0x3f,
+	' ' , 0x41, 0x42, ' ' , 0x44, ' ' , ' ' , 0x47, 0x48, ' ' , ' ' , 0x4b, ' ' , 0x4d, 0x4e, ' ' ,
+	0x50, ' ' , ' ' , 0x53, ' ' , 0x55, 0x56, ' ' , ' ' , 0x59, 0x5a, ' ' , 0x5c, ' ' , ' ' , 0x5f,
+	0x60, ' ' , ' ' , 0x63, ' ' , 0x65, 0x66, ' ' , ' ' , 0x69, 0x6a, ' ' , 0x6c, ' ' , ' ' , 0x6f,
+	' ' , 0x71, 0x72, ' ' , 0x74, ' ' , ' ' , 0x77, 0x78, ' ' , ' ' , 0x7b, ' ' , 0x7d, 0x7e, ' ' ,
+};
+
+#if 1	/* lookup-table algorithm for decoding Hamming 24/18, credits to: */
+/*
+ *  libzvbi - Error correction functions
+ *
+ *  Copyright (C) 2001 Michael H. Schimek
+ *
+ *  Based on code from AleVT 1.5.1
+ *  Copyright (C) 1998, 1999 Edgar Toernig <froese@gmx.de>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/*
+ *  [AleVT]
+ *
+ *  This table generates the parity checks for hamm24/18 decoding.
+ *  Bit 0 is for test A, 1 for B, ...
+ *
+ *  Thanks to R. Gancarz for this fine table *g*
+ */
+const unsigned char hamm24par[3][256] = {
+    {
+        /* Parities of first byte */
+	 0, 33, 34,  3, 35,  2,  1, 32, 36,  5,  6, 39,  7, 38, 37,  4,
+	37,  4,  7, 38,  6, 39, 36,  5,  1, 32, 35,  2, 34,  3,  0, 33,
+	38,  7,  4, 37,  5, 36, 39,  6,  2, 35, 32,  1, 33,  0,  3, 34,
+	 3, 34, 33,  0, 32,  1,  2, 35, 39,  6,  5, 36,  4, 37, 38,  7,
+	39,  6,  5, 36,  4, 37, 38,  7,  3, 34, 33,  0, 32,  1,  2, 35,
+	 2, 35, 32,  1, 33,  0,  3, 34, 38,  7,  4, 37,  5, 36, 39,  6,
+	 1, 32, 35,  2, 34,  3,  0, 33, 37,  4,  7, 38,  6, 39, 36,  5,
+	36,  5,  6, 39,  7, 38, 37,  4,  0, 33, 34,  3, 35,  2,  1, 32,
+	40,  9, 10, 43, 11, 42, 41,  8, 12, 45, 46, 15, 47, 14, 13, 44,
+	13, 44, 47, 14, 46, 15, 12, 45, 41,  8, 11, 42, 10, 43, 40,  9,
+	14, 47, 44, 13, 45, 12, 15, 46, 42, 11,  8, 41,  9, 40, 43, 10,
+	43, 10,  9, 40,  8, 41, 42, 11, 15, 46, 45, 12, 44, 13, 14, 47,
+	15, 46, 45, 12, 44, 13, 14, 47, 43, 10,  9, 40,  8, 41, 42, 11,
+	42, 11,  8, 41,  9, 40, 43, 10, 14, 47, 44, 13, 45, 12, 15, 46,
+	41,  8, 11, 42, 10, 43, 40,  9, 13, 44, 47, 14, 46, 15, 12, 45,
+	12, 45, 46, 15, 47, 14, 13, 44, 40,  9, 10, 43, 11, 42, 41,  8
+    }, {
+        /* Parities of second byte */
+	 0, 41, 42,  3, 43,  2,  1, 40, 44,  5,  6, 47,  7, 46, 45,  4,
+	45,  4,  7, 46,  6, 47, 44,  5,  1, 40, 43,  2, 42,  3,  0, 41,
+	46,  7,  4, 45,  5, 44, 47,  6,  2, 43, 40,  1, 41,  0,  3, 42,
+	 3, 42, 41,  0, 40,  1,  2, 43, 47,  6,  5, 44,  4, 45, 46,  7,
+	47,  6,  5, 44,  4, 45, 46,  7,  3, 42, 41,  0, 40,  1,  2, 43,
+	 2, 43, 40,  1, 41,  0,  3, 42, 46,  7,  4, 45,  5, 44, 47,  6,
+	 1, 40, 43,  2, 42,  3,  0, 41, 45,  4,  7, 46,  6, 47, 44,  5,
+	44,  5,  6, 47,  7, 46, 45,  4,  0, 41, 42,  3, 43,  2,  1, 40,
+	48, 25, 26, 51, 27, 50, 49, 24, 28, 53, 54, 31, 55, 30, 29, 52,
+	29, 52, 55, 30, 54, 31, 28, 53, 49, 24, 27, 50, 26, 51, 48, 25,
+	30, 55, 52, 29, 53, 28, 31, 54, 50, 27, 24, 49, 25, 48, 51, 26,
+	51, 26, 25, 48, 24, 49, 50, 27, 31, 54, 53, 28, 52, 29, 30, 55,
+	31, 54, 53, 28, 52, 29, 30, 55, 51, 26, 25, 48, 24, 49, 50, 27,
+	50, 27, 24, 49, 25, 48, 51, 26, 30, 55, 52, 29, 53, 28, 31, 54,
+	49, 24, 27, 50, 26, 51, 48, 25, 29, 52, 55, 30, 54, 31, 28, 53,
+	28, 53, 54, 31, 55, 30, 29, 52, 48, 25, 26, 51, 27, 50, 49, 24
+    }, {
+        /* Parities of third byte */
+	63, 14, 13, 60, 12, 61, 62, 15, 11, 58, 57,  8, 56,  9, 10, 59,
+	10, 59, 56,  9, 57,  8, 11, 58, 62, 15, 12, 61, 13, 60, 63, 14,
+	 9, 56, 59, 10, 58, 11,  8, 57, 61, 12, 15, 62, 14, 63, 60, 13,
+	60, 13, 14, 63, 15, 62, 61, 12,  8, 57, 58, 11, 59, 10,  9, 56,
+	 8, 57, 58, 11, 59, 10,  9, 56, 60, 13, 14, 63, 15, 62, 61, 12,
+	61, 12, 15, 62, 14, 63, 60, 13,  9, 56, 59, 10, 58, 11,  8, 57,
+	62, 15, 12, 61, 13, 60, 63, 14, 10, 59, 56,  9, 57,  8, 11, 58,
+	11, 58, 57,  8, 56,  9, 10, 59, 63, 14, 13, 60, 12, 61, 62, 15,
+	31, 46, 45, 28, 44, 29, 30, 47, 43, 26, 25, 40, 24, 41, 42, 27,
+	42, 27, 24, 41, 25, 40, 43, 26, 30, 47, 44, 29, 45, 28, 31, 46,
+	41, 24, 27, 42, 26, 43, 40, 25, 29, 44, 47, 30, 46, 31, 28, 45,
+	28, 45, 46, 31, 47, 30, 29, 44, 40, 25, 26, 43, 27, 42, 41, 24,
+	40, 25, 26, 43, 27, 42, 41, 24, 28, 45, 46, 31, 47, 30, 29, 44,
+	29, 44, 47, 30, 46, 31, 28, 45, 41, 24, 27, 42, 26, 43, 40, 25,
+	30, 47, 44, 29, 45, 28, 31, 46, 42, 27, 24, 41, 25, 40, 43, 26,
+	43, 26, 25, 40, 24, 41, 42, 27, 31, 46, 45, 28, 44, 29, 30, 47
+    }
+};
+
+/*
+ *  [AleVT]
+ *
+ *  Table to extract the lower 4 bit from hamm24/18 encoded bytes
+ */
+const unsigned char hamm24val[256] = {
+      0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,
+      2,  2,  2,  2,  3,  3,  3,  3,  2,  2,  2,  2,  3,  3,  3,  3,
+      4,  4,  4,  4,  5,  5,  5,  5,  4,  4,  4,  4,  5,  5,  5,  5,
+      6,  6,  6,  6,  7,  7,  7,  7,  6,  6,  6,  6,  7,  7,  7,  7,
+      8,  8,  8,  8,  9,  9,  9,  9,  8,  8,  8,  8,  9,  9,  9,  9,
+     10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 11, 11, 11, 11,
+     12, 12, 12, 12, 13, 13, 13, 13, 12, 12, 12, 12, 13, 13, 13, 13,
+     14, 14, 14, 14, 15, 15, 15, 15, 14, 14, 14, 14, 15, 15, 15, 15,
+      0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,
+      2,  2,  2,  2,  3,  3,  3,  3,  2,  2,  2,  2,  3,  3,  3,  3,
+      4,  4,  4,  4,  5,  5,  5,  5,  4,  4,  4,  4,  5,  5,  5,  5,
+      6,  6,  6,  6,  7,  7,  7,  7,  6,  6,  6,  6,  7,  7,  7,  7,
+      8,  8,  8,  8,  9,  9,  9,  9,  8,  8,  8,  8,  9,  9,  9,  9,
+     10, 10, 10, 10, 11, 11, 11, 11, 10, 10, 10, 10, 11, 11, 11, 11,
+     12, 12, 12, 12, 13, 13, 13, 13, 12, 12, 12, 12, 13, 13, 13, 13,
+     14, 14, 14, 14, 15, 15, 15, 15, 14, 14, 14, 14, 15, 15, 15, 15
+};
+
+const signed char hamm24err[64] = {
+     0, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
+    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
+     0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,   0,  0,  0,  0,
+     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1,  -1, -1, -1, -1,
+};
+
+/*
+ *  [AleVT]
+ *
+ *  Mapping from parity checks made by table hamm24par to faulty bit
+ *  in the decoded 18 bit word.
+ */
+const unsigned int hamm24cor[64] = {
+    0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
+    0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
+    0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
+    0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
+    0x00000, 0x00000, 0x00000, 0x00001, 0x00000, 0x00002, 0x00004, 0x00008,
+    0x00000, 0x00010, 0x00020, 0x00040, 0x00080, 0x00100, 0x00200, 0x00400,
+    0x00000, 0x00800, 0x01000, 0x02000, 0x04000, 0x08000, 0x10000, 0x20000,
+    0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000,
+};
+
+/**
+ * @internal
+ * @param p Pointer to a byte triplet, bytes in transmission order,
+ *   lsb first transmitted.
+ *
+ * This function decodes a Hamming 24/18 protected byte triplet
+ * as specified in ETS 300 706 8.3.
+ *
+ * @return
+ * Triplet data bits D18 [msb] ... D1 [lsb] or a negative
+ * value if the triplet contained incorrectable errors.
+ */
+signed int deh24(unsigned char *p)
+{
+	int e = hamm24par[0][p[0]]
+		^ hamm24par[1][p[1]]
+		^ hamm24par[2][p[2]];
+
+	int x = hamm24val[p[0]]
+		+ (p[1] & 127) * 16
+		+ (p[2] & 127) * 2048;
+
+	return (x ^ hamm24cor[e]) | hamm24err[e];
+}
+
+#else	 /* my (rm) slower but smaller solution without lookup tables */
+
+/* calc parity */
+int parity(int c)
+{
+	int n = 0;
+	for (; c; c &= (c-1)) /* reset least significant set bit */
+		n ^= 1;
+	return n;
+}
+
+#if 0	/* just for testing */
+/* encode hamming 24/18 */
+unsigned int ham24(unsigned int val)
+{
+	val = ((val & 0x000001) << 2) |
+		((val & 0x00000e) << 3) |
+		((val & 0x0007f0) << 4) |
+		((val & 0x03f800) << 5);
+	val |= parity(val & 0x555554);
+	val |= parity(val & 0x666664) << 1;
+	val |= parity(val & 0x787870) << 3;
+	val |= parity(val & 0x007f00) << 7;
+	val |= parity(val & 0x7f0000) << 15;
+	val |= parity(val) << 23;
+	return val;
+}
+#endif
+
+/* decode hamming 24/18, error=-1 */
+signed int deh24(unsigned char *ph24)
+{
+	int h24 = *ph24 | (*(ph24+1)<<8) | (*(ph24+2)<<16);
+	int a = parity(h24 & 0x555555);
+	int f = parity(h24 & 0xaaaaaa) ^ a;
+	a |= (parity(h24 & 0x666666) << 1) |
+		(parity(h24 & 0x787878) << 2) |
+		(parity(h24 & 0x007f80) << 3) |
+		(parity(h24 & 0x7f8000) << 4);
+	if (a != 0x1f)
+	{
+		if (f) /* 2 biterrors */
+			return -1;
+		else /* correct 1 biterror */
+			h24 ^= (1 << ((a ^ 0x1f)-1));
+	}
+	return
+		((h24 & 0x000004) >> 2) |
+		((h24 & 0x000070) >> 3) |
+		((h24 & 0x007f00) >> 4) |
+		((h24 & 0x7f0000) >> 5);
+}
+#endif /* table or serial */
+#endif
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.h enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.h
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.h	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Tuxtxt/tuxtxt/tuxtxt.h	2009-12-11 21:40:12.000000000 +0100
@@ -0,0 +1,1327 @@
+#ifndef __tuxtxt_h__
+#define __tuxtxt_h__
+
+/******************************************************************************
+ *                      <<< TuxTxt - Teletext Plugin >>>                      *
+ *                                                                            *
+ *             (c) Thomas "LazyT" Loewe 2002-2003 (LazyT@gmx.net)             *
+ *                                                                            *
+ *    continued 2004-2005 by Roland Meier <RolandMeier@Siemens.com>           *
+ *                       and DBLuelle <dbluelle@blau-weissoedingen.de>        *
+ *                                                                            *
+ *              ported 2006 to Dreambox 7025 / 32Bit framebuffer              *
+ *                   by Seddi <seddi@i-have-a-dreambox.com>                   *
+ *                                                                            *
+ ******************************************************************************/
+
+#define TUXTXT_CFG_STANDALONE 1  // 1:plugin only 0:use library
+#define TUXTXT_DEBUG 0
+
+#define FONTDIR "/usr/share/fonts"
+#define CONFIGDIR "/usr"
+
+//#include <config.h>
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <ctype.h>
+
+#include <linux/fb.h>
+
+#include <linux/input.h>
+#include <linux/videodev.h>
+
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+//#include <dbox/avs_core.h>
+//#include <dbox/saa7126_core.h>
+//#include <dbox/fp.h>
+//#include <dbox/lcd-ks0713.h>
+
+
+#include "tuxtxt_def.h"
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_CACHE_H
+#include FT_CACHE_SMALL_BITMAPS_H
+
+/* devices */
+#define AVS "/dev/dbox/avs0"
+#define SAA "/dev/dbox/saa0"
+
+#define PIG "/dev/video0"
+
+
+
+#if TUXTXT_CFG_STANDALONE
+#include "tuxtxt_common.h"
+#else
+/* variables and functions from libtuxtxt */
+extern tuxtxt_cache_struct tuxtxt_cache;
+extern int tuxtxt_init();
+extern void tuxtxt_close();
+extern void tuxtxt_start(int tpid);  // Start caching
+extern int  tuxtxt_stop(); // Stop caching
+extern void tuxtxt_next_dec(int *i); /* skip to next decimal */
+extern void tuxtxt_prev_dec(int *i); /* counting down */
+extern int tuxtxt_is_dec(int i);
+extern int tuxtxt_next_hex(int i);
+extern void tuxtxt_decode_btt();
+extern void tuxtxt_decode_adip(); /* additional information table */
+extern void tuxtxt_compress_page(int p, int sp, unsigned char* buffer);
+extern void tuxtxt_decompress_page(int p, int sp, unsigned char* buffer);
+#if TUXTXT_DEBUG
+extern int tuxtxt_get_zipsize(int p, int sp);
+#endif
+#endif
+
+
+#define TUXTXTCONF CONFIGDIR "/tuxtxt/tuxtxt2.conf"
+
+/* fonts */
+#define TUXTXTTTF FONTDIR "/tuxtxt.ttf"
+#define TUXTXTOTB FONTDIR "/tuxtxt.otb"
+/* alternative fontdir */
+#define TUXTXTTTFVAR "/var/tuxtxt/tuxtxt.ttf"
+#define TUXTXTOTBVAR "/var/tuxtxt/tuxtxt.otb"
+
+int TTFWidthFactor16, TTFHeightFactor16, TTFShiftX, TTFShiftY; /* parameters for adapting to various TTF fonts */
+int fontheight, fontwidth, fontwidth_normal, fontwidth_small, fontwidth_topmenumain, fontwidth_topmenusmall, ascender;
+int ymosaic[4];
+int displaywidth;
+#define fontwidth_small_lcd 8
+
+#define TV43STARTX (ex - 146) //(StartX + 2 + (40-nofirst)*fontwidth_topmenumain + (40*fontwidth_topmenumain/abx))
+#define TV169FULLSTARTX (sx+ 8*40) //(sx +(ex +1 - sx)/2)
+#define TVENDX ex
+#define TVENDY (StartY + 25*fontheight)
+#define TV43WIDTH 144 /* 120 */
+#define TV43HEIGHT 116 /* 96 */
+#define TV43STARTY (TVENDY - TV43HEIGHT)
+#define TV169FULLSTARTY sy
+#define TV169FULLWIDTH  (ex - sx)/2
+#define TV169FULLHEIGHT (ey - sy)
+
+#define TOPMENUSTARTX TV43STARTX+2
+#define TOPMENUENDX TVENDX
+#define TOPMENUSTARTY StartY
+#define TOPMENUENDY TV43STARTY
+
+#define TOPMENULINEWIDTH ((TOPMENUENDX-TOPMENU43STARTX+fontwidth_topmenusmall-1)/fontwidth_topmenusmall)
+#define TOPMENUINDENTBLK 0
+#define TOPMENUINDENTGRP 1
+#define TOPMENUINDENTDEF 2
+#define TOPMENUSPC 0
+#define TOPMENUCHARS (TOPMENUINDENTDEF+12+TOPMENUSPC+4)
+
+#define FLOFSIZE 4
+
+/* spacing attributes */
+#define alpha_black         0x00
+#define alpha_red           0x01
+#define alpha_green         0x02
+#define alpha_yellow        0x03
+#define alpha_blue          0x04
+#define alpha_magenta       0x05
+#define alpha_cyan          0x06
+#define alpha_white         0x07
+#define flash               0x08
+#define steady              0x09
+#define end_box             0x0A
+#define start_box           0x0B
+#define normal_size         0x0C
+#define double_height       0x0D
+#define double_width        0x0E
+#define double_size         0x0F
+#define mosaic_black        0x10
+#define mosaic_red          0x11
+#define mosaic_green        0x12
+#define mosaic_yellow       0x13
+#define mosaic_blue         0x14
+#define mosaic_magenta      0x15
+#define mosaic_cyan         0x16
+#define mosaic_white        0x17
+#define conceal             0x18
+#define contiguous_mosaic   0x19
+#define separated_mosaic    0x1A
+#define esc                 0x1B
+#define black_background    0x1C
+#define new_background      0x1D
+#define hold_mosaic         0x1E
+#define release_mosaic      0x1F
+
+/* rc codes */
+#define RC_0        0x00
+#define RC_1        0x01
+#define RC_2        0x02
+#define RC_3        0x03
+#define RC_4        0x04
+#define RC_5        0x05
+#define RC_6        0x06
+#define RC_7        0x07
+#define RC_8        0x08
+#define RC_9        0x09
+#define RC_RIGHT    0x0A
+#define RC_LEFT     0x0B
+#define RC_UP       0x0C
+#define RC_DOWN     0x0D
+#define RC_OK       0x0E
+#define RC_MUTE     0x0F
+#define RC_STANDBY  0x10
+#define RC_GREEN    0x11
+#define RC_YELLOW   0x12
+#define RC_RED      0x13
+#define RC_BLUE     0x14
+#define RC_PLUS     0x15
+#define RC_MINUS    0x16
+#define RC_HELP     0x17
+#define RC_DBOX     0x18
+#define RC_HOME     0x1F
+
+
+
+/*
+typedef enum // object type
+{
+	OBJ_PASSIVE,
+	OBJ_ACTIVE,
+	OBJ_ADAPTIVE
+} tObjType;
+
+const unsigned char *ObjectSource[] =
+{
+	"(illegal)",
+	"Local",
+	"POP",
+	"GPOP"
+};
+const unsigned char *ObjectType[] =
+{
+	"Passive",
+	"Active",
+	"Adaptive",
+	"Passive"
+};
+*/
+
+/* messages */
+#define ShowInfoBar     0
+//#define PageNotFound    1
+#define ShowServiceName 2
+#define NoServicesFound 3
+
+/* framebuffer stuff */
+unsigned char *lfb = 0;
+struct fb_var_screeninfo var_screeninfo;
+struct fb_fix_screeninfo fix_screeninfo;
+
+/* freetype stuff */
+FT_Library      library;
+FTC_Manager     manager;
+FTC_SBitCache   cache;
+FTC_SBit        sbit;
+
+#define FONTTYPE FTC_ImageTypeRec
+
+
+
+FT_Face			face;
+FONTTYPE typettf;
+
+// G2 Charset (0 = Latin, 1 = Cyrillic, 2 = Greek)
+/*
+const unsigned short int G2table[3][6*16] =
+{
+	{ ' ' ,'' ,'' ,'' ,'$' ,'' ,'#' ,'' ,'' ,'\'','\"','' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'' ,'' ,'' ,'' ,'\'','\"','' ,'' ,'' ,'' ,'' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,' ' ,' ' ,' ' ,8539,8540,8541,8542,
+	  937 ,'' ,272 ,'' ,294 ,' ' ,306 ,319 ,321 ,'' ,338 ,'' ,'' ,358 ,330 ,329 ,
+	  1082,'' ,273 ,'' ,295 ,305 ,307 ,320 ,322 ,'' ,339 ,'' ,'' ,359 ,951 ,0x7F},
+	{ ' ' ,'' ,'' ,'' ,'$' ,'' ,' ' ,'' ,' ' ,'\'','\"','' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'' ,'' ,'' ,'' ,'\'','\"','' ,'' ,'' ,'' ,'' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,321 ,322 ,'' ,8539,8540,8541,8542,
+	  'D' ,'E' ,'F' ,'G' ,'I' ,'J' ,'K' ,'L' ,'N' ,'Q' ,'R' ,'S' ,'U' ,'V' ,'W' ,'Z' ,
+	  'd' ,'e' ,'f' ,'g' ,'i' ,'j' ,'k' ,'l' ,'n' ,'q' ,'r' ,'s' ,'u' ,'v' ,'w' ,'z' },
+	{ ' ' ,'a' ,'b' ,'' ,'e' ,'h' ,'i' ,'' ,':' ,'\'','\"','k' ,8592,8594,8595,8593,
+	  '' ,'' ,'' ,'' ,'x' ,'m' ,'n' ,'p' ,'' ,'\'','\"','t' ,'' ,'' ,'' ,'x' ,
+	  ' ' ,'`' ,'' ,710 ,732 ,'' ,728 ,729 ,733 ,716 ,730 ,719 ,'_' ,698 ,718 ,711 ,
+	  '?' ,'' ,'' ,'' ,8482,9834,8364,8240,945 ,906 ,910 ,911 ,8539,8540,8541,8542,
+	  'C' ,'D' ,'F' ,'G' ,'J' ,'L' ,'Q' ,'R' ,'S' ,'U' ,'V' ,'W' ,'Y' ,'Z' ,902 ,905 ,
+	  'c' ,'d' ,'f' ,'g' ,'j' ,'l' ,'q' ,'r' ,'s' ,'u' ,'v' ,'w' ,'y' ,'z' ,904 ,0x7F}
+};
+*/
+/*
+const unsigned short int arrowtable[] =
+{
+	8592, 8594, 8593, 8595, 'O', 'K', 8592, 8592
+};*/
+
+/* national subsets */
+const char countrystring[] =
+"          (#$@[\\]^_`{|}~) "   /*  0 no subset specified */
+"  CS/SK   (#$@[\\]^_`{|}~) "   /*  1 czech, slovak */
+"    EN    (#$@[\\]^_`{|}~) "   /*  2 english */
+"    ET    (#$@[\\]^_`{|}~) "   /*  3 estonian */
+"    FR    (#$@[\\]^_`{|}~) "   /*  4 french */
+"    DE    (#$@[\\]^_`{|}~) "   /*  5 german */
+"    IT    (#$@[\\]^_`{|}~) "   /*  6 italian */
+"  LV/LT   (#$@[\\]^_`{|}~) "   /*  7 latvian, lithuanian */
+"    PL    (#$@[\\]^_`{|}~) "   /*  8 polish */
+"  PT/ES   (#$@[\\]^_`{|}~) "   /*  9 portuguese, spanish */
+"    RO    (#$@[\\]^_`{|}~) "   /* 10 romanian */
+" SR/HR/SL (#$@[\\]^_`{|}~) "   /* 11 serbian, croatian, slovenian */
+" SV/FI/HU (#$@[\\]^_`{|}~) "   /* 12 swedish, finnish, hungarian */
+"    TR    (#$@[\\]^_`{|}~) "   /* 13 turkish */
+" RU/BUL/SER/CRO/UKR (cyr) "   /* 14 cyrillic */
+"    EK                    "   /* 15 greek */
+;
+#define COUNTRYSTRING_WIDTH 26
+#define MAX_NATIONAL_SUBSET (sizeof(countrystring) / COUNTRYSTRING_WIDTH - 1)
+/*
+enum
+{
+	NAT_DEFAULT = 0,
+	NAT_CZ = 1,
+	NAT_UK = 2,
+	NAT_ET = 3,
+	NAT_FR = 4,
+	NAT_DE = 5,
+	NAT_IT = 6,
+	NAT_LV = 7,
+	NAT_PL = 8,
+	NAT_SP = 9,
+	NAT_RO = 10,
+	NAT_SR = 11,
+	NAT_SW = 12,
+	NAT_TR = 13,
+	NAT_MAX_FROM_HEADER = 13,
+	NAT_RU = 14,
+	NAT_GR = 15
+};
+
+const unsigned char countryconversiontable[] = { NAT_UK, NAT_DE, NAT_SW, NAT_IT, NAT_FR, NAT_SP, NAT_CZ, NAT_RO};
+*/
+
+/* some data */
+char versioninfo[16];
+int hotlist[10];
+int maxhotlist;
+
+int pig, rc, fb, lcd;
+int sx, ex, sy, ey;
+int PosX, PosY, StartX, StartY;
+int lastpage;
+int inputcounter;
+int zoommode, screenmode, transpmode, hintmode, boxed, nofirst, savedscreenmode, showflof, show39, showl25, prevscreenmode;
+char dumpl25;
+int catch_row, catch_col, catched_page, pagecatching;
+int prev_100, prev_10, next_10, next_100;
+int screen_mode1, screen_mode2, color_mode, trans_mode, national_subset, national_subset_secondary, auto_national, swapupdown, showhex, menulanguage;
+int pids_found, current_service, getpidsdone;
+int SDT_ready;
+int pc_old_row, pc_old_col;     /* for page catching */
+int temp_page;	/* for page input */
+char saveconfig, hotlistchanged;
+signed char clearbbcolor = -1;
+int usettf;
+short pop, gpop, drcs, gdrcs;
+unsigned char tAPx, tAPy;	/* temporary offset to Active Position for objects */
+unsigned char axdrcs[12+1+10+1];
+#define aydrcs (axdrcs + 12+1)
+unsigned char FullRowColor[25];
+unsigned char FullScrColor;
+tstPageinfo *pageinfo = 0;/* pointer to cached info of last decoded page */
+const char * fncmodes[] = {"12", "6"};
+const char * saamodes[] = {"4:3_full_format", "16:9_full_format"};
+
+struct timeval tv_delay;
+int  subtitledelay, delaystarted;
+FILE *conf;
+
+
+short RCCode;
+
+struct _pid_table
+{
+	int  vtxt_pid;
+	int  service_id;
+	int  service_name_len;
+	char service_name[24];
+	int  national_subset;
+}pid_table[128];
+
+unsigned char restoreaudio = 0;
+/* 0 Nokia, 1 Philips, 2 Sagem */
+/* typ_vcr/dvb: 	v1 a1 v2 a2 v3 a3 (vcr_only: fblk) */
+/*
+const int avstable_ioctl[7] =
+{
+	AVSIOSVSW1, AVSIOSASW1, AVSIOSVSW2, AVSIOSASW2, AVSIOSVSW3, AVSIOSASW3, AVSIOSFBLK
+};
+const int avstable_ioctl_get[7] =
+{
+	AVSIOGVSW1, AVSIOGASW1, AVSIOGVSW2, AVSIOGASW2, AVSIOGVSW3, AVSIOGASW3, AVSIOGFBLK
+};*/
+const unsigned char avstable_scart[3][7] =
+{
+	{ 3, 2, 1, 0, 1, 1, 2 },
+	{ 3, 3, 2, 2, 3, 2, 2 },
+	{ 2, 1, 0, 0, 0, 0, 0 },
+};
+unsigned char avstable_dvb[3][7] =
+{
+	{ 5, 1, 1, 0, 1, 1, 0 },
+	{ 1, 1, 1, 1, 1, 1, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+};
+
+/* language dependent texts */
+#define MAXMENULANGUAGE 8 /* 0 deutsch, 1 englisch, 2 franzsisch, 3 niederlndisch, 4 griechisch, 5 italienisch, 6 polnisch, 7 schwedisch, 8 suomi */
+const int menusubset[] =   { NAT_DE   , NAT_UK    , NAT_FR       , NAT_UK          , NAT_GR      , NAT_IT       , NAT_PL    , NAT_SW, NAT_SW };
+
+
+#define Menu_StartX (StartX + fontwidth*9/2)
+#define Menu_StartY (StartY + fontheight)
+#define Menu_Height 24
+#define Menu_Width 31
+
+const char MenuLine[] =
+{
+	3,8,11,12,15,17,19,20,21
+};
+
+enum
+{
+	M_HOT=0,
+	M_PID,
+	M_SC1,
+	M_SC2,
+	M_COL,
+	M_TRA,
+	M_AUN,
+	M_NAT,
+	M_LNG,
+	M_Number
+};
+
+#define M_Start M_HOT
+#define M_MaxDirect M_AUN
+
+const char hotlistpagecolumn[] =	/* last(!) column of page to show in each language */
+{
+	22, 26, 28, 27, 28, 27, 28, 21, 20
+};
+const char hotlisttextcolumn[] =
+{
+	24, 14, 14, 15, 14, 15, 14, 23, 22
+};
+const char hotlisttext[][2*5] =
+{
+	{ "dazu entf." },
+	{ " add rem. " },
+	{ "ajoutenlev" },
+	{ "toev.verw." },
+	{ "pq|shava_q" },
+	{ "agg. elim." },
+	{ "dodajkasuj" },
+	{ "ny   bort " },
+	{ "lis{{pois " },
+};
+
+const char configonoff[][2*3] =
+{
+	{ "ausein" },
+	{ "offon " },
+	{ "desact" },
+	{ "uitaan" },
+	{ "emeape" },
+	{ "offon " },
+	{ "wy}w} " },
+	{ "p} av " },
+	{ "EI ON " },
+};
+const char menuatr[Menu_Height*Menu_Width] =
+{
+	"0000000000000000000000000000002"
+	"0111111111111111111111111111102"
+	"0000000000000000000000000000002"
+	"3144444444444444444444444444432"
+	"3556655555555555555555555555532"
+	"3555555555555555555555555555532"
+	"3333333333333333333333333333332"
+	"3144444444444444444444444444432"
+	"3555555555555555555555555555532"
+	"3333333333333333333333333333332"
+	"3444444444444444444444444444432"
+	"3155555555555555555555555555532"
+	"3155555555555555555555555555532"
+	"3333333333333333333333333333332"
+	"3144444444444444444444444444432"
+	"3555555555555555555555555555532"
+	"3144444444444444444444444444432"
+	"3555555555555555555555555555532"
+	"3144444444444444444444444444432"
+	"3555555555555555555555555555532"
+	"3555555555555555555555555555532"
+	"3555555555555555555555555555532"
+	"3334444444444444444444444443332"
+	"2222222222222222222222222222222"
+};
+const char configmenu[][Menu_Height*Menu_Width] =
+{
+	{
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+		""
+		"     Konfigurationsmen}     "
+		""
+		"1 Favoriten: Seite 111 dazu "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2     Teletext-Auswahl      "
+		"          suchen          "
+		"                            "
+		"      Bildschirmformat      "
+		"3  Standard-Modus 16:9      "
+		"4  TextBild-Modus 16:9      "
+		"                            "
+		"5        Helligkeit         "
+		"                          "
+		"6       Transparenz         "
+		"                          "
+		"7  nationaler Zeichensatz   "
+		"automatische Erkennung      "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Sprache/Language deutsch "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"     Configuration menu     "
+		""
+		"1 Favorites:  add page 111  "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2     Teletext selection    "
+		"          search          "
+		"                            "
+		"        Screen format       "
+		"3 Standard mode 16:9        "
+		"4 Text/TV mode  16:9        "
+		"                            "
+		"5        Brightness         "
+		"                          "
+		"6       Transparency        "
+		"                          "
+		"7   national characterset   "
+		" automatic recognition      "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Sprache/language english "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"    Menu de configuration   "
+		""
+		"1 Favorites: ajout. page 111"
+		"                        "
+		"+-?                         "
+		"                            "
+		"2  Selection de teletext    "
+		"        recherche         "
+		"                            "
+		"      Format de l'#cran     "
+		"3 Mode standard 16:9        "
+		"4 Texte/TV      16:9        "
+		"                            "
+		"5          Clarte           "
+		"                          "
+		"6       Transparence        "
+		"                          "
+		"7     police nationale      "
+		"reconn. automatique         "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Sprache/language francais"
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"      Configuratiemenu      "
+		""
+		"1 Favorieten: toev. pag 111 "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2     Teletekst-selectie    "
+		"          zoeken          "
+		"                            "
+		"     Beeldschermformaat     "
+		"3   Standaardmode 16:9      "
+		"4   Tekst/TV mode 16:9      "
+		"                            "
+		"5        Helderheid         "
+		"                          "
+		"6       Transparantie       "
+		"                          "
+		"7    nationale tekenset     "
+		"automatische herkenning     "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Sprache/Language nederl. "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"      Lemo} quhl_seym       "
+		""
+		"1 Vaboq_:    pqo_h. sek. 111"
+		"                        "
+		"+-?                         "
+		"                            "
+		"2     Epikoc^ Teket]nt      "
+		"        Amaf^tgsg         "
+		"                            "
+		"       Loqv^ oh|mgr         "
+		"3 Tq|por pq|tupor   16:9    "
+		"4 Tq|por eij. jeil. 16:9    "
+		"                            "
+		"5       Kalpq|tgta          "
+		"                          "
+		"6       Diav\\meia           "
+		"                          "
+		"7    Ehmij^ tuposeiq\\       "
+		"aut|latg amacm~qisg         "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Ck~ssa/Language ekkgmij\\ "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"   Menu di configurazione   "
+		""
+		"1  Preferiti:  agg. pag.111 "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2   Selezione televideo     "
+		"         ricerca          "
+		"                            "
+		"      Formato schermo       "
+		"3  Modo standard 16:9       "
+		"4  Text/Mod.TV 16:9         "
+		"                            "
+		"5        Luminosit{         "
+		"                          "
+		"6        Trasparenza        "
+		"                          "
+		"7   nazionalita'caratteri   "
+		" riconoscimento automatico  "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Lingua/Language Italiana "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"        Konfiguracja        "
+		""
+		"1 Ulubione : kasuj  str. 111"
+		"                        "
+		"+-?                         "
+		"                            "
+		"2     Wyb_r telegazety      "
+		"          szukaj          "
+		"                            "
+		"       Format obrazu        "
+		"3 Tryb standard 16:9        "
+		"4 Telegazeta/TV 16:9        "
+		"                            "
+		"5          Jasno|^          "
+		"                          "
+		"6      Prze~roczysto|^      "
+		"                          "
+		"7 Znaki charakterystyczne   "
+		" automatyczne rozpozn.      "
+		"    DE    (#$@[\\]^_`{|}~) "
+		"  J`zyk/Language   polski "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"     Konfigurationsmeny     "
+		""
+		"1 Favoriter: sida 111 ny    "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2      TextTV v{ljaren      "
+		"            s|k           "
+		"                            "
+		"        TV- format          "
+		"3 Standard l{ge 16:9        "
+		"4 Text/Bild l{ge  16:9      "
+		"                            "
+		"5        Ljusstyrka         "
+		"                          "
+		"6     Genomskinlighet       "
+		"                          "
+		"7nationell teckenupps{ttning"
+		" automatisk igenk{nning     "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Sprache/language svenska "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+/*     0000000000111111111122222222223 */
+/*     0123456789012345678901234567890 */
+	{
+		""
+		"        Asetusvalikko       "
+		""
+		"1 Suosikit: sivu 111 lis{{  "
+		"                        "
+		"+-?                         "
+		"                            "
+		"2   Tekstikanavan valinta   "
+		"          search          "
+		"                            "
+		"         N{ytt|tila         "
+		"3 Vakiotila     16:9        "
+		"4 Teksti/TV     16:9        "
+		"                            "
+		"5         Kirkkaus          "
+		"                          "
+		"6       L{pin{kyvyys        "
+		"                          "
+		"7   kansallinen merkist|    "
+		" automaattinen tunnistus    "
+		"    DE    (#$@[\\]^_`{|}~) "
+		" Kieli            suomi   "
+		"   www.tuxtxt.net  x.xx   "
+		""
+	},
+};
+
+const char catchmenutext[][80] =
+{
+	{ "         w{hlen    anzeigen       "
+	  "0000000011110000000000110000000000000000" },
+	{ "         select    show           "
+	  "0000000011110000000000110000000000000000" },
+	{ "   selectionner    montrer        "
+	  "0011110000000000000000110000000000000000" },
+	{ "         kiezen    tonen          "
+	  "0000000011110000000000110000000000000000" },
+	{ "         epikoc^   pqobok^        "
+	  "0000000011110000000000110000000000000000" },
+	{ "        seleziona  mostra         "
+	  "0000000011110000000000110000000000000000" },
+	{ "         wybiez    wyswietl       "
+	  "0000000011110000000000110000000000000000" },
+	{ "         v{lj      visa           "
+     "0000000011110000000000110000000000000000" },
+	{ "         valitse   n{yt{          "
+	  "0000000011110000000000110000000000000000" },
+};
+
+const char message_3[][38] =
+{
+	{ "   suche nach Teletext-Anbietern   " },
+	{ "  searching for teletext Services  " },
+	{ "  recherche des services teletext  " },
+	{ " zoeken naar teletekst aanbieders  " },
+	{ "     amaf^tgsg voq]ym Teket]nt     " },
+	{ "     attesa opzioni televideo      " },
+	{ "  poszukiwanie sygna}u telegazety  " },
+	{ "    s|ker efter TextTV tj{nster    " },
+	{ "   etsit{{n Teksti-TV -palvelua    " },
+};
+const char message_3_blank[] = "                                   ";
+const char message_7[][38] =
+{
+	{ " kein Teletext auf dem Transponder " },
+	{ "   no teletext on the transponder  " },
+	{ " pas de teletext sur le transponder" },
+	{ " geen teletekst op de transponder  " },
+	{ " jal]la Teket]nt ston amaletadot^  " },
+	{ " nessun televideo sul trasponder   " },
+	{ "   brak sygna}u na transponderze   " },
+	{ " ingen TextTV p} denna transponder " },
+	{ "    Ei Teksti-TV:t{ l{hettimell{   " },
+};
+const char message_8[][38] =
+{
+/*    00000000001111111111222222222233333333334 */
+/*    01234567890123456789012345678901234567890 */
+	{ "  warte auf Empfang von Seite 100  " },
+	{ " waiting for reception of page 100 " },
+	{ " attentre la rception de page 100 " },
+	{ "wachten op ontvangst van pagina 100" },
+	{ "     amal]my k^xg sek_dar 100      " },
+	{ "   attesa ricezione pagina 100     " },
+	{ "     oczekiwanie na stron` 100     " },
+	{ "  v{ntar p} mottagning av sida 100 " },
+	{ "        Odotetaan sivua 100        " },
+};
+const char message8pagecolumn[] = /* last(!) column of page to show in each language */
+{
+	33, 34, 34, 35, 29, 30, 30, 34, 34
+};
+
+/*
+enum // options for charset
+{
+	C_G0P = 0, // primary G0
+	C_G0S, // secondary G0
+	C_G1C, // G1 contiguous
+	C_G1S, // G1 separate
+	C_G2,
+	C_G3,
+	C_OFFSET_DRCS = 32
+	// 32..47: 32+subpage# GDRCS (offset/20 in page_char)
+	// 48..63: 48+subpage#  DRCS (offset/20 in page_char)
+};*/
+
+/* struct for page attributes */
+/*
+typedef struct
+{
+	unsigned char fg      :6; 
+	unsigned char bg      :6; 
+	unsigned char charset :6; 
+	unsigned char doubleh :1; 
+	unsigned char doublew :1; 
+	
+	unsigned char IgnoreAtBlackBgSubst:1;
+	unsigned char concealed:1;
+	unsigned char inverted :1; 
+	unsigned char flashing :5; 
+	unsigned char diacrit  :4; 
+	unsigned char underline:1; 
+	unsigned char boxwin   :1; 
+	unsigned char setX26   :1; 
+	unsigned char setG0G2  :7; 
+} tstPageAttr;*/
+
+enum /* indices in atrtable */
+{
+	ATR_WB, /* white on black */
+	ATR_PassiveDefault, /* Default for passive objects: white on black, ignore at Black Background Color Substitution */
+	ATR_L250, /* line25 */
+	ATR_L251, /* line25 */
+	ATR_L252, /* line25 */
+	ATR_L253, /* line25 */
+	ATR_TOPMENU0, /* topmenu */
+	ATR_TOPMENU1, /* topmenu */
+	ATR_TOPMENU2, /* topmenu */
+	ATR_TOPMENU3, /* topmenu */
+	ATR_MSG0, /* message */
+	ATR_MSG1, /* message */
+	ATR_MSG2, /* message */
+	ATR_MSG3, /* message */
+	ATR_MSGDRM0, /* message */
+	ATR_MSGDRM1, /* message */
+	ATR_MSGDRM2, /* message */
+	ATR_MSGDRM3, /* message */
+	ATR_MENUHIL0, /* hilit menu line */
+	ATR_MENUHIL1, /* hilit menu line */
+	ATR_MENUHIL2, /* hilit menu line */
+	ATR_MENU0, /* menu line */
+	ATR_MENU1, /* menu line */
+	ATR_MENU2, /* menu line */
+	ATR_MENU3, /* menu line */
+	ATR_MENU4, /* menu line */
+	ATR_MENU5, /* menu line */
+	ATR_MENU6, /* menu line */
+	ATR_CATCHMENU0, /* catch menu line */
+	ATR_CATCHMENU1 /* catch menu line */
+};
+
+/* define color names */
+/*
+enum
+{
+	black = 0,
+	red, 
+	green, 
+	yellow, 
+	blue,	
+	magenta,	
+	cyan,	
+	white, 
+	menu1 = (4*8),
+	menu2,
+	menu3,
+	transp,
+	transp2,
+	SIZECOLTABLE
+};*/
+
+//const (avoid warnings :<)
+tstPageAttr atrtable[] =
+{
+	{ white  , black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_WB */
+	{ white  , black , C_G0P, 0, 0, 1 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_PassiveDefault */
+	{ white  , red   , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_L250 */
+	{ black  , green , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_L251 */
+	{ black  , yellow, C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_L252 */
+	{ white  , blue  , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_L253 */
+	{ magenta, black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_TOPMENU0 */
+	{ green  , black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_TOPMENU1 */
+	{ yellow , black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_TOPMENU2 */
+	{ cyan   , black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_TOPMENU3 */
+	{ menu2  , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSG0 */
+	{ yellow , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSG1 */
+	{ menu2  , transp, C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSG2 */
+	{ white  , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSG3 */
+	{ menu2  , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSGDRM0 */
+	{ yellow , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSGDRM1 */
+	{ menu2  , black , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSGDRM2 */
+	{ white  , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MSGDRM3 */
+	{ menu1  , blue  , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENUHIL0 5a Z */
+	{ white  , blue  , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENUHIL1 58 X */
+	{ menu2  , transp, C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENUHIL2 9b  */
+	{ menu2  , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU0 ab  */
+	{ yellow , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU1 a4  */
+	{ menu2  , transp, C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU2 9b  */
+	{ menu2  , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU3 cb  */
+	{ cyan   , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU4 c7  */
+	{ white  , menu3 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU5 c8  */
+	{ white  , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_MENU6 a8  */
+	{ yellow , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}, /* ATR_CATCHMENU0 a4  */
+	{ white  , menu1 , C_G0P, 0, 0, 0 ,0, 0, 0, 0, 0, 0, 0, 0x3f}  /* ATR_CATCHMENU1 a8  */
+};
+/* buffers */
+unsigned char  lcd_backbuffer[120*64 / 8];
+unsigned char  page_char[40 * 25];
+tstPageAttr page_atrb[40 * 25];
+
+//unsigned short page_atrb[40 * 25]; /*  ?????:h:cc:bbbb:ffff -> ?=reserved, h=double height, c=charset (0:G0 / 1:G1c / 2:G1s), b=background, f=foreground */
+
+
+/* colormap */
+const unsigned short defaultcolors[] =	/* 0x0bgr */
+{
+	0x000, 0x00f, 0x0f0, 0x0ff, 0xf00, 0xf0f, 0xff0, 0xfff,
+	0x000, 0x007, 0x070, 0x077, 0x700, 0x707, 0x770, 0x777,
+	0x50f, 0x07f, 0x7f0, 0xbff, 0xac0, 0x005, 0x256, 0x77c,
+	0x333, 0x77f, 0x7f7, 0x7ff, 0xf77, 0xf7f, 0xff7, 0xddd,
+	0x420, 0x210, 0x420, 0x000, 0x000
+};
+
+/* 32bit colortable */
+unsigned char bgra[][4] = { 
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xFF",
+"\0\0\0\xFF", "\0\0\0\xFF", "\0\0\0\xC0", "\0\0\0\x00",
+"\0\0\0\x33" };
+
+/* old 8bit color table */
+unsigned short rd0[] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0x00<<8, 0x00<<8, 0x00<<8, 0,      0      };
+unsigned short gn0[] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0x20<<8, 0x10<<8, 0x20<<8, 0,      0      };
+unsigned short bl0[] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0x40<<8, 0x20<<8, 0x40<<8, 0,      0      };
+unsigned short tr0[] = {0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0x0000 , 0x0000 , 0x0A00 , 0xFFFF, 0x3000 };
+struct fb_cmap colormap_0 = {0, SIZECOLTABLE, rd0, gn0, bl0, tr0};
+
+/* tables for color table remapping, first entry (no remapping) skipped, offsets for color index */
+//const unsigned char MapTblFG[] = {  0,  0,  8,  8, 16, 16, 16 };
+//const unsigned char MapTblBG[] = {  8, 16,  8, 16,  8, 16, 24 };
+
+
+/* lcd layout */
+const char lcd_layout[] =
+{
+#define ____ 0x0
+#define ___X 0x1
+#define __X_ 0x2
+#define __XX 0x3
+#define _X__ 0x4
+#define _X_X 0x5
+#define _XX_ 0x6
+#define _XXX 0x7
+#define X___ 0x8
+#define X__X 0x9
+#define X_X_ 0xA
+#define X_XX 0xB
+#define XX__ 0xC
+#define XX_X 0xD
+#define XXX_ 0xE
+#define XXXX 0xF
+
+#define i <<4|
+
+	____ i _XXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXX_ i ____,
+	___X i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i X___,
+	__XX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XX__ i ____,XXX_ i _X__,_XXX i __X_,__XX i X___,___X i XX__,X___ i XXX_,____ i _XXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XX__,
+	_XXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,X_XX i XXXX,_X_X i X_XX,X_X_ i XX_X,XX_X i _XXX,XXX_ i X_XX,_XXX i _X_X,XXXX i X_XX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXX_,
+	_XXX i XXXX,X___ i ____,____ i ____,____ i __XX,X_XX i XXXX,_X_X i X_XX,X_X_ i XX_X,XX_X i _XXX,XXX_ i X_XX,_XXX i _X_X,XXXX i X_XX,X___ i ____,____ i ____,____ i ___X,XXXX i XXX_,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,X_XX i XXXX,_X_X i X_XX,X_X_ i XX_X,XX_X i _XXX,XXX_ i X_XX,_XXX i _X_X,XXXX i X_XX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XX__ i XX__,XX_X i X_XX,X_X_ i XXXX,XX_X i X__X,X__X i X_XX,XXXX i _XX_,_XX_ i _XXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XX__,____ i ____,____ i ____,____ i __XX,XXX_ i XX_X,XX_X i X_XX,X_XX i _XXX,__XX i XX_X,X_XX i XX_X,XX__ i XXXX,_XX_ i XXXX,X___ i ____,____ i ____,____ i ____,__XX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXX_ i XX_X,XX_X i X_XX,X_X_ i XXXX,XX_X i XX_X,X_XX i X_XX,XXXX i _XXX,_XX_ i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXX_ i XX_X,XX_X i X_XX,X_X_ i XX_X,XX_X i XX_X,X_XX i X_XX,_XXX i _XXX,_XX_ i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXX_ i ____,____ i ____,____ i ____,____ i __XX,XXX_ i XX_X,XX_X i XXXX,X_X_ i XX_X,XX_X i XX_X,X_XX i X_XX,_XXX i _XXX,_XX_ i XXXX,X___ i ____,____ i ____,____ i ____,____ i _XXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXX_ i XX_X,XX_X i XXXX,X_X_ i XX_X,XX_X i XX_X,X_XX i X_XX,_XXX i _XXX,_XX_ i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i __XX,XXX_ i ____,_XXX i __X_,__XX i XXX_,_XXX i XX__,X___ i XXXX,X__X i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i XX__,_XXX i XXX_,__XX i ___X,XXXX i X___,XX__ i _XXX,XXX_ i __XX,____ i ___X,X___ i XXXX,XX__ i _XX_,__XX i XXXX,___X i XXXX,X___ i XX_X,XX__ i _XXX,XXX_ i __XX,XXXX i ___X,
+	X__X i __X_,X___ i ___X,_X__ i X_X_,____ i _X_X,__X_ i X___,___X i _X__,X___ i __X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i ____,_X_X i __X_,__X_ i X___,___X i _X__,____ i X__X,
+	X__X i __X_,X___ i ___X,_X__ i X_X_,____ i _X_X,__X_ i X___,___X i _X__,X___ i __X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i ____,_X_X i __X_,__X_ i X___,___X i _X__,____ i X__X,
+	X__X i __X_,X___ i ___X,_X__ i X_X_,____ i _X_X,__X_ i X___,___X i _X__,X___ i __X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i ____,_X_X i __X_,__X_ i X___,___X i _X__,____ i X__X,
+	X__X i __X_,X__X i ___X,_X__ i X__X,X__X i X__X,__X_ i X__X,___X i _X__,X___ i __X_,_X_X i __XX,XX__ i X__X,_X__ i XXXX,__X_ i _X__,_X_X i __X_,__X_ i X__X,___X i _X__,XXXX i ___X,
+	X__X i __X_,X__X i ___X,_X__ i X___,X__X i ___X,__X_ i X___,___X i _X__,X___ i __X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i ___X,X__X i __X_,__X_ i X__X,___X i _X__,X___ i X__X,
+	X__X i __X_,X__X i ___X,_X__ i X___,X__X i ___X,__X_ i X___,___X i _X__,X___ i __X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i ____,_X_X i __X_,__X_ i X__X,___X i _X__,X___ i X__X,
+	X__X i __X_,X__X i ___X,_X__ i X___,X__X i ___X,__X_ i X__X,___X i _X__,XXXX i __X_,_X__ i XXX_,__X_ i X__X,_X__ i XXXX,__X_ i _X__,_X_X i __X_,__X_ i X__X,___X i _X__,X___ i X__X,
+	X__X i __X_,X__X i ___X,_X__ i X___,X__X i ___X,__X_ i X__X,___X i _X__,____ i X_X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i _X__,_X_X i ____,__X_ i X__X,___X i _X__,____ i X__X,
+	X__X i __X_,X__X i ___X,_X__ i X___,X__X i ___X,__X_ i X__X,___X i _X__,____ i X_X_,_X_X i ____,__X_ i X__X,_X__ i ____,X_X_ i _X__,_X_X i ____,__X_ i X__X,___X i _X__,____ i X__X,
+	X___ i XX__,XXX_ i XXXX,__XX i ____,_XX_ i ____,XX__ i _XX_,XXX_ i __XX,XXXX i ___X,X___ i XXXX,XX__ i _XX_,__XX i XXXX,___X i X_XX,X___ i XXXX,XX__ i _XX_,XXX_ i __XX,XXXX i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,XXXX i XXXX,X___ i XXXX,XX__ i _XXX,XXXX i XX__,_XXX i XXX_,__XX i XXXX,___X i XXXX,X___ i ____,__XX i XXXX,___X i X___,XXXX i XX__,_XXX i XXX_,__XX i XXXX,____ i ___X,
+	X___ i ___X,____ i ____,_X_X i ____,__X_ i X___,____ i __X_,X___ i ___X,_X__ i ____,X_X_ i ____,_X__ i ____,_X__ i ____,X_X_ i _X_X,____ i __X_,X___ i ___X,_X__ i ____,X___ i ___X,
+	X___ i ___X,____ i ____,_X_X i ____,__X_ i X___,____ i __X_,X___ i ___X,_X__ i ____,X_X_ i ____,_X__ i ____,_X__ i ____,X_X_ i _X_X,____ i __X_,X___ i ___X,_X__ i ____,X___ i ___X,
+	X___ i ___X,____ i ____,_X_X i ____,__X_ i X___,____ i __X_,X___ i ___X,_X__ i ____,X_X_ i ____,_X__ i ____,_X__ i XX__,X_X_ i _X_X,____ i __X_,X___ i ___X,_X__ i ____,X___ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i __X_,__X_ i X__X,___X i __X_,X__X i XXX_,_X__ i X___,X__X i X__X,X___ i ____,_X__ i ____,X_X_ i _X__,XX__ i XX__,_XX_ i _XX_,_X__ i XXXX,____ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i __X_,__X_ i X__X,___X i __X_,X___ i ___X,_X__ i X___,X___ i X__X,____ i ____,_X__ i __XX,__X_ i _X__,_X__ i X___,__X_ i _X__,_X__ i ____,X___ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i __X_,__X_ i X__X,___X i __X_,X___ i ___X,_X__ i X___,X___ i X__X,____ i ____,_X__ i ____,X_X_ i _X__,_X__ i X___,__X_ i _X__,_X__ i ____,X___ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i __X_,__X_ i X__X,___X i __X_,X__X i XXX_,_X__ i X___,X___ i X__X,____ i ____,_X__ i XX__,X_X_ i _X__,_X__ i X___,__X_ i _X__,_X__ i XXXX,____ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i ____,__X_ i X__X,___X i __X_,X___ i ___X,_X__ i X___,X___ i X__X,____ i ____,_X__ i ____,X_X_ i _X__,_X__ i X___,__X_ i _X__,_X__ i ____,X___ i ___X,
+	X___ i ___X,__X_ i __X_,_X_X i ____,__X_ i X__X,___X i __X_,X___ i ___X,_X__ i X___,X___ i X__X,____ i ____,_X__ i ____,X_X_ i _X__,_X__ i X___,__X_ i _X__,_X__ i ____,X___ i ___X,
+	X___ i ____,XX_X i XX_X,X___ i XXXX,XX__ i _XX_,XXX_ i XX__,_XXX i XXX_,__XX i _XXX,____ i _XX_,____ i ____,__XX i XXXX,___X i X___,__XX i ____,___X i X___,__XX i XXXX,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	X___ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ___X,
+	_X__ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i __X_,
+	_X__ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i __X_,
+	__X_ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i _X__,
+	___X i X___,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,____ i ____,___X i X___,
+	____ i _XXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXXX i XXXX,XXX_ i ____,
+
+#undef i
+};
+
+/* lcd digits */
+const char lcd_digits[] =
+{
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,0,0,1,1,1,1,0,0,0,
+	0,0,1,1,0,0,1,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,1,0,0,1,1,0,0,
+	0,0,0,1,1,1,1,0,0,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,0,1,1,1,1,0,
+	1,1,0,1,1,1,0,0,1,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,1,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,1,0,0,1,1,
+	0,0,0,0,0,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,1,1,1,1,0,
+	1,0,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,0,0,0,0,1,
+	0,0,0,0,1,1,0,0,1,1,
+	0,0,0,0,0,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,0,0,0,0,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,1,1,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,1,1,
+	0,1,1,1,1,1,1,1,1,0,
+
+	/* 10: - */
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,1,1,1,1,1,1,0,0,
+	0,1,0,0,0,0,0,0,1,0,
+	0,1,0,0,0,0,0,0,1,0,
+	0,1,0,0,0,0,0,0,1,0,
+	0,0,1,1,1,1,1,1,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+
+	/* 11: / */
+	0,0,0,0,1,1,1,1,0,0,
+	0,0,0,1,0,0,0,0,1,0,
+	0,0,0,1,0,0,0,0,1,0,
+	0,0,0,1,0,0,0,0,1,0,
+	0,0,0,1,0,0,0,0,1,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,0,1,0,0,0,0,1,0,0,
+	0,1,0,0,0,0,1,0,0,0,
+	0,1,0,0,0,0,1,0,0,0,
+	0,1,0,0,0,0,1,0,0,0,
+	0,1,0,0,0,0,1,0,0,0,
+	0,0,1,1,1,1,0,0,0,0,
+
+	/* 12: ? */
+	0,1,1,1,1,1,1,1,1,0,
+	1,1,0,0,0,0,0,0,1,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	0,1,1,1,1,1,0,0,0,1,
+	1,1,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,0,1,
+	1,0,0,0,0,0,0,0,1,1,
+	1,1,1,1,1,1,1,1,1,0,
+	1,0,0,0,0,1,0,0,0,0,
+	1,0,0,0,0,1,0,0,0,0,
+	1,0,0,0,0,1,0,0,0,0,
+	1,1,0,0,1,1,0,0,0,0,
+	0,1,1,1,1,0,0,0,0,0,
+
+	/* 13: " " */
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,
+};
+
+/* functions */
+void ConfigMenu(int Init);
+void CleanUp();
+void PageInput(int Number);
+void ColorKey(int);
+void PageCatching();
+void CatchNextPage(int, int);
+void GetNextPageOne(int up);
+void GetNextSubPage(int offset);
+void SwitchZoomMode();
+void SwitchScreenMode(int newscreenmode);
+void SwitchTranspMode();
+void SwitchHintMode();
+void CreateLine25();
+void CopyBB2FB();
+void RenderCatchedPage();
+void RenderCharFB(int Char, tstPageAttr *Attribute);
+void RenderCharBB(int Char, tstPageAttr *Attribute);
+void RenderCharLCD(int Digit, int XPos, int YPos);
+void RenderMessage(int Message);
+void RenderPage();
+void DecodePage();
+void UpdateLCD();
+int  Init();
+int  GetNationalSubset(char *country_code);
+int  GetTeletextPIDs();
+int  GetRCCode();
+int  eval_triplet(int iOData, tstCachedPage *pstCachedPage,
+						unsigned char *pAPx, unsigned char *pAPy,
+						unsigned char *pAPx0, unsigned char *pAPy0,
+						unsigned char *drcssubp, unsigned char *gdrcssubp,
+						signed char *endcol, tstPageAttr *attrPassive, unsigned char* pagedata);
+void eval_object(int iONr, tstCachedPage *pstCachedPage,
+					  unsigned char *pAPx, unsigned char *pAPy,
+					  unsigned char *pAPx0, unsigned char *pAPy0,
+					  tObjType ObjType, unsigned char* pagedata);
+
+
+#endif
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py	2009-12-13 10:14:36.117264812 +0100
@@ -0,0 +1,2 @@
+
+
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE	2009-12-11 21:40:13.000000000 +0100
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am	2009-12-11 21:40:13.000000000 +0100
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am	2009-12-11 21:40:13.000000000 +0100
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta/
+
+dist_install_DATA = plugin_vfd-icons.xml
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml	2009-12-11 21:40:13.000000000 +0100
@@ -0,0 +1,27 @@
+<default>
+	  <prerequisites>
+                    <tag type="System" />
+	  </prerequisites>
+          <info language="en">
+                    <author>Team Ducktales</author>
+                    <name>VFD-Icons</name>
+                    <packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		    <packagetype>internal</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+                    <shortdescription>Internal firmware updater.</shortdescription>
+                    <description>This system tool is internally used to program the hardware with firmware updates.
+                    </description>
+	  </info>
+          <info language="de">
+                    <author>Dream Multimedia</author>
+                    <name>FrontprocessorUpgrade</name>
+                    <packagename>enigma2-plugin-systemplugins-frontprocessorupgrade</packagename>
+		    <packagetype>internal</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+                    <shortdescription>Interner Firmware-Upgrader.</shortdescription>
+                    <description>Dieses Systemtool wird intern benutzt um Firmware-Upgrades fr die Hardware aufzuspielen.
+                    </description>
+          </info>
+	  <files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-frontprocessorupgrade" />
+	</files>
+
+</default>
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py	2009-12-11 21:40:13.000000000 +0100
@@ -0,0 +1,154 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+				
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()	
+		
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+		
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+		
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+		
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+	
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+	
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+		
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+		
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+		
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+		
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+		
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+		
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+		
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+ 	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2009-12-12 23:16:22.484601000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2009-12-12 23:54:14.000000000 +0100
@@ -85,7 +85,16 @@
 		elif config.av.aspect.value == "4_3":
 			self.list.append(getConfigListEntry(_("Display 16:9 content as"), config.av.policy_169))
 
-#		if config.av.videoport.value == "DVI":
+#--->
+#-#		if config.av.videoport.value == "DVI":
+#---<
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat))
diff -Nur enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- enigma2-nightly.org/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2009-12-12 23:16:22.484601000 +0100
+++ enigma2-nightly/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2009-12-11 21:40:15.000000000 +0100
@@ -2,7 +2,6 @@
 from Components.config import config, ConfigSelection, ConfigSubDict, ConfigYesNo
 
 from Tools.CList import CList
-from Tools.HardwareInfo import HardwareInfo
 
 # The "VideoHardware" is the interface to /proc/stb/video.
 # It generates hotplug events, and gives you the list of 
@@ -13,93 +12,48 @@
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":		{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+	rates["PAL"] =			{ "50Hz":		{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz": 	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
-
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
+	rates["576p"] =			{ "50Hz": 	{ 50: "576p50" } }
 
 	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+					  "60Hz": 	{ 60: "720p60" } }
 
-	rates["1080i"] =		{ "50Hz":		{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
+	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
+					  "60Hz":	{ 60: "1080i60" } }
+
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+					  "24Hz":	{ 60: "1080p24" },
+					  "25Hz":	{ 60: "1080p25" },
+					  "29Hz":	{ 60: "1080p29" },
+					  "30Hz":	{ 60: "1080p30" } }
 
 	rates["PC"] = { 
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768": 		{ 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : 		{ 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200": 		{ 60: "1600x1200_60" }, #60 66 76
+
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
 
-	widescreen_modes = set(["720p", "1080i"])
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI"]  = ["576i", "576p", "720p", "1080i", "1080p"]
+	modes["HDMI-PC"] = ["PC"]
 
-	def getOutputAspect(self):
-		ret = (16,9)
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print "current port not available in getOutputAspect!!! force 16:9"
-		else:
-			mode = config.av.videomode[port].value
-			force_widescreen = self.isWidescreenMode(port, mode)
-			is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-			is_auto = config.av.aspect.value == "auto"
-			if is_widescreen:
-				if force_widescreen:
-					pass
-				else:
-					aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-					if aspect == "16:10":
-						ret = (16,10)
-			elif is_auto:
-				try:
-					aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
-					if aspect_str == "1": # 4:3
-						ret = (4,3)
-				except IOError:
-					pass
-			else:  # 4:3
-				ret = (4,3)
-		return ret
+	widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
 
 	def __init__(self):
 		self.last_modes_preferred =  [ ]
 		self.on_hotplug = CList()
+		self.standby = False
 		self.current_mode = None
 		self.current_port = None
 
 		self.readAvailableModes()
 
-		if self.modes.has_key("DVI-PC") and not self.getModeList("DVI-PC"):
-			print "remove DVI-PC because of not existing modes"
-			del self.modes["DVI-PC"]
-
 		self.createConfig()
 #		self.on_hotplug.append(self.createConfig)
 
@@ -108,11 +62,20 @@
 		# take over old AVSwitch component :)
 		from Components.AVSwitch import AVSwitch
 #		config.av.colorformat.notifiers = [ ] 
+
 		config.av.aspectratio.notifiers = [ ]
 		config.av.tvsystem.notifiers = [ ]
 		config.av.wss.notifiers = [ ]
-		AVSwitch.getOutputAspect = self.getOutputAspect
+		AVSwitch.setInput = self.AVSwitchSetInput
 
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+#		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF"), "8ch": _("8Ch"), "none": _("None")}, default="pcm")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -123,6 +86,12 @@
 #		self.timer.callback.append(self.readPreferredModes)
 #		self.timer.start(1000)
 
+		config.av.colorformat.addNotifier(self.updateFastblank) 
+
+	def AVSwitchSetInput(self, mode):
+		self.standby = mode == "SCART"
+		self.updateStandby()
+
 	def readAvailableModes(self):
 		try:
 			modes = open("/proc/stb/video/videomode_choices").read()[:-1]
@@ -131,6 +100,7 @@
 			self.modes_available = [ ]
 			return
 		self.modes_available = modes.split(' ')
+		print self.modes_available
 
 	def readPreferredModes(self):
 		try:
@@ -142,20 +112,23 @@
 
 		if self.modes_preferred != self.last_modes_preferred:
 			self.last_modes_preferred = self.modes_preferred
-			print "hotplug on dvi"
-			self.on_hotplug("DVI") # must be DVI
+			print "hotplug on hdmi"
+			self.on_hotplug("HDMI") # must be DVI
 
 	# check if a high-level mode with a given rate is available.
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
 			# DVI modes must be in "modes_preferred"
-#			if port == "DVI":
+			if port == "HDMI-PC":
+				return True
 #				if mode not in self.modes_preferred and not config.av.edid_override.value:
 #					print "no, not preferred"
 #					return False
 			if mode not in self.modes_available:
+				#print "isModeAvailable", mode, "false"
 				return False
+		#print "isModeAvailable", mode, "true"
 		return True
 
 	def isWidescreenMode(self, port, mode):
@@ -189,8 +162,11 @@
 			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
-
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gFBDC
+		gFBDC.getInstance().setResolution(-1, -1)
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -206,7 +182,7 @@
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -229,29 +205,20 @@
 		return res
 
 	def createConfig(self, *args):
-		hw_type = HardwareInfo().get_device_name()
-		lst = []
+		# create list of output ports
+		portlist = self.getPortList()
 
+		# create list of available modes
+		config.av.videoport = ConfigSelection(choices = [(port, _(port)) for port in portlist])
 		config.av.videomode = ConfigSubDict()
 		config.av.videorate = ConfigSubDict()
 
-		# create list of output ports
-		portlist = self.getPortList()
 		for port in portlist:
-			descr = port
-			if descr == 'DVI' and hw_type == 'dm500hd':
-				descr = 'HDMI'
-			elif descr == 'DVI-PC' and hw_type == 'dm500hd':
-				descr = 'HDMI-PC'
-			lst.append((port, descr))
-
-			# create list of available modes
 			modes = self.getModeList(port)
 			if len(modes):
 				config.av.videomode[port] = ConfigSelection(choices = [mode for (mode, rates) in modes])
 			for (mode, rates) in modes:
 				config.av.videorate[mode] = ConfigSelection(choices = rates)
-		config.av.videoport = ConfigSelection(choices = lst)
 
 	def setConfiguredMode(self):
 		port = config.av.videoport.value
@@ -297,17 +264,15 @@
 
 		force_widescreen = self.isWidescreenMode(port, mode)
 
-		is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
+		is_widescreen = force_widescreen or config.av.aspect.value in ["16_9", "16_10"]
 		is_auto = config.av.aspect.value == "auto"
-		policy2 = "policy" # use main policy
 
 		if is_widescreen:
 			if force_widescreen:
 				aspect = "16:9"
 			else:
 				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit"}[config.av.policy_43.value]
-			policy2 = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit"}[config.av.policy_169.value]
+			policy = {"pillarbox": "letterbox", "panscan": "panscan", "nonlinear": "nonlinear", "scale": "bestfit"}[config.av.policy_43.value]
 		elif is_auto:
 			aspect = "any"
 			policy = "bestfit"
@@ -320,14 +285,70 @@
 		else:
 			wss = "auto"
 
-		print "-> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss
+		print "-> setting aspect, policy, wss", aspect, policy, wss
 		open("/proc/stb/video/aspect", "w").write(aspect)
 		open("/proc/stb/video/policy", "w").write(policy)
 		open("/proc/stb/denc/0/wss", "w").write(wss)
-		try:
-			open("/proc/stb/video/policy2", "w").write(policy2)
-		except IOError:
-			pass
+		self.updateSlowblank()
+		self.updateFastblank()
+
+	def updateSlowblank(self):
+		if self.standby:
+			from Components.SystemInfo import SystemInfo
+			if SystemInfo["ScartSwitch"]:
+				input = "scart"
+				sb = "vcr"
+			else:
+				input = "off"
+				sb = "0"
+		else:
+			input = "encoder"
+			sb = "auto"
+
+		open("/proc/stb/avs/0/sb", "w").write(sb)
+		open("/proc/stb/avs/0/input", "w").write(input)
+
+	def updateStandby(self):
+		self.updateSlowblank()
+		self.updateFastblank()
+
+	def updateFastblank(self, *args):
+		if self.standby:
+			from Components.SystemInfo import SystemInfo
+			if SystemInfo["ScartSwitch"]:
+				fb = "vcr"
+			else:
+				fb = "low"
+		else:
+			if self.current_port == "Scart" and config.av.colorformat.value == "rgb":
+				fb = "high"
+			else:
+				fb = "low"
+		open("/proc/stb/avs/0/fb", "w").write(fb)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+
 
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
diff -Nur enigma2-nightly.org/lib/python/Screens/DefaultWizard.py enigma2-nightly/lib/python/Screens/DefaultWizard.py
--- enigma2-nightly.org/lib/python/Screens/DefaultWizard.py	2009-12-12 23:16:22.488600000 +0100
+++ enigma2-nightly/lib/python/Screens/DefaultWizard.py	2009-12-12 23:50:38.000000000 +0100
@@ -25,8 +25,13 @@
 		self["arrowup2"] = MovingPixmap()
 	
 	def setDirectory(self):
-		os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)))
-		self.directory = resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)
+#--->
+#-		os_system("mount %s %s" % (resolveFilename(SCOPE_DEFAULTPARTITION), resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)))
+#-		self.directory = resolveFilename(SCOPE_DEFAULTPARTITIONMOUNTDIR)
+#---<
+#+++>
+		self.directory = resolveFilename(SCOPE_DEFAULTDIR)
+#+++<
 		self.xmlfile = "defaultwizard.xml"
         
 	def markDone(self):
diff -Nur enigma2-nightly.org/lib/python/Screens/Wizard.py enigma2-nightly/lib/python/Screens/Wizard.py
--- enigma2-nightly.org/lib/python/Screens/Wizard.py	2009-12-12 23:16:22.492600000 +0100
+++ enigma2-nightly/lib/python/Screens/Wizard.py	2009-12-12 23:52:52.000000000 +0100
@@ -14,6 +14,9 @@
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	skin = """
@@ -360,6 +363,9 @@
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -448,6 +454,9 @@
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 		
 	def resetCounter(self):
diff -Nur enigma2-nightly.org/lib/service/Makefile.am enigma2-nightly/lib/service/Makefile.am
--- enigma2-nightly.org/lib/service/Makefile.am	2009-12-12 23:16:22.496600000 +0100
+++ enigma2-nightly/lib/service/Makefile.am	2009-12-12 23:59:16.000000000 +0100
@@ -1,5 +1,5 @@
 INCLUDES = \
-	-I$(top_srcdir)/include
+	-I$(top_srcdir)/include -I$(top_srcdir)/../misc/tools/libeplayer2/include
 
 noinst_LIBRARIES = libenigma_service.a
 
diff -Nur enigma2-nightly.org/lib/service/servicedvb.cpp enigma2-nightly/lib/service/servicedvb.cpp
--- enigma2-nightly.org/lib/service/servicedvb.cpp	2009-12-12 23:16:22.496600000 +0100
+++ enigma2-nightly/lib/service/servicedvb.cpp	2009-12-12 23:58:40.000000000 +0100
@@ -534,6 +534,9 @@
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
diff -Nur enigma2-nightly.org/lib/service/servicedvbrecord.cpp enigma2-nightly/lib/service/servicedvbrecord.cpp
--- enigma2-nightly.org/lib/service/servicedvbrecord.cpp	2009-12-12 23:16:22.496600000 +0100
+++ enigma2-nightly/lib/service/servicedvbrecord.cpp	2009-12-12 23:59:03.000000000 +0100
@@ -12,6 +12,26 @@
 #error no byte order defined!
 #endif
 
+#if defined(__sh__) 
+#include <sys/vfs.h> 
+//this is not available for stlinux :-( 
+//#include <linux/magic.h> 
+ 
+/* and these i dont get included :-( 
+#include <linux/usbdevice_fs.h> 
+#include <linux/smb.h> 
+#include <linux/nfs__fs.h> 
+#include <linux/ext3_fs.h> 
+
+so hack ;-) 
+*/ 
+#define USBDEVICE_SUPER_MAGIC 0x9fa2 
+#define EXT2_SUPER_MAGIC      0xEF53 
+#define EXT3_SUPER_MAGIC      0xEF53 
+#define SMB_SUPER_MAGIC       0x517B 
+#define NFS_SUPER_MAGIC       0x6969 
+#define MSDOS_SUPER_MAGIC     0x4d44            /* MD */ 
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref): m_ref(ref)
@@ -254,9 +274,43 @@
 	
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__) 
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__) 
+		//nit2005, we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0) 
+		{ 
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!"); 
+		} else 
+		{ 
+			if (sbuf.f_type == EXT3_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n"); 
+			else 
+			if (sbuf.f_type == NFS_SUPER_MAGIC) 
+			{ 
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n"); 
+				flags |= O_DIRECT; 
+			} 
+			else 
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - USB Device\n"); 
+			else 
+			if (sbuf.f_type == SMB_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - SMBs Device\n"); 
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC) 
+				eDebug("eDVBServiceRecord - MSDOS Device\n"); 
+		} 
+		fd = ::open(m_filename.c_str(), flags, 0644); 
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff -Nur enigma2-nightly.org/lib/service/servicemp3.h enigma2-nightly/lib/service/servicemp3.h
--- enigma2-nightly.org/lib/service/servicemp3.h	2009-12-12 23:16:22.500600000 +0100
+++ enigma2-nightly/lib/service/servicemp3.h	2009-12-13 00:41:07.000000000 +0100
@@ -1,13 +1,23 @@
 #ifndef __servicemp3_h
 #define __servicemp3_h
-
-#ifdef HAVE_GSTREAMER
+//#if not defined(__sh__)
+//#ifdef HAVE_GSTREAMER
+//#endif
 #include <lib/base/message.h>
 #include <lib/service/iservice.h>
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#if not defined(__sh__)
 #include <gst/gst.h>
+#else
+#include <common.h>
+#define gint int
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t		ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -44,7 +54,9 @@
 	int getInfo(const eServiceReference &ref, int w);
 };
 
+#if not defined(__sh__)
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC } audiotype_t;
 typedef enum { stPlainText, stSSA, stSRT } subtype_t;
@@ -102,7 +114,9 @@
 	RESULT getName(std::string &name);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#if not defined(__sh__)
 	PyObject *getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection	
 	int getNumberOfTracks();
@@ -131,6 +145,7 @@
 	void setAC3Delay(int);
 	void setPCMDelay(int);
 
+#if not defined(__sh__)
 	struct audioStream
 	{
 		GstPad* pad;
@@ -163,6 +178,39 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
+
 	struct bufferInfo
 	{
 		int bufferPercent;
@@ -197,31 +245,42 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#if not defined(__sh__)
 	GstElement *m_gst_playbin;
 	GstTagList *m_stream_tags;
+#else
+	Context_t * player;
+#endif
 	eFixedMessagePump<int> m_pump;
 	std::string m_error_message;
 
+#if not defined(__sh__)
 	audiotype_t gstCheckAudioPad(GstStructure* structure);
 	void gstBusCall(GstBus *bus, GstMessage *msg);
 	static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data);
 	static void gstCBsubtitleAvail(GstElement *element, gpointer user_data);
 	GstPad* gstCreateSubtitleSink(eServiceMP3* _this, subtype_t type);
 	void gstPoll(const int&);
-
+#else
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 	std::list<ePangoSubtitlePage> m_subtitle_pages;
 	ePtr<eTimer> m_subtitle_sync_timer;
 	void pushSubtitles();
 	void pullSubtitle();
 	int m_subs_to_pull;
 	eSingleLock m_subs_to_pull_lock;
+#if not defined(__sh__)
 	gulong m_subs_to_pull_handler_id;
-
+#endif
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+#if not defined(__sh__)
 	RESULT trickSeek(gdouble ratio);
-};
 #endif
-
+};
 #endif
+//#if not defined(__sh__)
+//#endif
+//#endif
diff -Nur enigma2-nightly.org/main/bsod.cpp enigma2-nightly/main/bsod.cpp
--- enigma2-nightly.org/main/bsod.cpp	2009-12-12 23:16:22.500600000 +0100
+++ enigma2-nightly/main/bsod.cpp	2009-12-12 23:19:55.585100263 +0100
@@ -15,7 +15,13 @@
 
 /************************************************/
 
+#if defined(__sh__)  
+#include <fcntl.h>
+#define CRASH_EMAILADDR "nobody" 
+int stopFBgui = 0;
+#else 
 #define CRASH_EMAILADDR "crashlog@dream-multimedia-tv.de"
+#endif
 #define STDBUFFER_SIZE 512
 #define RINGBUFFER_SIZE 16384
 static char ringbuffer[RINGBUFFER_SIZE];
@@ -446,6 +451,21 @@
 {
 	ucontext_t *uc = (ucontext_t*)ctx;
 
+#if defined(__sh__)  
+        if(signum == SIGUSR1)
+        {
+                //stop output of spinner
+                stopFBgui = 1;
+                return;
+        }
+        if(signum == SIGUSR2)
+        {
+                //stop output of gui 
+                stopFBgui = 0;
+                return;
+        }
+#endif
+
 #ifndef NO_OOPS_SUPPORT
 	oops(uc->uc_mcontext, signum == SIGSEGV || signum == SIGABRT);
 #endif
@@ -467,6 +498,12 @@
 	sigaction(SIGILL, &act, 0);
 	sigaction(SIGBUS, &act, 0);
 	sigaction(SIGABRT, &act, 0);
+#if defined(__sh__)  
+        sigaction(SIGUSR1, &act, 0);
+        sigaction(SIGUSR2, &act, 0);
+        int fd = open ("/tmp/.e2fbstopOk", O_RDWR | O_CREAT | O_TRUNC);
+        close(fd);
+#endif
 }
 
 void bsodLogInit()
diff -Nur enigma2-nightly.org/main/enigma.cpp enigma2-nightly/main/enigma.cpp
--- enigma2-nightly.org/main/enigma.cpp	2009-12-12 23:16:22.500600000 +0100
+++ enigma2-nightly/main/enigma.cpp	2009-12-12 23:20:35.880600970 +0100
@@ -29,6 +29,9 @@
 #include <lib/python/connections.h>
 #include <lib/python/python.h>
 
+#if defined(__sh__)  
+#include <lib/driver/vfd.h>  
+#endif  
 #include "bsod.h"
 
 #ifdef HAVE_GSTREAMER
@@ -235,6 +238,12 @@
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
+
+#if defined(__sh__)  
+	evfd * vfd = new evfd;  
+	vfd->init();  
+	delete vfd;  
+#endif  
 	
 	printf("executing main\n");
	
diff -Nur enigma2-nightly.org/main/Makefile.am enigma2-nightly/main/Makefile.am
--- enigma2-nightly.org/main/Makefile.am	2009-12-12 23:16:22.500600000 +0100
+++ enigma2-nightly/main/Makefile.am	2009-12-12 23:18:41.332599958 +0100
@@ -68,7 +68,7 @@
 	@LIBUNGIF_LIBS@ \
 	@XML2_LIBS@ \
 	@XMLCCWRAP_LIBS@ \
-	-ldl -lpthread -lcrypt -lresolv -lrt
+	-ldl -lpthread -lcrypt -lresolv -lrt -leplayer2  
 
 enigma2$(EXEEXT): $(enigma2_OBJECTS) $(enigma2_DEPENDENCIES) $(enigma2_LDADD_WHOLE)
 #	@rm -f enigma2$(EXEEXT)

diff -Nur enigma2-nightly.org/mytest.py enigma2-nightly.org/mytest.py
--- enigma2-nightly.org/mytest.py	2010-01-03 23:16:22.500600000 +0100
+++ enigma2-nightly.org/mytest.py	2010-01-03 23:18:41.332599958 +0100
@@ -301,4 +301,8 @@
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+#+++>
+		if dlg is None:
+			return
+#+++<
 		dlg.isTmp = True
 		dlg.callback = None
@@ -369,4 +373,8 @@
 		if action == "shutdown":
 			self.shutdown()
+#+++>
+		elif action == "standby":
+			self.standby()
+#+++<
 		elif action == "show_menu":
 			print "Show shutdown Menu"
@@ -501,8 +509,15 @@
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
-			wptime = nowTime + 30  # so switch back on in 30 seconds
-		else:
-			wptime = startTime[0] - 240
+#+++>
+#-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+#-			wptime = nowTime + 30  # so switch back on in 30 seconds
+#-		else:
+#-			wptime = startTime[0] - 240
+
+	        if (startTime[0] - nowTime) < 330: # no time to switch box back on
+		       wptime = nowTime + 30  # so switch back on in 30 seconds
+	        else:
+		       wptime = startTime[0] - 300
+#+++<
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))

diff -Nur enigma2-nightly.org/lib/python/Screens/InfoBar.py enigma2-nightly.org/lib/python/Screens/InfoBar.py
--- enigma2-nightly.org/lib/python/Screens/InfoBar.py	2010-02-07 23:16:22.500600000 +0100
+++ enigma2-nightly.org/lib/python/Screens/InfoBar.py	2010-02-07 23:18:41.332599958 +0100
@@ -7,15 +7,31 @@
 
 profile("LOAD:enigma")
-from enigma import iPlayableService
+#--->
+#-from enigma import iPlayableService
+#---<
+#+++>
+from enigma import iServiceInformation, iPlayableService 
+#+++<
 
 profile("LOAD:InfoBarGenerics")
+
+#-from Screens.InfoBarGenerics import InfoBarShowHide, \
+#-	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarRdsDecoder, \
+#-	InfoBarEPG, InfoBarSeek, InfoBarInstantRecord, \
+#-	InfoBarAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, \
+#-	InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
+#-	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView, \
+#-	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
+#-	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman
+#+++>
 from Screens.InfoBarGenerics import InfoBarShowHide, \
 	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarRdsDecoder, \
 	InfoBarEPG, InfoBarSeek, InfoBarInstantRecord, \
-	InfoBarAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarUnhandledKey, \
-	InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
+	InfoBarAudioSelection, InfoBarExtendedAudioSelection, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, \
+	InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, InfoBarShowMovies, InfoBarTimeshift,  \
 	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarSimpleEventView, \
 	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
-	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman
+	InfoBarSleepTimer, InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarUnhandledKey, InfoBarJobman
+#+++<
 
 profile("LOAD:InitBar_Components")
@@ -29,7 +45,17 @@
 class InfoBar(InfoBarBase, InfoBarShowHide,
 	InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder,
-	InfoBarInstantRecord, InfoBarAudioSelection, 
+#--->
+#-	InfoBarInstantRecord, InfoBarAudioSelection, 
+#---<
+#+++>
+	InfoBarInstantRecord, InfoBarAudioSelection, InfoBarExtendedAudioSelection, 
+#+++<
 	HelpableScreen, InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarUnhandledKey,
-	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#--->
+#-	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#---<
+#+++>
+	InfoBarSleepTimer, InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek,
+#+++<
 	InfoBarSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions,
 	InfoBarPiP, InfoBarPlugins, InfoBarSubtitleSupport, InfoBarServiceErrorPopupSupport, InfoBarJobman,
@@ -46,16 +72,32 @@
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+#+++>
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")), 
+				"volumeUp": (self._volUp, _("...")), 
+				"volumeDown": (self._volDown, _("...")), 
+#+++<
 			}, prio=2)
 		
 		self.allowPiP = True
-		
+#--->
+#-		for x in HelpableScreen, \
+#-				InfoBarBase, InfoBarShowHide, \
+#-				InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder, \
+#-				InfoBarInstantRecord, InfoBarAudioSelection, \
+#-				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
+#-				InfoBarTimeshift, InfoBarSeek, InfoBarSummarySupport, InfoBarTimeshiftState, \
+#-				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, \
+#-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+#---<
+#+++>
 		for x in HelpableScreen, \
 				InfoBarBase, InfoBarShowHide, \
 				InfoBarNumberZap, InfoBarChannelSelection, InfoBarMenu, InfoBarEPG, InfoBarRdsDecoder, \
-				InfoBarInstantRecord, InfoBarAudioSelection, InfoBarUnhandledKey, \
-				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, \
+				InfoBarInstantRecord, InfoBarAudioSelection, InfoBarExtendedAudioSelection, \
+				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarAspectSelection, InfoBarResolutionSelection, InfoBarSubserviceSelection, \
 				InfoBarTimeshift, InfoBarSeek, InfoBarSummarySupport, InfoBarTimeshiftState, \
 				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, \
-				InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+				InfoBarSleepTimer, InfoBarPlugins, InfoBarServiceErrorPopupSupport:
+#+++<		
 			x.__init__(self)
 
@@ -71,4 +113,39 @@
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
+
+#+++>
+		# I know that this is not nice but i dont know how to directly access VolumneControl
+		from Screens.Volume import Volume
+		self.volumeDialog = session.instantiateDialog(Volume)
+		from enigma import eTimer
+		self.hideVolTimer = eTimer()
+		self.hideVolTimer.callback.append(self.volHide)
+		from Components.config import config, ConfigSubsection, ConfigInteger
+		config.audio = ConfigSubsection()
+		config.audio.volume = ConfigInteger(default = 100, limits = (0, 100))
+		
+	def volHide(self):
+		self.volumeDialog.hide()
+
+	def _volUp(self):
+		print "_volUp"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeUp()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+
+	def _volDown(self):
+		print "_volDown"
+		from enigma import eDVBVolumecontrol
+		eDVBVolumecontrol.getInstance().volumeDown()
+		self.volumeDialog.setValue(eDVBVolumecontrol.getInstance().getVolume())
+		self.volumeDialog.show()
+		self.hideVolTimer.start(3000, True)
+		config.audio.volume.value = eDVBVolumecontrol.getInstance().getVolume()
+		config.audio.volume.save()
+#+++<
 
 	def __onClose(self):
@@ -90,4 +167,22 @@
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+#+++>
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService() 
+		info = service.info() 
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID) 
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID) 
+
+		print "sAudioPID", AudioPID 
+		print "sVideoPID", VideoPID 
+               
+		if VideoPID == -1: 
+			print "radio->tv" 
+			self.showTv2() 
+		else: 
+			print "tv->radio" 
+			self.showRadio2() 
+#+++<
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
@@ -112,4 +207,17 @@
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
+#+++>
+	def showTv2(self):
+		self.showTvChannelList(False)
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+ 		else:
+ 			self.rds_display.hide() # in InfoBarRdsDecoder
+ 			from Screens.ChannelSelection import ChannelSelectionRadio
+ 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+#+++<
 
 	def ChannelSelectionRadioClosed(self, *arg):
@@ -213,4 +305,9 @@

 		if answer in ("quit", "quitanddeleteconfirmed"):
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.close()
 		elif answer == "movielist":
@@ -219,4 +333,9 @@
 			from Screens.MovieSelection import MovieSelection
 			self.session.openWithCallback(self.movieSelected, MovieSelection, ref)
+#+++> 
+                        # make sure that playback is unpaused otherwise the  
+                        # player driver might stop working 
+                        self.setSeekState(self.SEEK_STATE_PLAY) 
+#+++<
 			self.session.nav.stopService()
 		elif answer == "restart":
diff -Nur enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py
--- enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py	2010-01-26 23:16:22.500600000 +0100
+++ enigma2-nightly.org/lib/python/Screens/InfoBarGenerics.py	2010-03-10 23:18:41.332599958 +0100
@@ -45,4 +45,8 @@
 from Menu import MainMenu, mdom
 
+#+++>
+txtIsStarting = False
+#+++<
+
 class InfoBarDish:
 	def __init__(self):
@@ -89,4 +93,7 @@
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+#+++>
+	STATE_EPG = 4
+#+++<
 
 	def __init__(self):
@@ -139,10 +146,32 @@
 			self.hide()
 
+#+++>
+	def epg(self): 
+		self.__state = self.STATE_EPG 
+		self.hide() 
+		self.hideTimer.stop() 
+		self.openEventView() 
+#+++<
+
 	def toggleShow(self):
-		if self.__state == self.STATE_SHOWN:
-			self.hide()
-			self.hideTimer.stop()
-		elif self.__state == self.STATE_HIDDEN:
-			self.show()
+#--->
+#-		if self.__state == self.STATE_SHOWN:
+#-			self.hide()
+#-			self.hideTimer.stop()
+#-		elif self.__state == self.STATE_HIDDEN:
+#-			self.show()
+#---<
+#+++>
+		if self.__state == self.STATE_SHOWN: 
+			print "self.STATE_SHOWN" 
+			self.epg() 
+		elif self.__state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.show() 
+		elif self.__state == self.STATE_EPG: 
+			print "self.STATE_EPG" 
+			self.hide() 
+			self.hideTimer.stop() 
+#+++<
 
 	def lockShow(self):
@@ -1327,5 +1356,10 @@
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#--->
+#-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+#---<
+#+++>
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
+#+++<
 		self.extensionKeys = {}
 		for x in self.list:
@@ -1404,4 +1438,16 @@
 
 # depends on InfoBarExtensions
+
+class InfoBarSleepTimer:
+	def __init__(self):
+		self.addExtension((self.getSleepTimerName, self.showSleepTimerSetup, lambda: True), "1")
+
+	def getSleepTimerName(self):
+		return _("Sleep Timer")
+
+	def showSleepTimerSetup(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
+
 class InfoBarPiP:
 	def __init__(self):
@@ -1793,4 +1839,151 @@
 			self.audioChannel.selectChannel(mode[1])
 		del self.audioChannel
+
+#+++>
+class InfoBarExtendedAudioSelection:
+	STATE_HIDDEN = 0 
+	STATE_AUDIO = 1 
+	STATE_SUBSERVICE = 2 
+
+	def __init__(self):
+		self["ExtendedAudioSelectionAction"] = HelpableActionMap(self, "InfobarExtendedAudioSelectionActions",
+			{
+				"audioSelection": (self.EXtoggleYellow, _("Audio Options...")),
+			})
+		self.__state = self.STATE_HIDDEN 
+
+	def EXdoAudio(self): 
+		self.__state = self.STATE_AUDIO 
+		self.EXaudioSelection() 
+
+	def EXdoSubService(self): 
+		self.__state = self.STATE_SUBSERVICE 
+		self.subserviceSelection() 
+
+	def EXdoHide(self): 
+		self.__state = self.STATE_HIDDEN 
+
+	def EXtoggleYellow(self, arg=""): 
+		print self.__state 
+		if self.__state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.EXdoAudio() 
+		elif self.__state == self.STATE_AUDIO: 
+			print "self.STATE_AUDIO" 
+			self.EXdoSubService() 
+		elif self.__state == self.STATE_SUBSERVICE: 
+			print "self.STATE_SUBSERVICE" 
+			self.EXdoHide() 
+
+	def EXaudioSelection(self):
+		service = self.session.nav.getCurrentService()
+		self.audioTracks = audio = service and service.audioTracks()
+		n = audio and audio.getNumberOfTracks() or 0
+		tlist = []
+		if n > 0:
+			self.audioChannel = service.audioChannel()
+
+			for x in range(n):
+				i = audio.getTrackInfo(x)
+				language = i.getLanguage()
+				description = i.getDescription()
+
+				if LanguageCodes.has_key(language):
+					language = LanguageCodes[language][0]
+
+				if len(description):
+					description += " (" + language + ")"
+				else:
+					description = language
+
+				tlist.append((description, x))
+
+			tlist.sort(key=lambda x: x[0])
+
+			selectedAudio = self.audioTracks.getCurrentTrack()
+
+			selection = 0
+
+			for x in tlist:
+				if x[1] != selectedAudio:
+					selection += 1
+				else:
+					break
+
+			if SystemInfo["CanDownmixAC3"]:
+				tlist = [(_("AC3 downmix") + " - " +[_("Off"), _("On")][config.av.downmix_ac3.value and 1 or 0], "CALLFUNC", self.EXchangeAC3Downmix),
+					([_("Left"), _("Stereo"), _("Right")][self.audioChannel.getCurrentChannel()], "mode"),
+					(_("Subservice"), "subservice"),#"CALLFUNC", self.toggleYellow), 
+					("--", "")] + tlist
+				keys = [ "red", "green", "yellow", "", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"] + [""]*n
+				selection += 4
+			else:
+				tlist = [([_("Left"), _("Stereo"), _("Right")][self.audioChannel.getCurrentChannel()], "mode"), (_("Subservice"), "subservice"), ("--", "")] + tlist
+				keys = [ "red", "yellow", "", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"] + [""]*n
+				selection += 3
+			self.session.openWithCallback(self.EXaudioSelected, ChoiceBox, title=_("Select audio track"), list = tlist, selection = selection, keys = keys)
+		else:
+			del self.audioTracks
+
+	def EXchangeAC3Downmix(self, arg):
+		choicelist = self.session.current_dialog["list"]
+		list = choicelist.list
+		t = list[0][1]
+		list[0][1]=(t[0], t[1], t[2], t[3], t[4], t[5], t[6],
+			_("AC3 downmix") + " - " +[_("On"), _("Off")][config.av.downmix_ac3.value and 1 or 0])
+		choicelist.setList(list)
+		if config.av.downmix_ac3.value:
+			config.av.downmix_ac3.value = False
+		else:
+			config.av.downmix_ac3.value = True
+		config.av.downmix_ac3.save()
+
+	def EXaudioSelected(self, audio):
+		if audio is not None:
+			if isinstance(audio[1], str):
+				if audio[1] == "subservice":
+					service = self.session.nav.getCurrentService()
+					#subservices = service and service.subServices()
+					try:
+						del self.audioChannel
+					except AttributeError:
+						print "no such Attribute"
+					try:
+						del self.audioTracks
+					except AttributeError:
+						print "no such Attribute"
+					if service.subServices().getNumberOfSubservices() > 0:
+						#del self.audioChannel
+						#del self.audioTracks
+						self.EXtoggleYellow()
+
+				elif audio[1] == "mode":
+					keys = ["red", "green", "yellow"]
+					selection = self.audioChannel.getCurrentChannel()
+					tlist = [(_("left"), 0), (_("stereo"), 1), (_("right"), 2)]
+					self.session.openWithCallback(self.EXmodeSelected, ChoiceBox, title=_("Select audio mode"), list = tlist, selection = selection, keys = keys)
+					
+			else: #if isinstance(audio[1], str):
+				del self.audioChannel
+				if self.session.nav.getCurrentService().audioTracks().getNumberOfTracks() > audio[1]:
+					self.audioTracks.selectTrack(audio[1])
+
+		else:
+			try:
+				del self.audioChannel
+			except AttributeError:
+				print "no such Attribute"
+		try:
+			del self.audioTracks
+		except AttributeError:
+			print "no such Attribute"
+			
+		self.EXdoHide() 
+
+	def EXmodeSelected(self, mode):
+		if mode is not None:
+			self.audioChannel.selectChannel(mode[1])
+		del self.audioChannel
+#+++<
 
 class InfoBarSubserviceSelection:
@@ -1870,14 +2063,41 @@
 
 			if self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#--->
+#-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#---<
+#+++>
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#+++<
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
 				else:
-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#--->
+#-					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+#---<
+#+++>
+					tlist = [(_("Quickzap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+#+++<
+#--->
+#-				selection += 3
+#---<
+#+++>
+				selection += 4
+#+++<
+			else:
+#--->
+#-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
+#-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+#-				selection += 2
+#---<
+#+++>
+				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				selection += 3
-			else:
-				tlist = [(_("Quickzap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
+#+++<
 
 			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a subservice..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
@@ -1919,4 +2139,127 @@
 		else:
 			del self.selectedSubservice
+
+#+++>
+class InfoBarAspectSelection: 
+	STATE_HIDDEN = 0 
+	STATE_ASPECT = 1 
+	STATE_RESOLUTION = 2 
+	def __init__(self): 
+		self["AspectSelectionAction"] = HelpableActionMap(self, "InfobarAspectSelectionActions", 
+			{ 
+				"aspectSelection": (self.ExGreen_toggleGreen, _("Aspect list...")), 
+			}) 
+
+		self.__ExGreen_state = self.STATE_HIDDEN 
+
+	def ExGreen_doAspect(self): 
+		self.__ExGreen_state = self.STATE_ASPECT 
+		self.aspectSelection() 
+
+	def ExGreen_doResolution(self): 
+		self.__ExGreen_state = self.STATE_RESOLUTION 
+		self.resolutionSelection() 
+
+	def ExGreen_doHide(self): 
+		self.__ExGreen_state = self.STATE_HIDDEN 
+
+	def ExGreen_toggleGreen(self, arg=""): 
+		print self.__ExGreen_state 
+		if self.__ExGreen_state == self.STATE_HIDDEN: 
+			print "self.STATE_HIDDEN" 
+			self.ExGreen_doAspect() 
+		elif self.__ExGreen_state == self.STATE_ASPECT: 
+			print "self.STATE_ASPECT" 
+			self.ExGreen_doResolution() 
+		elif self.__ExGreen_state == self.STATE_RESOLUTION: 
+			print "self.STATE_RESOLUTION" 
+			self.ExGreen_doHide() 
+
+	def aspectSelection(self): 
+		selection = 0 
+		tlist = [] 
+		tlist.append((_("Resolution"), "resolution")) 
+		tlist.append(("", "")) 
+		tlist.append(("Letterbox", "letterbox")) 
+		tlist.append(("PanScan", "panscan")) 
+		tlist.append(("Non Linear", "non")) 
+		tlist.append(("Bestfit", "bestfit")) 
+
+		mode = open("/proc/stb/video/policy").read()[:-1] 
+		print mode 
+		for x in range(len(tlist)): 
+			if tlist[x][1] == mode: 
+				selection = x 
+
+		keys = ["green", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] 
+
+
+		self.session.openWithCallback(self.aspectSelected, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys) 
+	def aspectSelected(self, aspect): 
+		if not aspect is None: 
+			if isinstance(aspect[1], str): 
+				if aspect[1] == "resolution":
+					self.ExGreen_toggleGreen()
+				else:
+					open("/proc/stb/video/policy", "w").write(aspect[1]) 
+					self.ExGreen_doHide()
+		return 
+
+class InfoBarResolutionSelection: 
+	def __init__(self): 
+		return
+
+	def resolutionSelection(self): 
+
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+
+		selection = 0 
+		tlist = [] 
+		tlist.append((_("Exit"), "exit")) 
+		tlist.append((_("Auto(not available)"), "auto")) 
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", "")) 
+		tlist.append(("--", "")) 
+		tlist.append(("576i", "576i50")) 
+		tlist.append(("576p", "576p50")) 
+		tlist.append(("720p", "720p50")) 
+		tlist.append(("1080i", "1080i50")) 
+		tlist.append(("1080p@23.976hz", "1080p23")) 
+		tlist.append(("1080p@24hz", "1080p24")) 
+		tlist.append(("1080p@25hz", "1080p25")) 
+		
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] 
+
+		mode = open("/proc/stb/video/videomode").read()[:-1] 
+		print mode 
+		for x in range(len(tlist)): 
+			if tlist[x][1] == mode: 
+				selection = x 
+
+		self.session.openWithCallback(self.ResolutionSelected, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys) 
+
+	def ResolutionSelected(self, Resolution): 
+		if not Resolution is None: 
+			if isinstance(Resolution[1], str): 
+				if Resolution[1] == "exit":
+					self.ExGreen_toggleGreen()
+				elif Resolution[1] != "auto":
+					open("/proc/stb/video/videomode", "w").write(Resolution[1]) 
+					from enigma import gFBDC
+					gFBDC.getInstance().setResolution(-1, -1)
+					self.ExGreen_toggleGreen()
+		return 
+
+
+
+#+++<
 
 class InfoBarAdditionalInfo:
@@ -2246,5 +2589,20 @@
 
 	def startTeletext(self):
-		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#--->
+#		self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+#---<
+#+++>
+		global txtIsStarting
+		if txtIsStarting is False:
+			self.teletext_plugin(session=self.session, service=self.session.nav.getCurrentService())
+			txtIsStarting = True
+			self.txtIsStartingTimer = eTimer()
+			self.txtIsStartingTimer.callback.append(self.txtIsStartingEnd)
+			self.txtIsStartingTimer.start(10000, True)
+
+	def txtIsStartingEnd(self):
+		global txtIsStarting
+		txtIsStarting = False
+#+++<
 
 class InfoBarSubtitleSupport(object):

diff -Nur enigma2-nightly.org/lib/python/Components/VolumeControl.py enigma2-nightly.org/lib/python/Components/VolumeControl.py
--- enigma2-nightly.org/lib/python/Components/VolumeControl.py	2010-01-14 23:16:22.500600000 +0100
+++ enigma2-nightly.org/lib/python/Components/VolumeControl.py	2010-01-14 23:18:41.332599958 +0100
@@ -68,5 +68,13 @@
 
 	def volMute(self, showMuteSymbol=True, force=False):
-		vol = self.volctrl.getVolume()
+#--->
+#-		vol = self.volctrl.getVolume()
+#---<
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
@@ -75,5 +83,11 @@
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<

diff -Nur enigma2-nightly.org/lib/python/Components/UsageConfig.py enigma2-nightly.org/lib/python/Components/UsageConfig.py
--- enigma2-nightly.org/lib/python/Components/UsageConfig.py	2010-01-17 23:16:22.500600000 +0100
+++ enigma2-nightly.org/lib/python/Components/UsageConfig.py	2010-01-17 23:18:41.332599958 +0100
@@ -52,4 +52,7 @@
 	config.usage.on_long_powerpress = ConfigSelection(default = "show_menu", choices = [
 		("show_menu", _("show shutdown menu")),
+#+++>
+		("standby", _("immediate standby")),
+#+++<
 		("shutdown", _("immediate shutdown")) ] )
 
diff -Nur enigma2-nightly.org/RecordTimer.py enigma2-nightly/RecordTimer.py
--- enigma2-nightly.org/RecordTimer.py	2010-02-16 19:28:48.000000000 +0100
+++ enigma2-nightly/RecordTimer.py	2010-02-16 19:32:07.000000000 +0100
@@ -292,6 +292,12 @@
 						RecordTimerEntry.TryQuitMainloop() # start shutdown handling without screen
 					else:
 						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20)
+                        elif self.afterEvent == AFTEREVENT.AUTO:
+                                if not Screens.Standby.inTryQuitMainloop: # not a shutdown messagebox is open
+                                        timerStart = open("/proc/stb/fp/was_timer_wakeup").read()
+                                        if timerStart[:1] == "1":
+						Notifications.AddNotificationWithCallback(self.sendTryQuitMainloopNotification, MessageBox, _("A finished record timer wants to shut down\nyour Dreambox. Shutdown now?"), timeout = 20) 
+
 			return True
 
 	def setAutoincreaseEnd(self, entry = None):

diff -Nur enigma2-nightly.org/lib/gdi/gpixmap.cpp
--- enigma2-nightly/lib/gdi/gpixmap.cpp	2010-03-02 23:06:31.000000000 -0500
+++ enigma2-nightly/lib/gdi/gpixmap.cpp	2010-03-02 23:08:40.000000000 -0500
@@ -326,7 +326,10 @@
 		if (flag & blitScale)
 		{
 			eWarning("unimplemented: scale on non-accel surfaces");
+//if accel blit fails, do direkt blit
+#ifndef __sh__
 			continue;
+#endif
 		}
 
 		if ((surface->bpp == 8) && (src.surface->bpp==8))

diff -Nur enigma2-nightly.org/lib/python/Components/Renderer/Progress.py enigma2-nightly/lib/python/Components/Renderer/Progress.py
--- enigma2-nightly.org/lib/python/Components/Renderer/Progress.py	2009-12-12 23:16:22.424599000 +0100
+++ enigma2-nightly/lib/python/Components/Renderer/Progress.py	2009-12-12 23:44:58.000000000 +0100
@@ -14,24 +14,58 @@
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
+#--->
+#-		if what[0] == self.CHANGED_CLEAR:
+#-			(self.range, self.value) = ((0, 1), 0)
+#-			return
+#-
+#-		range = self.source.range or 100
+#-		value = self.source.value
+#-		if value is None:
+#-			value = 0
+#-		(self.range, self.value) = ((0, range), value)
+#---<
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
 
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
 
 	GUI_WIDGET = eSlider
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
-
+#--->
+#-		instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
-
+#--->
+#-		(self.__start, self.__end) = range
+#-		if self.instance is not None:
+#-			self.instance.setRange(self.__start, self.__end)
+#---<
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 	def getRange(self):
 		return (self.__start, self.__end)

diff -Nur enigma2-nightly.org/lib/python/Components/Harddisk.py enigma2-nightly/lib/python/Components/Harddisk.py
--- enigma2-nightly.org/lib/python/Components/Harddisk.py	2010-01-17 23:16:22.420599000 +0100
+++ enigma2-nightly/lib/python/Components/Harddisk.py	2010-01-17 23:46:13.000000000 +0100
@@ -1,8 +1,25 @@
-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
-from Tools.Directories import SCOPE_HDD, resolveFilename
+#--->
+#-from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access
+#-from Tools.Directories import SCOPE_HDD, resolveFilename
+#---<
+#+++>
+from os import system, listdir, statvfs, popen, makedirs, stat, major, minor, path, access, readlink, remove, path as os_path
+from Tools.Directories import SCOPE_HDD, resolveFilename, removeDir
+#+++<
 from Tools.CList import CList
 from SystemInfo import SystemInfo
 import time
 from Components.Console import Console
+#+++>
+from enigma import eConsoleAppContainer, evfd
+import os
+
+def tryOpen(filename):
+	try:
+		procFile = open(filename)
+	except IOError:
+		return ""
+	return procFile
+#+++<
 
 def readFile(filename):
@@ -19,11 +36,14 @@
 		self.device = device
 
-		if access("/dev/.udev", 0):
-			self.type = self.DEVTYPE_UDEV
-		elif access("/dev/.devfsd", 0):
-			self.type = self.DEVTYPE_DEVFS
-		else:
-			print "Unable to determine structure of /dev"
-
+#--->
+#-		if access("/dev/.udev", 0):
+#-			self.type = self.DEVTYPE_UDEV
+#-		elif access("/dev/.devfsd", 0):
+#-			self.type = self.DEVTYPE_DEVFS
+#-		else:
+#-			print "Unable to determine structure of /dev"
+#+++>
+		self.type = self.DEVTYPE_UDEV
+#+++<
 		self.max_idle_time = 0
 		self.idle_running = False
@@ -33,5 +53,6 @@
 		self.disk_path = ''
 		self.phys_path = path.realpath(self.sysfsPath('device'))
-
+		
+		print "[Harddisk] found: ", self.phys_path
 		if self.type == self.DEVTYPE_UDEV:
 			self.dev_path = '/dev/' + self.device
@@ -44,5 +65,5 @@
 			for disc in listdir("/dev/discs"):
 				dev_path = path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
+ 				disk_path = dev_path + '/disc'
 				try:
 					rdev = stat(disk_path).st_rdev
@@ -172,11 +193,20 @@
 			parts = line.strip().split(" ")
 			if path.realpath(parts[0]).startswith(self.dev_path):
-				cmd = ' ' . join([cmd, parts[1]])
-
+#--->			
+#-				cmd = ' ' . join([cmd, parts[1]])
+#---<
+#+++>
+				cmd = ' -fl ' . join([cmd, parts[1]])
+#+++<
 		res = system(cmd)
 		return (res >> 8)
 
 	def createPartition(self):
-		cmd = 'printf "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#--->
+#-		cmd = 'printf "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#---<
+#+++>
+		cmd = 'echo "0,\n;\n;\n;\ny\n" | sfdisk -f ' + self.disk_path
+#+++<
 		res = system(cmd)
 		return (res >> 8)
@@ -186,6 +216,19 @@
 		if self.diskSize() > 4 * 1024:
 			cmd += "-T largefile "
-		cmd += "-m0 -O dir_index " + self.partitionPath("1")
-		res = system(cmd)
+
+		cmd += "-m0 -O dir_index -L RECORD " + self.partitionPath("1")
+		print "cmd", cmd
+#--->
+#-		res = system(cmd)
+#---<
+#+++>
+		print "[Harddisk] mkfs: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
@@ -203,5 +246,5 @@
 			parts = line.strip().split(" ")
 			if path.realpath(parts[0]) == self.partitionPath("1"):
-				cmd = "mount -t ext3 " + parts[0]
+				cmd = "mount -t ext3 " + parts[0] + " /media/hdd"
 				res = system(cmd)
 				break
@@ -220,5 +263,16 @@
 		# TODO: we could check if the fs is actually ext3
 		cmd = "fsck.ext3 -f -p " + self.partitionPath("1")
-		res = system(cmd)
+#--->
+#-		res = system(cmd)
+#---<
+#+++>		
+		print "[Harddisk] fsck: ", cmd
+		if os.path.exists("/sbin/cmd") is True:
+			self.container = eConsoleAppContainer()
+			self.container.execute("/sbin/cmd " + cmd)
+			res = 0
+		else:	
+			res = system(cmd)
+#+++<
 		return (res >> 8)
 
@@ -395,26 +449,45 @@
 		return False
 
+#--->
+#-DEVICEDB =  \
+#-	{"dm8000":
+#-		{
+#-			# dm8000:
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": "Front USB Slot",
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.2/1-1.2:1.0": "Back, upper USB Slot",
+#-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.3/1-1.3:1.0": "Back, lower USB Slot",
+#-			"/devices/platform/brcm-ehci-1.1/usb2/2-1/2-1:1.0/host1/target1:0:0/1:0:0:0": "DVD Drive",
+#-		},
+#-	"dm800":
+#-	{
+#-		# dm800:
+#-		"/devices/platform/brcm-ehci.0/usb1/1-2/1-2:1.0": "Upper USB Slot",
+#-		"/devices/platform/brcm-ehci.0/usb1/1-1/1-1:1.0": "Lower USB Slot",
+#-	},
+#-	"dm7025":
+#-	{
+#-		# dm7025:
+#-		"/devices/pci0000:00/0000:00:14.1/ide1/1.0": "CF Card Slot", #hdc
+#-		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk"
+#-	}
+#-	}
+#---<
+#+++>
 DEVICEDB =  \
-	{"dm8000":
+	{"ufs910":
 		{
-			# dm8000:
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.1/1-1.1:1.0": "Front USB Slot",
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.2/1-1.2:1.0": "Back, upper USB Slot",
-			"/devices/platform/brcm-ehci.0/usb1/1-1/1-1.3/1-1.3:1.0": "Back, lower USB Slot",
-			"/devices/platform/brcm-ehci-1.1/usb2/2-1/2-1:1.0/host1/target1:0:0/1:0:0:0": "DVD Drive",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.4/1-1.4:1.0": "Front USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0": "Back, upper USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0": "Back, lower USB Slot",
 		},
-	"dm800":
-	{
-		# dm800:
-		"/devices/platform/brcm-ehci.0/usb1/1-2/1-2:1.0": "Upper USB Slot",
-		"/devices/platform/brcm-ehci.0/usb1/1-1/1-1:1.0": "Lower USB Slot",
-	},
-	"dm7025":
-	{
-		# dm7025:
-		"/devices/pci0000:00/0000:00:14.1/ide1/1.0": "CF Card Slot", #hdc
-		"/devices/pci0000:00/0000:00:14.1/ide0/0.0": "Internal Harddisk"
+	"UFS922":
+		{
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.1/1-1.1:1.0/": "Back, upper USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.2/1-1.2:1.0/": "Back, lower USB Slot",
+			"/devices/platform/ST40-ehci.2/usb1/1-1/1-1.3/1-1.3:1.0/": "Front USB Slot",
+		}	
 	}
-	}
+#+++<
+
 
 class HarddiskManager:
@@ -441,4 +514,6 @@
 					("/media/ram", _("Ram Disk")),
 					("/media/usb", _("USB Stick")),
+					("/media/upnp", _("UPNP Stick")),
+					("/media/ftp", _("FTP Stick")),
 					("/", _("Internal Flash"))
 				]
@@ -456,5 +531,10 @@
 			removable = bool(int(readFile(devpath + "/removable")))
 			dev = int(readFile(devpath + "/dev").split(':')[0])
-			if dev in (7, 31): # loop, mtdblock
+#--->
+#-			if dev in (7, 31): # loop, mtdblock
+#---<
+#+++>
+			if dev in [1, 7, 31, 253]: # ram, loop, mtdblock, ramzswap
+#+++<
 				blacklisted = True
 			if blockdev[0:2] == 'sr':
@@ -516,4 +596,11 @@
 				physdev = dev
 				print "couldn't determine blockdev physdev for device", device
+#+++>		
+		else:
+			dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start automount"
+			#Automount(device,"mount")
+#+++<		
 
 		# device is the device name, without /dev
@@ -548,4 +635,10 @@
 					break
 			SystemInfo["Harddisk"] = len(self.hdd) > 0
+#+++>
+		dev, part = self.splitDeviceName(device)
+		if part is not 0:
+			print "[Harddisk] start auto umount"
+			#Automount(device,"umount")
+#+++<
 
 	def HDDCount(self):
@@ -617,4 +710,4 @@
 				self.partitions.remove(x)
 				self.on_partition_list_change("remove", x)
-
+		
 harddiskmanager = HarddiskManager()

diff -Nur enigma2-nightly.org/lib/service/servicemp3.cpp enigma2-nightly/lib/service/servicemp3.cpp
--- enigma2-nightly.org/lib/service/servicemp3.cpp	2009-12-12 23:16:22.496600000 +0100
+++ enigma2-nightly/lib/service/servicemp3.cpp	2009-12-13 00:07:10.000000000 +0100
@@ -1,4 +1,6 @@
-#ifdef HAVE_GSTREAMER
+//#if not defined(__sh__)
+//#ifdef HAVE_GSTREAMER
+//#endif
 
 	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
 	/* it's currently hardcoded to use a big-endian alsasink as sink. */
@@ -16,8 +18,10 @@
 
 #include <string>
 
+#if not defined(__sh__)
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
 // eServiceFactoryMP3
@@ -25,14 +29,16 @@
 eServiceFactoryMP3::eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
-	
+
 	eServiceCenter::getPrivInstance(sc);
 	if (sc)
 	{
 		std::list<std::string> extensions;
 		extensions.push_back("mp2");
 		extensions.push_back("mp3");
+#if not defined(__sh__)
 		extensions.push_back("ogg");
+#endif
 		extensions.push_back("mpg");
 		extensions.push_back("vob");
 		extensions.push_back("wav");
@@ -42,10 +48,22 @@
 		extensions.push_back("avi");
 		extensions.push_back("divx");
 		extensions.push_back("dat");
+#if not defined(__sh__)
 		extensions.push_back("flac");
+#endif
 		extensions.push_back("mp4");
+#if not defined(__sh__)
 		extensions.push_back("mov");
+#endif
 		extensions.push_back("m4a");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("wma");
+		extensions.push_back("mts");
+#endif
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
 
@@ -55,7 +73,7 @@
 eServiceFactoryMP3::~eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
-	
+
 	eServiceCenter::getPrivInstance(sc);
 	if (sc)
 		sc->removeServiceFactory(eServiceFactoryMP3::id);
@@ -95,7 +113,7 @@
 	eServiceReference m_ref;
 public:
 	eMP3ServiceOfflineOperations(const eServiceReference &ref);
-	
+
 	RESULT deleteFromDisk(int simulate);
 	RESULT getListOfFilenames(std::list<std::string> &);
 	RESULT reindex();
@@ -116,11 +134,11 @@
 		std::list<std::string> res;
 		if (getListOfFilenames(res))
 			return -1;
-		
+
 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
 		if (!eraser)
 			eDebug("FATAL !! can't get background file eraser");
-		
+
 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
 		{
 			eDebug("Removing %s...", i->c_str());
@@ -129,7 +147,7 @@
 			else
 				::unlink(i->c_str());
 		}
-		
+
 		return 0;
 	}
 }
@@ -206,7 +224,7 @@
 	}
 	return iServiceInformation::resNA;
 }
- 
+
 
 // eServiceMP3
 int eServiceMP3::ac3_delay,
@@ -217,7 +235,9 @@
 {
 	m_seekTimeout = eTimer::create(eApp);
 	m_subtitle_sync_timer = eTimer::create(eApp);
+#if not defined(__sh__)
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = 0;
 	m_subtitle_widget = 0;
@@ -226,7 +246,9 @@
 	m_buffer_size = 1*1024*1024;
 	CONNECT(m_seekTimeout->timeout, eServiceMP3::seekTimeoutCB);
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#if not defined(__sh__)
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
 
 	m_state = stIdle;
@@ -237,6 +259,7 @@
 	if (!ext)
 		ext = filename;
 
+#if not defined(__sh__)
 	sourceStream sourceinfo;
 	sourceinfo.is_video = FALSE;
 	sourceinfo.audiotype = atUnknown;
@@ -359,10 +382,147 @@
 	}
 
 	setBufferSize(m_buffer_size);
+#else
+    player = (Context_t*) malloc(sizeof(Context_t));
+
+    if(player) {
+	    player->playback	= &PlaybackHandler;
+	    player->output		= &OutputHandler;
+	    player->container	= &ContainerHandler;
+	    player->manager		= &ManagerHandler;
+
+    	printf("%s\n", player->output->Name);
+    }
+
+	//Registration of output devices
+    if(player && player->output) {
+	    player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+	    player->output->Command(player,OUTPUT_ADD, (void*)"video");
+	    player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+    }
+
+    //create playback path
+    char file[400] = {""};
+
+    if(!strncmp("http://", m_ref.path.c_str(), 7))
+        ;
+    else if(!strncmp("file://", m_ref.path.c_str(), 7))
+        ;
+    else
+        strcat(file, "file://");
+
+    strcat(file, m_ref.path.c_str());
+
+    //try to open file
+	if(player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0) {
+
+        //VIDEO
+            //We dont have to register video tracks, or do we ?
+
+        //AUDIO
+        if(player && player->manager && player->manager->audio) {
+            char ** TrackList = NULL;
+		    player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+		    if (TrackList != NULL) {
+			    printf("AudioTrack List\n");
+			    int i = 0;
+			    for (i = 0; TrackList[i] != NULL; i+=2) {
+				    printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+                    audioStream audio;
+
+                    audio.language_code = TrackList[i];
+
+                    // atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+                    if(     !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+                        audio.type = atMP3;
+                    else if(!strncmp("A_AC3",       TrackList[i+1], 5))
+                        audio.type = atAC3;
+                    else if(!strncmp("A_DTS",       TrackList[i+1], 5))
+                        audio.type = atDTS;
+                    else if(!strncmp("A_AAC",       TrackList[i+1], 5))
+                        audio.type = atAAC;
+                    else if(!strncmp("A_PCM",       TrackList[i+1], 5))
+                        audio.type = atPCM;
+                    else if(!strncmp("A_VORBIS",    TrackList[i+1], 8))
+                        audio.type = atOGG;
+                    else if(!strncmp("A_FLAC",      TrackList[i+1], 6))
+                        audio.type = atFLAC;
+                    else
+		                audio.type = atUnknown;
+
+		            m_audioStreams.push_back(audio);
+
+				    free(TrackList[i]);
+                    free(TrackList[i+1]);
+			    }
+			    free(TrackList);
+		    }
+        }
+
+        //SUB
+        if(player && player->manager && player->manager->subtitle) {
+            char ** TrackList = NULL;
+		    player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+		    if (TrackList != NULL) {
+			    printf("SubtitleTrack List\n");
+			    int i = 0;
+			    for (i = 0; TrackList[i] != NULL; i+=2) {
+				    printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+                    subtitleStream sub;
+
+                    sub.language_code = TrackList[i];
+
+                    //  stPlainText, stSSA, stSRT
+                    if(     !strncmp("S_TEXT/SSA",  TrackList[i+1], 10) ||
+                            !strncmp("S_SSA",       TrackList[i+1], 5))
+                        sub.type = stSSA;
+                    else if(!strncmp("S_TEXT/ASS",  TrackList[i+1], 10) ||
+                            !strncmp("S_AAS",       TrackList[i+1], 5))
+                        sub.type = stSSA;
+                    else if(!strncmp("S_TEXT/SRT",  TrackList[i+1], 10) ||
+                            !strncmp("S_SRT",       TrackList[i+1], 5))
+                        sub.type = stSRT;
+                    else
+		                sub.type = stPlainText;
+
+		            m_subtitleStreams.push_back(sub);
+
+				    free(TrackList[i]);
+                    free(TrackList[i+1]);
+			    }
+			    free(TrackList);
+		    }
+        }
+
+		m_event(this, evStart);
+    } else {
+        //Creation failed, no playback support for insert file, so delete playback context
+
+        //FIXME: How to tell e2 that we failed?
+
+        if(player && player->output) {
+            player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+	        player->output->Command(player,OUTPUT_DEL, (void*)"video");
+	        player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+        }
+
+        if(player && player->playback)
+            player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+        if(player)
+            free(player);
+        player = NULL;
+
+    }
+
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#if not defined(__sh__)
 	// disconnect subtitle callback
 	GstElement *sink;
 	g_object_get (G_OBJECT (m_gst_playbin), "text-sink", &sink, NULL);
@@ -371,23 +531,42 @@
 		g_signal_handler_disconnect (sink, m_subs_to_pull_handler_id);
 		gst_object_unref(sink);
 	}
+	#endif
 
 	delete m_subtitle_widget;
 
+#if not defined(__sh__)
 	// disconnect sync handler callback
 	gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), NULL, NULL);
+	#endif
 
 	if (m_state == stRunning)
 		stop();
-
+#if not defined(__sh__)
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
-	
+
 	if (m_gst_playbin)
 	{
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
 		eDebug("eServiceMP3::destruct!");
 	}
+#else
+//Trick
+/*    if(player && player->output) {
+        player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+        player->output->Command(player,OUTPUT_DEL, (void*)"video");
+        player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+    }
+
+    if(player && player->playback)
+        player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+    if(player)
+        free(player);
+    player = NULL;
+*/
+#endif
 }
 
 DEFINE_REF(eServiceMP3);
@@ -395,20 +574,35 @@
 RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#if defined(__sh__)
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#if not defined(__sh__)
 	ASSERT(m_state == stIdle);
-
+#else
+	if(m_state != stIdle) {
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
 	m_state = stRunning;
+#if not defined(__sh__)
 	if (m_gst_playbin)
 	{
 		eDebug("eServiceMP3::starting pipeline");
 		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
 	}
-
+#else
+	if(player && player->output && player->playback) {
+        player->output->Command(player, OUTPUT_OPEN, NULL);
+        player->playback->Command(player, PLAYBACK_PLAY, NULL);
+    }
+#endif
 	m_event(this, evStart);
 
 	return 0;
@@ -416,13 +610,39 @@
 
 RESULT eServiceMP3::stop()
 {
+#if not defined(__sh__)
 	ASSERT(m_state != stIdle);
-
+#else
+	if(m_state == stIdle) {
+		eDebug("eServiceMP3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+#endif
 	if (m_state == stStopped)
 		return -1;
 
 	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
+#if not defined(__sh__)
 	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
+#else
+	if(player && player->playback && player->output) {
+        player->playback->Command(player, PLAYBACK_STOP, NULL);
+        player->output->Command(player, OUTPUT_CLOSE, NULL);
+    }
+	//Trick
+	if(player && player->output) {
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if(player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+	if(player)
+		free(player);
+	if(player != NULL)
+		player = NULL;
+#endif
 	m_state = stStopped;
 
 	return 0;
@@ -436,21 +656,40 @@
 RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 {
 	ptr=this;
+#if defined(__sh__)
+	m_event((iPlayableService*)this, evSeekableStatusChanged);
+	m_event((iPlayableService*)this, evUpdatedInfo);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#if not defined(__sh__)
 	if (!ratio)
 		return 0;
 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1/(float)ratio);
 	return trickSeek(1/(float)ratio);
+#else
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
+#if not defined(__sh__)
 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+	if(player && player->playback) {
+        	int result = 0;
+        	if(ratio > 1) result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&ratio);
+    		else result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+        	if (result != 0)
+            		return -1;
+    	}
+	return 0;
+#endif
 }
 
 void eServiceMP3::seekTimeoutCB()
@@ -459,7 +698,7 @@
 	getPlayPosition(ppos);
 	getLength(len);
 	ppos += 90000*m_currentTrickRatio;
-	
+
 	if (ppos < 0)
 	{
 		ppos = 0;
@@ -478,21 +717,30 @@
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 
+#else
+	if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-
+#else
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 	return 0;
 }
 
@@ -505,6 +753,7 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin)
 		return -1;
 
@@ -513,17 +762,29 @@
 
 	GstFormat fmt = GST_FORMAT_TIME;
 	gint64 len;
-	
+
 	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
 		return -1;
 		/* len is in nanoseconds. we have 90 000 pts per second. */
-	
+
 	pts = len / 11111;
+#else
+    double length = 0;
+
+	if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+    if(length <= 0)
+        return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#if not defined(__sh__)
 		/* convert pts to nanoseconds */
 	gint64 time_nanoseconds = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
@@ -533,7 +794,8 @@
 		eDebug("eServiceMP3::seekTo failed");
 		return -1;
 	}
-
+#else
+#endif
 	return 0;
 }
 
@@ -541,6 +803,7 @@
 {
 	RESULT ret = -1;
 
+#if not defined(__sh__)
 	if (m_gst_playbin) {
 		eSingleLocker l(m_subs_to_pull_lock); // this is needed to dont handle incomming subtitles during seek!
 		if (!(ret = seekToImpl(to)))
@@ -550,10 +813,12 @@
 		}
 	}
 
+#else
+#endif
 	return ret;
 }
 
-
+#if not defined(__sh__)
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -594,10 +859,12 @@
 
 	return 0;
 }
+#endif
 
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#if not defined(__sh__)
 	if (!m_gst_playbin)
 		return -1;
 
@@ -607,12 +874,17 @@
 	if (ppos < 0)
 		ppos = 0;
 	seekTo(ppos);
-	
+#else
+    float pos = direction*(to/90000.0);
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#if not defined(__sh__)
 	GstFormat fmt = GST_FORMAT_TIME;
 	gint64 pos;
 	GstElement *sink;
@@ -647,6 +919,24 @@
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111;
+#else
+	if (player && player->playback && !player->playback->isPlaying) {
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+        if(m_state == stRunning)
+		    m_event((iPlayableService*)this, evEOF);
+        pts = 0;
+		return -1;
+	}
+    unsigned long long int vpts = 0;
+    if(player && player->playback)
+        player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+    if(vpts<=0)return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -658,6 +948,9 @@

 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef __sh__
+	return 1;
+#else
 	int ret = 3; // seeking and fast/slow winding possible
 	GstElement *sink;
 
@@ -683,6 +976,7 @@
 	}
 
 	return ret;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -708,7 +1002,9 @@
 
 int eServiceMP3::getInfo(int w)
 {
+#if not defined(__sh__)
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -748,7 +1044,9 @@
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -759,6 +1057,7 @@
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#if not defined(__sh__)
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -792,22 +1091,25 @@
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	default:
 		return resNA;
 	}
-
+#if not defined(__sh__)
 	if (!m_stream_tags || !tag)
 		return 0;
-	
+
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
 
 std::string eServiceMP3::getInfoString(int w)
 {
+#if not defined(__sh__)
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -836,7 +1138,7 @@
 		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
 		{
 			gchar res[5];
- 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date); 
+ 			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date);
 			return (std::string)res;
 		}
 		break;
@@ -920,9 +1222,56 @@
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+
+	default:
+		return "";
+	}
+
+	if (player && player->playback) {
+        player->playback->Command(player, PLAYBACK_INFO, &tag);
+
+		std::string res = tag;
+        free(tag);
+		return res;
+	}
+    free(tag);
+#endif
 	return "";
 }
 
+#if not defined(__sh__)
 PyObject *eServiceMP3::getInfoObject(int w)
 {
 	const gchar *tag = 0;
@@ -982,6 +1331,7 @@
 
 	return 0;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1014,8 +1364,10 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#if not defined(__sh__)
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
@@ -1038,6 +1390,7 @@
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#if not defined(__sh__)
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
@@ -1048,6 +1401,13 @@
 		return 0;
 	}
 	return -1;
+#else
+	if(i!=m_currentAudioStream){
+		if(player && player->playback)
+            player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream=i;
+	}
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1065,6 +1425,7 @@
 {
  	if (i >= m_audioStreams.size())
 		return -2;
+#if not defined(__sh__)
 		info.m_description = m_audioStreams[i].codec;
 /*	if (m_audioStreams[i].type == atMPEG)
 		info.m_description = "MPEG";
@@ -1084,11 +1445,28 @@
 		info.m_description = "FLAC";
 	else
 		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
 	if (info.m_language.empty())
 		info.m_language = m_audioStreams[i].language_code;
 	return 0;
 }
 
+#if not defined(__sh__)
 void eServiceMP3::gstBusCall(GstBus *bus, GstMessage *msg)
 {
 	if (!msg)
@@ -1120,14 +1498,14 @@
 
 			GstState old_state, new_state;
 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
-		
+
 			if(old_state == new_state)
 				break;
-	
+
 			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
-	
+
 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
-	
+
 			switch(transition)
 			{
 				case GST_STATE_CHANGE_NULL_TO_READY:
@@ -1187,7 +1565,7 @@
 		{
 			gchar *debug;
 			GError *inf;
-	
+
 			gst_message_parse_info (msg, &inf, &debug);
 			g_free (debug);
 			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
@@ -1202,7 +1580,7 @@
 		{
 			GstTagList *tags, *result;
 			gst_message_parse_tag(msg, &tags);
-	
+
 			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
 			if (result)
 			{
@@ -1210,7 +1588,7 @@
 					gst_tag_list_free(m_stream_tags);
 				m_stream_tags = result;
 			}
-	
+
 			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
 			if ( gv_image )
 			{
@@ -1280,7 +1658,7 @@
 			}
 
 			for (i = 0; i < n_text; i++)
-			{	
+			{
 				gchar *g_lang;
 // 				gchar *g_type;
 // 				GstPad* pad = 0;
@@ -1406,11 +1784,11 @@
 
 void eServiceMP3::gstPoll(const int &msg)
 {
-		/* ok, we have a serious problem here. gstBusSyncHandler sends 
+		/* ok, we have a serious problem here. gstBusSyncHandler sends
 		   us the wakup signal, but likely before it was posted.
 		   the usleep, an EVIL HACK (DON'T DO THAT!!!) works around this.
-		   
-		   I need to understand the API a bit more to make this work 
+
+		   I need to understand the API a bit more to make this work
 		   proplerly. */
 	if (msg == 1)
 	{
@@ -1426,9 +1804,9 @@
 	else
 		pullSubtitle();
 }
-
+#endif
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
-
+#if not defined(__sh__)
 void eServiceMP3::gstCBsubtitleAvail(GstElement *appsink, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -1475,9 +1853,30 @@
 	else
 		eDebug("no subtitle sink!");
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#if not defined(__sh__)
 	ePangoSubtitlePage page;
 	pts_t running_pts;
 	while ( !m_subtitle_pages.empty() )
@@ -1522,6 +1921,7 @@
 	}
 	if (m_subtitle_pages.empty())
 		pullSubtitle();
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
@@ -1546,9 +1946,11 @@
 
 	if (m_currentSubtitleStream != pid)
 	{
+#if not defined(__sh__)
 		eSingleLocker l(m_subs_to_pull_lock);
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", pid, NULL);
 		m_currentSubtitleStream = pid;
+#endif
 		m_subs_to_pull = 0;
 		m_subtitle_pages.clear();
 	}
@@ -1557,9 +1959,14 @@
 	m_subtitle_widget = new eSubtitleWidget(parent);
 	m_subtitle_widget->resize(parent->size()); /* full size */
 
+#if not defined(__sh__)
 	g_object_get (G_OBJECT (m_gst_playbin), "current-text", &text_pid, NULL);
 
 	eDebug ("eServiceMP3::switched to subtitle stream %i", text_pid);
+#else
+	if(player && player->playback)
+       player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 
 	return 0;
 
@@ -1575,6 +1982,11 @@
 	m_subtitle_pages.clear();
 	delete m_subtitle_widget;
 	m_subtitle_widget = 0;
+#if defined(__sh__)
+    int pid = -1;
+    if(player && player->playback)
+       player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -1587,6 +1999,15 @@
 PyObject *eServiceMP3::getSubtitleList()
 {
 	eDebug("eServiceMP3::getSubtitleList");
+#if defined(__sh__)
+    if( player &&
+        player->output &&
+        player->output->subtitle) {
+
+        player->output->subtitle->Command(player, (OutputCmd_t)222, (void*)eplayerCBsubtitleAvail);
+        player->output->subtitle->Command(player, (OutputCmd_t)223, (void*) this);
+    }
+#endif
 
 	ePyObject l = PyList_New(0);
 	int stream_count[sizeof(subtype_t)];
@@ -1629,7 +2050,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#if not defined(__sh__)
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -1645,6 +2068,7 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#if not defined(__sh__)
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -1678,10 +2102,12 @@
 			gst_object_unref(sink);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#if not defined(__sh__)
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -1722,8 +2148,9 @@
 			gst_object_unref(sink);
 		}
 	}
+#endif
 }
 
-#else
-#warning gstreamer not available, not building media player
-#endif
+//#else
+//#warning gstreamer not available, not building media player
+//#endif
--- enigma2-nightly.org/lib/gdi/grc.cpp	2010-03-30 19:26:09.000000000 -0400
+++ enigma2-nightly.org/lib/gdi/grc.cpp	2010-03-30 19:34:30.000000000 -0400
@@ -4,6 +4,10 @@
 #include <lib/base/init.h>
 #include <lib/base/init_num.h>
 
+#if defined(__sh__)
+extern int stopFBgui;
+#endif
+
 #ifndef SYNC_PAINT
 void *gRC::thread_wrapper(void *ptr)
 {
@@ -125,7 +130,12 @@
 				m_compositing->Release();
 			} else if(o.dc)
 			{
+#if defined(__sh__)
+				if(stopFBgui == 0)
+					o.dc->exec(&o);
+#else
 				o.dc->exec(&o);
+#endif
 				// o.dc is a gDC* filled with grabref... so we must release it here
 				o.dc->Release();
 			}
@@ -175,9 +185,19 @@
 
 				if (!idle)
 				{
+#if defined(__sh__)
+					if(stopFBgui == 0)
+					{
+						if (!m_spinner_enabled)
+							eDebug("main thread is non-idle! display spinner!");
+						enableSpinner();
+					} else
+						disableSpinner();
+#else
 					if (!m_spinner_enabled)
 						eDebug("main thread is non-idle! display spinner!");
 					enableSpinner();
+#endif
 				} else
 					disableSpinner();
 			}

--- enigma2-nightly.orig/Makefile.am	2010-04-03 11:19:40.382790698 +0200
+++ enigma2-nightly/Makefile.am	2010-04-03 11:24:04.542799620 +0200
@@ -1,3 +1,5 @@
+ACLOCAL_AMFLAGS = -I m4
+
 SUBDIRS = include lib main data po tools
 
 installdir = $(pkglibdir)/python
--- enigma2-nightly.orig/autogen.sh	2010-04-03 11:19:40.382790698 +0200
+++ enigma2-nightly/autogen.sh	2010-04-03 11:22:50.858762218 +0200
@@ -50,7 +50,7 @@
 echo "Generating configuration files for $package, please wait...."
 
 echo "  aclocal"
-aclocal
+aclocal -I m4
 echo "  libtoolize --automake"
 libtoolize --automake
 echo "  autoconf"
--- /dev/null	2010-02-24 16:41:58.694342924 +0100
+++ enigma2-nightly/m4/progtest.m4	2010-04-03 11:22:50.858762218 +0200
@@ -0,0 +1,92 @@
+# progtest.m4 serial 4 (gettext-0.14.2)
+dnl Copyright (C) 1996-2003, 2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+AC_PREREQ(2.50)
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+# Find out how to test for executable files. Don't use a zero-byte file,
+# as systems may use methods other than mode bits to determine executability.
+cat >conf$$.file <<_ASEOF
+#! /bin/sh
+exit 0
+_ASEOF
+chmod +x conf$$.file
+if test -x conf$$.file >/dev/null 2>&1; then
+  ac_executable_p="test -x"
+else
+  ac_executable_p="test -f"
+fi
+rm -f conf$$.file
+
+# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  [[\\/]]* | ?:[[\\/]]*)
+    ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+    ;;
+  *)
+    ac_save_IFS="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in ifelse([$5], , $PATH, [$5]); do
+      IFS="$ac_save_IFS"
+      test -z "$ac_dir" && ac_dir=.
+      for ac_exec_ext in '' $ac_executable_extensions; do
+        if $ac_executable_p "$ac_dir/$ac_word$ac_exec_ext"; then
+          echo "$as_me: trying $ac_dir/$ac_word..." >&AS_MESSAGE_LOG_FD
+          if [$3]; then
+            ac_cv_path_$1="$ac_dir/$ac_word$ac_exec_ext"
+            break 2
+          fi
+        fi
+      done
+    done
+    IFS="$ac_save_IFS"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+    ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
--- enigma2-nightly.orig/configure.ac	2010-04-03 23:45:11.000000000 +0200
+++ enigma2-nightly/configure.ac	2010-04-03 23:47:27.000000000 +0200
@@ -67,10 +67,11 @@
 TUXBOX_APPS_LIB_PKGCONFIG(XML2,libxml-2.0)
 
 # ok, we are in trouble: XMLCCWRAP only defines C++ symbols. So let's just check if linking works,
-# and assume everything will be ok. Then just check for the "exit" symbol, which should be always there.
+# and assume everything will be ok. Then just check for the "main" symbol, which should be always there.
+# This check fails if the user decides to use the --pedantic CFLAG
 AC_LANG_SAVE
 AC_LANG_CPLUSPLUS
-TUXBOX_APPS_LIB_SYMBOL(XMLCCWRAP, xmlccwrap, exit)
+TUXBOX_APPS_LIB_SYMBOL(XMLCCWRAP, xmlccwrap, main)
 AC_LANG_RESTORE
 
 if test "$withsdl" = "yes" ; then
 
diff -Nur enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py enigma2-nightly/lib/python/Plugins/Extensions/TopfieldVFD/__init__.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/__init__.py	2009-12-13 10:15:06.057264790 +0100
@@ -0,0 +1,2 @@
+
+
diff -urN enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/Makefile.am	2009-11-29 17:44:06.000000000 +0100
@@ -0,0 +1,7 @@
+installdir = $(LIBDIR)/enigma2/python/Plugins/Extensions/CuberevoVFD
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
+
+ 
diff -urN enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py
--- enigma2-nightly.org/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	1970-01-01 01:00:00.000000000 +0100
+++ enigma2-nightly/lib/python/Plugins/Extensions/CuberevoVFD/plugin.py	2009-12-02 10:26:12.000000000 +0100
@@ -0,0 +1,244 @@
+from Screens.Screen import Screen
+from Screens.MessageBox import MessageBox
+from Plugins.Plugin import PluginDescriptor
+from Tools import Notifications
+from Components.Pixmap import Pixmap, MovingPixmap
+from Components.ActionMap import ActionMap, NumberActionMap
+from Components.Label import Label
+from Components.Button import Button
+from Components.Console import Console
+from Components.ConfigList import ConfigList
+from Components.config import config, configfile, ConfigSubsection, ConfigEnableDisable, \
+     getConfigListEntry, ConfigInteger, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eServiceCenter, iServiceInformation
+from enigma import evfd
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+from re import compile as re_compile, search as re_search
+from enigma import evfd
+
+my_global_session = None
+
+config.plugins.CuberevoVFD = ConfigSubsection()
+config.plugins.CuberevoVFD.scroll = ConfigSelection(default = "once", choices = [("never"), ("once"), ("always")])
+config.plugins.CuberevoVFD.brightness = ConfigSelection(default = "bright", choices = [("dark"), ("medium"), ("bright")])
+config.plugins.CuberevoVFD.showClock = ConfigEnableDisable(default = True)
+config.plugins.CuberevoVFD.setLed = ConfigEnableDisable(default = False)
+config.plugins.CuberevoVFD.setFan = ConfigEnableDisable(default = True)
+
+class CuberevoVFDSetup(ConfigListScreen, Screen):
+	skin = """
+		<screen position="100,100" size="550,400" title="CuberevoVFD Setup" >
+		<widget name="config" position="20,10" size="460,350" scrollbarMode="showOnDemand" />
+		<ePixmap position="140,350" size="140,40" pixmap="skin_default/buttons/green.png" alphatest="on" />
+		<ePixmap position="280,350" size="140,40" pixmap="skin_default/buttons/red.png" alphatest="on" />
+		<widget name="key_green" position="140,350" size="140,40" font="Regular;20" backgroundColor="#1f771f" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		<widget name="key_red" position="280,350" size="140,40" font="Regular;20" backgroundColor="#9f1313" zPosition="2" transparent="1" shadowColor="black" shadowOffset="-1,-1" />
+		</screen>"""
+
+
+	def __init__(self, session, args = None):
+		Screen.__init__(self, session)
+		self.onClose.append(self.abort)
+		
+		# create elements for the menu list
+		self.list = [ ]
+		self.list.append(getConfigListEntry(_("Show clock"), config.plugins.CuberevoVFD.showClock))
+		self.list.append(getConfigListEntry(_("Set led"), config.plugins.CuberevoVFD.setLed))
+		self.list.append(getConfigListEntry(_("Brightness"), config.plugins.CuberevoVFD.brightness))
+		self.list.append(getConfigListEntry(_("Scroll long strings"), config.plugins.CuberevoVFD.scroll))
+		self.list.append(getConfigListEntry(_("Set fan"), config.plugins.CuberevoVFD.setFan))
+		ConfigListScreen.__init__(self, self.list)
+
+		self.Console = Console()
+                self["key_red"] = Button(_("Cancel"))
+                self["key_green"] = Button(_("Save"))
+                                
+		# DO NOT ASK.
+		self["setupActions"] = ActionMap(["SetupActions"],
+		{
+			"save": self.save,
+			"cancel": self.cancel,
+			"ok": self.save,
+		}, -2)
+
+	def abort(self):
+		print "aborting"
+
+	def save(self):
+		# save all settings
+		for x in self["config"].list:
+			x[1].save()
+
+		if config.plugins.CuberevoVFD.showClock.getValue():
+			cubeVfd.enableClock()
+		else:
+			cubeVfd.disableClock()
+
+		# enable/disable fan activity
+                if config.plugins.CuberevoVFD.setFan.getValue():
+                	cubeVfd.enableFan()
+                else:
+                	cubeVfd.disableFan()
+		# enable/disable led activity
+                if config.plugins.CuberevoVFD.setLed.getValue():
+                	cubeVfd.enableLed()
+                else:
+                	cubeVfd.disableLed()
+       
+	        # set the brightness
+        	brightness = 3
+                if config.plugins.CuberevoVFD.brightness.getValue() == "dark":
+                	brightness = 1
+                elif config.plugins.CuberevoVFD.brightness.getValue() == "bright":
+                	brightness = 7
+                evfd.getInstance().vfd_set_brightness(brightness)
+                
+	        # set the the scroll mode
+	      	if config.plugins.CuberevoVFD.scroll.value == "once":
+			scrollMode = 1
+		elif config.plugins.CuberevoVFD.scroll.value == "always":
+			scrollMode = 2
+		else:
+			scrollMode = 0
+                evfd.getInstance().vfd_set_ani(scrollMode)
+
+		configfile.save()
+
+		self.close()
+
+	def cancel(self):
+                for x in self["config"].list:
+			x[1].cancel()
+		self.close()
+
+
+class CuberevoVFD:
+	def __init__(self, session):
+		#print "CuberevoVFD initializing"
+	        self.session = session
+	        self.service = None
+	        self.onClose = [ ]
+	        self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+	                {
+                                iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+                                iPlayableService.evStart: self.__evStart,
+	                })
+		self.Console = Console()
+		self.tsEnabled = False
+		self.fanEnabled = config.plugins.CuberevoVFD.setFan.getValue()
+		self.ledEnabled = config.plugins.CuberevoVFD.setLed.getValue()
+		self.clockEnabled = config.plugins.CuberevoVFD.showClock.getValue()
+		if self.fanEnabled == False:
+			self.disableFan()
+		else:
+			self.enableFan()
+		if self.ledEnabled == False:
+			self.disableLed()
+		else:
+			self.enableLed()
+		if config.plugins.CuberevoVFD.scroll.value == "once":
+			scrollMode = 1
+		elif config.plugins.CuberevoVFD.scroll.value == "always":
+			scrollMode = 2
+		else:
+			scrollMode = 0
+                evfd.getInstance().vfd_set_ani(scrollMode)
+
+	def enableClock(self):
+		self.clockEnabled = True
+	        
+	def disableClock(self):
+		self.clockEnabled = False
+
+	def enableLed(self):
+		self.ledEnabled = True
+                evfd.getInstance().vfd_set_light(self.ledEnabled)
+	        
+	def disableLed(self):
+		self.ledEnabled = False
+                evfd.getInstance().vfd_set_light(self.ledEnabled)
+
+	def enableFan(self):
+		self.fanEnabled = True
+		evfd.getInstance().vfd_set_fan(self.fanEnabled)
+	        
+	def disableFan(self):
+		self.fanEnabled = False
+		evfd.getInstance().vfd_set_fan(self.fanEnabled)
+
+        def regExpMatch(self, pattern, string):
+                if string is None:
+                        return None
+                try:
+                        return pattern.search(string).group()
+                except AttributeError:
+                        None
+	
+	def __evStart(self):
+	        self.__evSeekableStatusChanged()
+	
+	def getTimeshiftState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+		        return False
+		timeshift = service.timeshift()
+		if timeshift is None:
+		        return False
+		return True
+
+	def __evSeekableStatusChanged(self):
+	        tmp = self.getTimeshiftState()
+	        if tmp == self.tsEnabled:
+	        	return
+	        if tmp:
+	                print "[Timeshift enabled]"
+	                evfd.getInstance().vfd_set_icon(0x1A,True)
+	        else:
+	                print "[Timeshift disabled]"
+	                evfd.getInstance().vfd_set_icon(0x1A,False)
+		self.tsEnabled = tmp
+		
+	def shutdown(self):
+		self.abort()
+
+	def abort(self):
+		print "CuberevoVFD aborting"
+
+def main(session, **kwargs):
+	session.open(CuberevoVFDSetup)
+
+cubeVfd = None
+gReason = -1
+mySession = None
+
+def controlcubeVfd():
+	global cubeVfd
+	global gReason
+	global mySession
+
+        if gReason == 0 and mySession != None and cubeVfd == None:
+		print "Starting CuberevoVFD"
+		cubeVfd = CuberevoVFD(mySession)
+	elif gReason == 1 and cubeVfd != None:
+		print "Stopping CuberevoVFD"
+		cubeVfd = None
+
+def autostart(reason, **kwargs):
+	global cubeVfd
+	global gReason
+	global mySession
+
+	if kwargs.has_key("session"):
+                global my_global_session
+                mySession = kwargs["session"]
+	else:
+		gReason = reason
+	controlcubeVfd()
+
+def Plugins(**kwargs):
+ 	return [ PluginDescriptor(name="CuberevoVFD", description="Change VFD display settings", where = PluginDescriptor.WHERE_PLUGINMENU, fnc=main),
+ 		PluginDescriptor(where = [PluginDescriptor.WHERE_SESSIONSTART, PluginDescriptor.WHERE_AUTOSTART], fnc = autostart) ]
+

--- enigma2-nightly/lib/dvb/decoder.cpp	2010-04-06 07:01:08.000000000 -0400
+++ enigma2-nightly/lib/dvb/decoder.cpp	2010-04-06 07:05:49.000000000 -0400
@@ -40,6 +40,10 @@
 #define VIDEO_GET_PTS              _IOR('o', 57, __u64)
 #endif
 
+#ifdef __sh__
+int old_m_state = -1;
+#endif
+
 DEFINE_REF(eDVBAudio);
 
 eDVBAudio::eDVBAudio(eDVBDemux *demux, int dev)
@@ -166,7 +170,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_AUDIO1 : DMX_PES_AUDIO0; /* FIXME */
+#ifdef __sh__
+        pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -174,6 +182,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - audio - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -181,6 +191,8 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
+
 	int bypass = 0;
 
 	switch (type)
@@ -210,7 +222,10 @@
 		eDebug("failed (%m)");
 	else
 		eDebug("ok");
+
+#if !defined(__sh__)
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("AUDIO_PLAY - ");
 	if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -436,7 +451,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_VIDEO1 : DMX_PES_VIDEO0; /* FIXME */
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -444,6 +463,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - video - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -452,6 +472,7 @@
 	}
 	eDebug("ok");
 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 	eDebugNoNewLine("VIDEO_PLAY - ");
 	if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 		eDebug("failed (%m)");
@@ -750,7 +771,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_PCR1 : DMX_PES_PCR0; /* FIXME */
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -758,6 +783,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -765,6 +791,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 #endif
@@ -810,7 +837,11 @@
 	pes.input    = DMX_IN_FRONTEND;
 	pes.output   = DMX_OUT_DECODER;
 	pes.pes_type = m_dev ? DMX_PES_TELETEXT1 : DMX_PES_TELETEXT0; // FIXME
+#ifdef __sh__
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -819,6 +850,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#if !defined(__sh__)
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -826,6 +858,7 @@
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -1004,8 +1037,13 @@
 	}
 #endif
 
+#if defined(__sh__)
+if(old_m_state != m_state)
+{
+#endif
 	if (changed & (changeState|changeVideo|changeAudio))
 	{
+		old_m_state = m_state;
 					/* play, slowmotion, fast-forward */
 		int state_table[6][4] = 
 			{
@@ -1045,6 +1083,9 @@
 		}
 		m_changed &= ~changeState;
 	}
+#if defined(__sh__)
+}
+#endif
 
 	if (changed && !m_video && m_audio && m_radio_pic.length())
 		showSinglePic(m_radio_pic.c_str());
@@ -1111,9 +1152,11 @@
 eTSMPEGDecoder::~eTSMPEGDecoder()
 {
 	finishShowSinglePic();
+#if !defined(__sh__)
 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
 	m_changed = -1;
 	setState();
+#endif
 }
 
 RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
