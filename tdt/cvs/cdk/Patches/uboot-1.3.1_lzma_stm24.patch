diff -Nur u-boot-1.3.1/common/cmd_bootm.c u-boot-1.3.1-patched/common/cmd_bootm.c
--- u-boot-1.3.1/common/cmd_bootm.c	2011-07-02 21:08:15.700078411 +0200
+++ u-boot-1.3.1-patched/common/cmd_bootm.c	2011-07-02 21:07:24.584080807 +0200
@@ -43,6 +43,13 @@
 #include <ft_build.h>
 #endif
 
+#ifdef CONFIG_LZMA
+#define _7ZIP_BYTE_DEFINED /* Byte already defined by zlib */
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDecode.h>
+#include <lzma/LzmaTools.h>
+#endif /* CONFIG_LZMA */
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /*cmd_boot.c*/
@@ -428,6 +435,22 @@
 		}
 		break;
 #endif /* CONFIG_BZIP2 */
+#ifdef CONFIG_LZMA
+	case IH_COMP_LZMA:
+		printf ("   Uncompressing %s ... ", type_name);
+
+		int ret = lzmaBuffToBuffDecompress(
+			(unsigned char *)load, &unc_len,
+			(unsigned char *)image_start, image_start);
+		if (ret != LZMA_RESULT_OK) {
+			printf ("LZMA: uncompress or overwrite error %d "
+				"- must RESET board to recover\n", ret);
+			show_boot_progress (-6);
+			return BOOTM_ERR_RESET;
+		}
+		*load_end = load + unc_len;
+		break;
+#endif /* CONFIG_LZMA */
 	default:
 		if (iflag)
 			enable_interrupts();
diff -Nur u-boot-1.3.1/common/cmd_bootm.c.orig u-boot-1.3.1-patched/common/cmd_bootm.c.orig
--- u-boot-1.3.1/common/cmd_bootm.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/common/cmd_bootm.c.orig	2011-07-02 21:06:32.379078873 +0200
@@ -0,0 +1,1712 @@
+/*
+ * (C) Copyright 2000-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Boot support
+ */
+#include <common.h>
+#include <watchdog.h>
+#include <command.h>
+#include <image.h>
+#include <malloc.h>
+#include <u-boot/zlib.h>
+#include <bzlib.h>
+#include <environment.h>
+#include <asm/byteorder.h>
+
+#if defined(CONFIG_OF_LIBFDT)
+#include <fdt.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#endif
+#if defined(CONFIG_OF_FLAT_TREE)
+#include <ft_build.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*cmd_boot.c*/
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE)
+#include <rtc.h>
+#endif
+
+#ifdef CFG_HUSH_PARSER
+#include <hush.h>
+#endif
+
+#ifdef CFG_INIT_RAM_LOCK
+#include <asm/cache.h>
+#endif
+
+#ifdef CONFIG_LOGBUFFER
+#include <logbuff.h>
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+#include <dataflash.h>
+#endif
+
+#if defined(CONFIG_SH4)
+#include <asm/addrspace.h>
+#endif	/* CONFIG_SH4 */
+/*
+ * Some systems (for example LWMON) have very short watchdog periods;
+ * we must make sure to split long operations like memmove() or
+ * crc32() into reasonable chunks.
+ */
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+# define CHUNKSZ (64 * 1024)
+#endif
+
+int  gunzip (void *, int, unsigned char *, unsigned long *);
+
+static void *zalloc(void *, unsigned, unsigned);
+static void zfree(void *, void *, unsigned);
+
+#if defined(CONFIG_CMD_IMI)
+static int image_info (unsigned long addr);
+#endif
+
+#if defined(CONFIG_CMD_IMLS)
+#include <flash.h>
+extern flash_info_t flash_info[]; /* info for FLASH chips */
+static int do_imls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+static void print_type (image_header_t *hdr);
+
+#ifdef __I386__
+image_header_t *fake_header(image_header_t *hdr, void *ptr, int size);
+#endif
+
+/*
+ *  Continue booting an OS image; caller already has:
+ *  - copied image header to global variable `header'
+ *  - checked header magic number, checksums (both header & image),
+ *  - verified image architecture (PPC) and type (KERNEL or MULTI),
+ *  - loaded (first part of) image to header load address,
+ *  - disabled interrupts.
+ */
+typedef void boot_os_Fcn (cmd_tbl_t *cmdtp, int flag,
+			  int	argc, char *argv[],
+			  ulong	addr,		/* of image to boot */
+			  ulong	*len_ptr,	/* multi-file image length table */
+			  int	verify);	/* getenv("verify")[0] != 'n' */
+
+#ifdef	DEBUG
+extern int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+#ifdef CONFIG_PPC
+static boot_os_Fcn do_bootm_linux;
+#else
+extern boot_os_Fcn do_bootm_linux;
+#endif
+#ifdef CONFIG_SILENT_CONSOLE
+static void fixup_silent_linux (void);
+#endif
+static boot_os_Fcn do_bootm_netbsd;
+static boot_os_Fcn do_bootm_rtems;
+#if defined(CONFIG_CMD_ELF)
+static boot_os_Fcn do_bootm_vxworks;
+static boot_os_Fcn do_bootm_qnxelf;
+int do_bootvx ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] );
+int do_bootelf (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] );
+#endif
+#if defined(CONFIG_ARTOS) && defined(CONFIG_PPC)
+static boot_os_Fcn do_bootm_artos;
+#endif
+#ifdef CONFIG_LYNXKDI
+static boot_os_Fcn do_bootm_lynxkdi;
+extern void lynxkdi_boot( image_header_t * );
+#endif
+
+#ifndef CFG_BOOTM_LEN
+#define CFG_BOOTM_LEN	0x800000	/* use 8MByte as default max gunzip size */
+#endif
+
+image_header_t header;
+
+ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */
+
+int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	ulong	iflag;
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong  *len_ptr;
+	uint	unc_len = CFG_BOOTM_LEN;
+	int	i, verify;
+	char	*name, *s;
+	int	(*appl)(int, char *[]);
+	image_header_t *hdr = &header;
+
+	s = getenv ("verify");
+	verify = (s && (*s == 'n')) ? 0 : 1;
+
+	if (argc < 2) {
+		addr = load_addr;
+	} else {
+		addr = simple_strtoul(argv[1], NULL, 16);
+	}
+
+	show_boot_progress (1);
+	printf ("## Booting image at %08lx ...\n", addr);
+
+	/* Copy header so we can blank CRC field for re-calculation */
+#ifdef CONFIG_HAS_DATAFLASH
+	if (addr_dataflash(addr)){
+		read_dataflash(addr, sizeof(image_header_t), (char *)&header);
+	} else
+#endif
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+#ifdef __I386__	/* correct image format not implemented yet - fake it */
+		if (fake_header(hdr, (void*)addr, -1) != NULL) {
+			/* to compensate for the addition below */
+			addr -= sizeof(image_header_t);
+			/* turnof verify,
+			 * fake_header() does not fake the data crc
+			 */
+			verify = 0;
+		} else
+#endif	/* __I386__ */
+	    {
+		puts ("Bad Magic Number\n");
+		show_boot_progress (-1);
+		return 1;
+	    }
+	}
+	show_boot_progress (2);
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+
+	if (crc32 (0, (uchar *)data, len) != checksum) {
+		puts ("Bad Header Checksum\n");
+		show_boot_progress (-2);
+		return 1;
+	}
+	show_boot_progress (3);
+
+#ifdef CONFIG_HAS_DATAFLASH
+	if (addr_dataflash(addr)){
+		len  = ntohl(hdr->ih_size) + sizeof(image_header_t);
+		read_dataflash(addr, len, (char *)CFG_LOAD_ADDR);
+		addr = CFG_LOAD_ADDR;
+	}
+#endif
+
+
+	/* for multi-file images we need the data part, too */
+	print_image_hdr ((image_header_t *)addr);
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+
+	if (verify) {
+		puts ("   Verifying Checksum ... ");
+		if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
+			printf ("Bad Data CRC\n");
+			show_boot_progress (-3);
+			return 1;
+		}
+		puts ("OK\n");
+	}
+	show_boot_progress (4);
+
+	len_ptr = (ulong *)data;
+
+#if defined(__ARM__)
+	if (hdr->ih_arch != IH_CPU_ARM)
+#elif defined(__avr32__)
+	if (hdr->ih_arch != IH_CPU_AVR32)
+#elif defined(__bfin__)
+	if (hdr->ih_arch != IH_CPU_BLACKFIN)
+#elif defined(__I386__)
+	if (hdr->ih_arch != IH_CPU_I386)
+#elif defined(__M68K__)
+	if (hdr->ih_arch != IH_CPU_M68K)
+#elif defined(__microblaze__)
+	if (hdr->ih_arch != IH_CPU_MICROBLAZE)
+#elif defined(__mips__)
+	if (hdr->ih_arch != IH_CPU_MIPS)
+#elif defined(__nios__)
+	if (hdr->ih_arch != IH_CPU_NIOS)
+#elif defined(__nios2__)
+	if (hdr->ih_arch != IH_CPU_NIOS2)
+#elif defined(__PPC__)
+	if (hdr->ih_arch != IH_CPU_PPC)
+#elif defined(__SH4__)
+	if (hdr->ih_arch != IH_CPU_SH)
+#elif defined(__ST200__)
+	if (hdr->ih_arch != IH_CPU_ST200)
+#else
+# error Unknown CPU type
+#endif
+	{
+		printf ("Unsupported Architecture 0x%x\n", hdr->ih_arch);
+		show_boot_progress (-4);
+		return 1;
+	}
+	show_boot_progress (5);
+
+	switch (hdr->ih_type) {
+	case IH_TYPE_STANDALONE:
+		name = "Standalone Application";
+		/* A second argument overwrites the load address */
+		if (argc > 2) {
+			hdr->ih_load = htonl(simple_strtoul(argv[2], NULL, 16));
+		}
+		break;
+	case IH_TYPE_KERNEL:
+		name = "Kernel Image";
+		break;
+	case IH_TYPE_MULTI:
+		name = "Multi-File Image";
+		len  = ntohl(len_ptr[0]);
+		/* OS kernel is always the first image */
+		data += 8; /* kernel_len + terminator */
+		for (i=1; len_ptr[i]; ++i)
+			data += 4;
+		break;
+	default: printf ("Wrong Image Type for %s command\n", cmdtp->name);
+		show_boot_progress (-5);
+		return 1;
+	}
+	show_boot_progress (6);
+
+	/*
+	 * We have reached the point of no return: we are going to
+	 * overwrite all exception vector code, so we cannot easily
+	 * recover from any failures any more...
+	 */
+
+	iflag = disable_interrupts();
+
+#ifdef CONFIG_AMIGAONEG3SE
+	/*
+	 * We've possible left the caches enabled during
+	 * bios emulation, so turn them off again
+	 */
+	icache_disable();
+	invalidate_l1_instruction_cache();
+	flush_data_cache();
+	dcache_disable();
+#endif
+
+	switch (hdr->ih_comp) {
+	case IH_COMP_NONE:
+		if(ntohl(hdr->ih_load) == addr) {
+			printf ("   XIP %s ... ", name);
+		} else {
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+			size_t l = len;
+			void *to = (void *)ntohl(hdr->ih_load);
+			void *from = (void *)data;
+
+			printf ("   Loading %s ... ", name);
+
+			while (l > 0) {
+				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
+				WATCHDOG_RESET();
+				memmove (to, from, tail);
+				to += tail;
+				from += tail;
+				l -= tail;
+			}
+#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+			memmove ((void *) ntohl(hdr->ih_load), (uchar *)data, len);
+#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+		}
+		break;
+	case IH_COMP_GZIP:
+		printf ("   Uncompressing %s ... ", name);
+#if defined(CONFIG_SH4)
+{
+		const uchar * const isizep =		/* pointer to ISIZE */
+			(uchar *)data + ntohl(hdr->ih_size) - 4;
+		const ulong isize =			/* ISIZE (gzip's Input Size) */
+			(ulong)(isizep[0]) << 0*8 |	/* i.e. the ORIGINAL UN-compressed size */
+			(ulong)(isizep[1]) << 1*8 |
+			(ulong)(isizep[2]) << 2*8 |
+			(ulong)(isizep[3]) << 3*8;
+		const ulong Cload = data;		/* compressed load address */
+		const ulong Csize = ntohl(hdr->ih_size);/* compressed size */
+		const ulong Cend  = Cload + Csize - 1;	/* compressed end address */
+		const ulong Uload = ntohl(hdr->ih_load);/* un-compressed load address */
+		const ulong Usize = isize;		/* un-compressed size */
+		const ulong Uend  = Uload + Usize - 1;	/* un-compressed end address */
+
+#if !defined(CONFIG_SH_SE_MODE)
+		/* assert ( IS_IN_P1_REGION(Uload) ); */
+		if ( (Uload < P1SEG) || (Uend >= P2SEG) )
+		{
+			printf ("\nwarning: Uncompressing to non-P1 region (0x%08x..0x%08x)\n",
+				Uload, Uend);
+			/* just a warning, so carry on! */
+		}
+#endif	/* CONFIG_SH_SE_MODE */
+
+		/* assert (Uload >= CFG_SDRAM_BASE); */
+		if ( PHYSADDR(Uload) < PHYSADDR(CFG_SDRAM_BASE) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is below RAM (0x%08x)\n",
+				Uload,
+				CFG_SDRAM_BASE);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert (Uend < CFG_MEMTEST_END); */
+		if ( PHYSADDR(Uend) >= PHYSADDR(CFG_MEMTEST_END) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is beyond safe RAM (0x%08x)\n",
+				Uend,
+				CFG_MEMTEST_END);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert ( (Cload > Uend) || (Uload > Cend) ); */
+		if ( !((PHYSADDR(Cload) > PHYSADDR(Uend)) || (PHYSADDR(Uload) > PHYSADDR(Cend))) )
+		{
+			printf ("\nERROR: Overlapping images (0x%08x..0x%08x) and (0x%08x..0x%08x)\n",
+				Cload, Cend,
+				Uload, Uend);
+			return 1;	/* unable to proceed */
+		}
+		unc_len = Usize;	/* we now know that it will fit okay */
+}
+#endif	/* CONFIG_SH4 */
+		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
+			    (uchar *)data, &len) != 0) {
+			puts ("GUNZIP ERROR - must RESET board to recover\n");
+			show_boot_progress (-6);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#ifdef CONFIG_BZIP2
+	case IH_COMP_BZIP2:
+		printf ("   Uncompressing %s ... ", name);
+		/*
+		 * If we've got less than 4 MB of malloc() space,
+		 * use slower decompression algorithm which requires
+		 * at most 2300 KB of memory.
+		 */
+		i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
+						&unc_len, (char *)data, len,
+						CFG_MALLOC_LEN < (4096 * 1024), 0);
+		if (i != BZ_OK) {
+			printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
+			show_boot_progress (-6);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		break;
+#endif /* CONFIG_BZIP2 */
+	default:
+		if (iflag)
+			enable_interrupts();
+		printf ("Unimplemented compression type %d\n", hdr->ih_comp);
+		show_boot_progress (-7);
+		return 1;
+	}
+	puts ("OK\n");
+	show_boot_progress (7);
+
+	switch (hdr->ih_type) {
+	case IH_TYPE_STANDALONE:
+		if (iflag)
+			enable_interrupts();
+
+		/* load (and uncompress), but don't start if "autostart"
+		 * is set to "no"
+		 */
+		if (((s = getenv("autostart")) != NULL) && (strcmp(s,"no") == 0)) {
+			char buf[32];
+			sprintf(buf, "%lX", len);
+			setenv("filesize", buf);
+			return 0;
+		}
+		appl = (int (*)(int, char *[]))ntohl(hdr->ih_ep);
+		(*appl)(argc-1, &argv[1]);
+		return 0;
+	case IH_TYPE_KERNEL:
+	case IH_TYPE_MULTI:
+		/* handled below */
+		break;
+	default:
+		if (iflag)
+			enable_interrupts();
+		printf ("Can't boot image type %d\n", hdr->ih_type);
+		show_boot_progress (-8);
+		return 1;
+	}
+	show_boot_progress (8);
+
+	switch (hdr->ih_os) {
+	default:			/* handled by (original) Linux case */
+	case IH_OS_LINUX:
+#ifdef CONFIG_SILENT_CONSOLE
+	    fixup_silent_linux();
+#endif
+	    do_bootm_linux  (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+	    break;
+	case IH_OS_NETBSD:
+	    do_bootm_netbsd (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+	    break;
+
+#ifdef CONFIG_LYNXKDI
+	case IH_OS_LYNXOS:
+	    do_bootm_lynxkdi (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+	    break;
+#endif
+
+	case IH_OS_RTEMS:
+	    do_bootm_rtems (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+	    break;
+
+#if defined(CONFIG_CMD_ELF)
+	case IH_OS_VXWORKS:
+	    do_bootm_vxworks (cmdtp, flag, argc, argv,
+			      addr, len_ptr, verify);
+	    break;
+	case IH_OS_QNX:
+	    do_bootm_qnxelf (cmdtp, flag, argc, argv,
+			      addr, len_ptr, verify);
+	    break;
+#endif
+#ifdef CONFIG_ARTOS
+	case IH_OS_ARTOS:
+	    do_bootm_artos  (cmdtp, flag, argc, argv,
+			     addr, len_ptr, verify);
+	    break;
+#endif
+	}
+
+	show_boot_progress (-9);
+#ifdef DEBUG
+	puts ("\n## Control returned to monitor - resetting...\n");
+	do_reset (cmdtp, flag, argc, argv);
+#endif
+	return 1;
+}
+
+U_BOOT_CMD(
+ 	bootm,	CFG_MAXARGS,	1,	do_bootm,
+ 	"bootm   - boot application image from memory\n",
+ 	"[addr [arg ...]]\n    - boot application image stored in memory\n"
+ 	"\tpassing arguments 'arg ...'; when booting a Linux kernel,\n"
+ 	"\t'arg' can be the address of an initrd image\n"
+#if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
+	"\tWhen booting a Linux kernel which requires a flat device-tree\n"
+	"\ta third argument is required which is the address of the\n"
+	"\tdevice-tree blob. To boot that kernel without an initrd image,\n"
+	"\tuse a '-' for the second argument. If you do not pass a third\n"
+	"\ta bd_info struct will be passed instead\n"
+#endif
+);
+
+#ifdef CONFIG_SILENT_CONSOLE
+static void
+fixup_silent_linux ()
+{
+	char buf[256], *start, *end;
+	char *cmdline = getenv ("bootargs");
+
+	/* Only fix cmdline when requested */
+	if (!(gd->flags & GD_FLG_SILENT))
+		return;
+
+	debug ("before silent fix-up: %s\n", cmdline);
+	if (cmdline) {
+		if ((start = strstr (cmdline, "console=")) != NULL) {
+			end = strchr (start, ' ');
+			strncpy (buf, cmdline, (start - cmdline + 8));
+			if (end)
+				strcpy (buf + (start - cmdline + 8), end);
+			else
+				buf[start - cmdline + 8] = '\0';
+		} else {
+			strcpy (buf, cmdline);
+			strcat (buf, " console=");
+		}
+	} else {
+		strcpy (buf, "console=");
+	}
+
+	setenv ("bootargs", buf);
+	debug ("after silent fix-up: %s\n", buf);
+}
+#endif /* CONFIG_SILENT_CONSOLE */
+
+#ifdef CONFIG_PPC
+static void  __attribute__((noinline))
+do_bootm_linux (cmd_tbl_t *cmdtp, int flag,
+		int	argc, char *argv[],
+		ulong	addr,
+		ulong	*len_ptr,
+		int	verify)
+{
+	ulong	sp;
+	ulong	len, checksum;
+	ulong	initrd_start, initrd_end;
+	ulong	cmd_start, cmd_end;
+	ulong	initrd_high;
+	ulong	data;
+	int	initrd_copy_to_ram = 1;
+	char    *cmdline;
+	char	*s;
+	bd_t	*kbd;
+	void	(*kernel)(bd_t *, ulong, ulong, ulong, ulong);
+	image_header_t *hdr = &header;
+#if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
+	char	*of_flat_tree = NULL;
+	ulong	of_data = 0;
+#endif
+
+	if ((s = getenv ("initrd_high")) != NULL) {
+		/* a value of "no" or a similar string will act like 0,
+		 * turning the "load high" feature off. This is intentional.
+		 */
+		initrd_high = simple_strtoul(s, NULL, 16);
+		if (initrd_high == ~0)
+			initrd_copy_to_ram = 0;
+	} else {	/* not set, no restrictions to load high */
+		initrd_high = ~0;
+	}
+
+#ifdef CONFIG_LOGBUFFER
+	kbd=gd->bd;
+	/* Prevent initrd from overwriting logbuffer */
+	if (initrd_high < (kbd->bi_memsize-LOGBUFF_LEN-LOGBUFF_OVERHEAD))
+		initrd_high = kbd->bi_memsize-LOGBUFF_LEN-LOGBUFF_OVERHEAD;
+	debug ("## Logbuffer at 0x%08lX ", kbd->bi_memsize-LOGBUFF_LEN);
+#endif
+
+	/*
+	 * Booting a (Linux) kernel image
+	 *
+	 * Allocate space for command line and board info - the
+	 * address should be as high as possible within the reach of
+	 * the kernel (see CFG_BOOTMAPSZ settings), but in unused
+	 * memory, which means far enough below the current stack
+	 * pointer.
+	 */
+
+	asm( "mr %0,1": "=r"(sp) : );
+
+	debug ("## Current stack ends at 0x%08lX ", sp);
+
+	sp -= 2048;		/* just to be sure */
+	if (sp > CFG_BOOTMAPSZ)
+		sp = CFG_BOOTMAPSZ;
+	sp &= ~0xF;
+
+	debug ("=> set upper limit to 0x%08lX\n", sp);
+
+	cmdline = (char *)((sp - CFG_BARGSIZE) & ~0xF);
+	kbd = (bd_t *)(((ulong)cmdline - sizeof(bd_t)) & ~0xF);
+
+	if ((s = getenv("bootargs")) == NULL)
+		s = "";
+
+	strcpy (cmdline, s);
+
+	cmd_start    = (ulong)&cmdline[0];
+	cmd_end      = cmd_start + strlen(cmdline);
+
+	*kbd = *(gd->bd);
+
+#ifdef	DEBUG
+	printf ("## cmdline at 0x%08lX ... 0x%08lX\n", cmd_start, cmd_end);
+
+	do_bdinfo (NULL, 0, 0, NULL);
+#endif
+
+	if ((s = getenv ("clocks_in_mhz")) != NULL) {
+		/* convert all clock information to MHz */
+		kbd->bi_intfreq /= 1000000L;
+		kbd->bi_busfreq /= 1000000L;
+#if defined(CONFIG_MPC8220)
+	kbd->bi_inpfreq /= 1000000L;
+	kbd->bi_pcifreq /= 1000000L;
+	kbd->bi_pevfreq /= 1000000L;
+	kbd->bi_flbfreq /= 1000000L;
+	kbd->bi_vcofreq /= 1000000L;
+#endif
+#if defined(CONFIG_CPM2)
+		kbd->bi_cpmfreq /= 1000000L;
+		kbd->bi_brgfreq /= 1000000L;
+		kbd->bi_sccfreq /= 1000000L;
+		kbd->bi_vco     /= 1000000L;
+#endif
+#if defined(CONFIG_MPC5xxx)
+		kbd->bi_ipbfreq /= 1000000L;
+		kbd->bi_pcifreq /= 1000000L;
+#endif /* CONFIG_MPC5xxx */
+	}
+
+	kernel = (void (*)(bd_t *, ulong, ulong, ulong, ulong)) ntohl(hdr->ih_ep);
+
+	/*
+	 * Check if there is an initrd image
+	 */
+
+#if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
+	/* Look for a '-' which indicates to ignore the ramdisk argument */
+	if (argc >= 3 && strcmp(argv[2], "-") ==  0) {
+			debug ("Skipping initrd\n");
+			len = data = 0;
+		}
+	else
+#endif
+	if (argc >= 3) {
+		debug ("Not skipping initrd\n");
+		show_boot_progress (9);
+
+		addr = simple_strtoul(argv[2], NULL, 16);
+
+		printf ("## Loading RAMDisk Image at %08lx ...\n", addr);
+
+		/* Copy header so we can blank CRC field for re-calculation */
+		memmove (&header, (char *)addr, sizeof(image_header_t));
+
+		if (ntohl(hdr->ih_magic)  != IH_MAGIC) {
+			puts ("Bad Magic Number\n");
+			show_boot_progress (-10);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		data = (ulong)&header;
+		len  = sizeof(image_header_t);
+
+		checksum = ntohl(hdr->ih_hcrc);
+		hdr->ih_hcrc = 0;
+
+		if (crc32 (0, (uchar *)data, len) != checksum) {
+			puts ("Bad Header Checksum\n");
+			show_boot_progress (-11);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		show_boot_progress (10);
+
+		print_image_hdr (hdr);
+
+		data = addr + sizeof(image_header_t);
+		len  = ntohl(hdr->ih_size);
+
+		if (verify) {
+			ulong csum = 0;
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+			ulong cdata = data, edata = cdata + len;
+#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+
+			puts ("   Verifying Checksum ... ");
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+
+			while (cdata < edata) {
+				ulong chunk = edata - cdata;
+
+				if (chunk > CHUNKSZ)
+					chunk = CHUNKSZ;
+				csum = crc32 (csum, (uchar *)cdata, chunk);
+				cdata += chunk;
+
+				WATCHDOG_RESET();
+			}
+#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+			csum = crc32 (0, (uchar *)data, len);
+#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+
+			if (csum != ntohl(hdr->ih_dcrc)) {
+				puts ("Bad Data CRC\n");
+				show_boot_progress (-12);
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			puts ("OK\n");
+		}
+
+		show_boot_progress (11);
+
+		if ((hdr->ih_os   != IH_OS_LINUX)	||
+		    (hdr->ih_arch != IH_CPU_PPC)	||
+		    (hdr->ih_type != IH_TYPE_RAMDISK)	) {
+			puts ("No Linux PPC Ramdisk Image\n");
+			show_boot_progress (-13);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		/*
+		 * Now check if we have a multifile image
+		 */
+	} else if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1])) {
+		u_long tail    = ntohl(len_ptr[0]) % 4;
+		int i;
+
+		show_boot_progress (13);
+
+		/* skip kernel length and terminator */
+		data = (ulong)(&len_ptr[2]);
+		/* skip any additional image length fields */
+		for (i=1; len_ptr[i]; ++i)
+			data += 4;
+		/* add kernel length, and align */
+		data += ntohl(len_ptr[0]);
+		if (tail) {
+			data += 4 - tail;
+		}
+
+		len   = ntohl(len_ptr[1]);
+
+	} else {
+		/*
+		 * no initrd image
+		 */
+		show_boot_progress (14);
+
+		len = data = 0;
+	}
+
+#if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
+	if(argc > 3) {
+		of_flat_tree = (char *) simple_strtoul(argv[3], NULL, 16);
+		hdr = (image_header_t *)of_flat_tree;
+#if defined(CONFIG_OF_FLAT_TREE)
+		if (*((ulong *)(of_flat_tree + sizeof(image_header_t))) != OF_DT_HEADER) {
+#else
+		if (fdt_check_header(of_flat_tree + sizeof(image_header_t)) != 0) {
+#endif
+#ifndef CFG_NO_FLASH
+			if (addr2info((ulong)of_flat_tree) != NULL)
+				of_data = (ulong)of_flat_tree;
+#endif
+		} else if (ntohl(hdr->ih_magic) == IH_MAGIC) {
+			printf("## Flat Device Tree at %08lX\n", hdr);
+			print_image_hdr(hdr);
+
+			if ((ntohl(hdr->ih_load) <  ((unsigned long)hdr + ntohl(hdr->ih_size) + sizeof(hdr))) &&
+			   ((ntohl(hdr->ih_load) + ntohl(hdr->ih_size)) > (unsigned long)hdr)) {
+				puts ("ERROR: fdt overwritten - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+
+			puts ("   Verifying Checksum ... ");
+			memmove (&header, (char *)hdr, sizeof(image_header_t));
+			checksum = ntohl(header.ih_hcrc);
+			header.ih_hcrc = 0;
+
+			if(checksum != crc32(0, (uchar *)&header, sizeof(image_header_t))) {
+				puts ("ERROR: fdt header checksum invalid - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+
+			checksum = ntohl(hdr->ih_dcrc);
+			addr = (ulong)((uchar *)(hdr) + sizeof(image_header_t));
+
+			if(checksum != crc32(0, (uchar *)addr, ntohl(hdr->ih_size))) {
+				puts ("ERROR: fdt checksum invalid - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			puts ("OK\n");
+
+			if (ntohl(hdr->ih_type) != IH_TYPE_FLATDT) {
+				puts ("ERROR: uImage is not a fdt - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			if (ntohl(hdr->ih_comp) != IH_COMP_NONE) {
+				puts ("ERROR: uImage is compressed - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+#if defined(CONFIG_OF_FLAT_TREE)
+			if (*((ulong *)(of_flat_tree + sizeof(image_header_t))) != OF_DT_HEADER) {
+#else
+			if (fdt_check_header(of_flat_tree + sizeof(image_header_t)) != 0) {
+#endif
+				puts ("ERROR: uImage data is not a fdt - "
+					"must RESET the board to recover.\n");
+				do_reset (cmdtp, flag, argc, argv);
+			}
+
+			memmove((void *)ntohl(hdr->ih_load),
+		       		(void *)(of_flat_tree + sizeof(image_header_t)),
+				ntohl(hdr->ih_size));
+			of_flat_tree = (char *)ntohl(hdr->ih_load);
+		} else {
+			puts ("Did not find a flat Flat Device Tree.\n"
+				"Must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		printf ("   Booting using the fdt at 0x%x\n",
+				of_flat_tree);
+	} else if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]) && (len_ptr[2])) {
+		u_long tail    = ntohl(len_ptr[0]) % 4;
+		int i;
+
+		/* skip kernel length, initrd length, and terminator */
+		of_flat_tree = (char *)(&len_ptr[3]);
+		/* skip any additional image length fields */
+		for (i=2; len_ptr[i]; ++i)
+			of_flat_tree += 4;
+		/* add kernel length, and align */
+		of_flat_tree += ntohl(len_ptr[0]);
+		if (tail) {
+			of_flat_tree += 4 - tail;
+		}
+
+		/* add initrd length, and align */
+		tail = ntohl(len_ptr[1]) % 4;
+		of_flat_tree += ntohl(len_ptr[1]);
+		if (tail) {
+			of_flat_tree += 4 - tail;
+		}
+
+#ifndef CFG_NO_FLASH
+		/* move the blob if it is in flash (set of_data to !null) */
+		if (addr2info ((ulong)of_flat_tree) != NULL)
+			of_data = (ulong)of_flat_tree;
+#endif
+
+
+#if defined(CONFIG_OF_FLAT_TREE)
+		if (*((ulong *)(of_flat_tree)) != OF_DT_HEADER) {
+#else
+		if (fdt_check_header (of_flat_tree) != 0) {
+#endif
+			puts ("ERROR: image is not a fdt - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+#if defined(CONFIG_OF_FLAT_TREE)
+		if (((struct boot_param_header *)of_flat_tree)->totalsize !=
+			ntohl (len_ptr[2])) {
+#else
+		if (be32_to_cpu (fdt_totalsize (of_flat_tree)) !=
+			ntohl(len_ptr[2])) {
+#endif
+			puts ("ERROR: fdt size != image size - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+	}
+#endif
+	if (!data) {
+		debug ("No initrd\n");
+	}
+
+	if (data) {
+	    if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
+		initrd_start = data;
+		initrd_end = initrd_start + len;
+	    } else {
+		initrd_start  = (ulong)kbd - len;
+		initrd_start &= ~(4096 - 1);	/* align on page */
+
+		if (initrd_high) {
+			ulong nsp;
+
+			/*
+			 * the inital ramdisk does not need to be within
+			 * CFG_BOOTMAPSZ as it is not accessed until after
+			 * the mm system is initialised.
+			 *
+			 * do the stack bottom calculation again and see if
+			 * the initrd will fit just below the monitor stack
+			 * bottom without overwriting the area allocated
+			 * above for command line args and board info.
+			 */
+			asm( "mr %0,1": "=r"(nsp) : );
+			nsp -= 2048;		/* just to be sure */
+			nsp &= ~0xF;
+			if (nsp > initrd_high)	/* limit as specified */
+				nsp = initrd_high;
+			nsp -= len;
+			nsp &= ~(4096 - 1);	/* align on page */
+			if (nsp >= sp)
+				initrd_start = nsp;
+		}
+
+		show_boot_progress (12);
+
+		debug ("## initrd at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
+			data, data + len - 1, len, len);
+
+		initrd_end    = initrd_start + len;
+		printf ("   Loading Ramdisk to %08lx, end %08lx ... ",
+			initrd_start, initrd_end);
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+		{
+			size_t l = len;
+			void *to = (void *)initrd_start;
+			void *from = (void *)data;
+
+			while (l > 0) {
+				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
+				WATCHDOG_RESET();
+				memmove (to, from, tail);
+				to += tail;
+				from += tail;
+				l -= tail;
+			}
+		}
+#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+		memmove ((void *)initrd_start, (void *)data, len);
+#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+		puts ("OK\n");
+	    }
+	} else {
+		initrd_start = 0;
+		initrd_end = 0;
+	}
+
+#if defined(CONFIG_OF_LIBFDT)
+
+#ifdef CFG_BOOTMAPSZ
+	/*
+	 * The blob must be within CFG_BOOTMAPSZ,
+	 * so we flag it to be copied if it is not.
+	 */
+	if (of_flat_tree >= (char *)CFG_BOOTMAPSZ)
+		of_data = (ulong)of_flat_tree;
+#endif
+
+	/* move of_flat_tree if needed */
+	if (of_data) {
+		int err;
+		ulong of_start, of_len;
+
+		of_len = be32_to_cpu(fdt_totalsize(of_data));
+
+		/* position on a 4K boundary before the kbd */
+		of_start  = (ulong)kbd - of_len;
+		of_start &= ~(4096 - 1);	/* align on page */
+		debug ("## device tree at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
+			of_data, of_data + of_len - 1, of_len, of_len);
+
+		of_flat_tree = (char *)of_start;
+		printf ("   Loading Device Tree to %08lx, end %08lx ... ",
+			of_start, of_start + of_len - 1);
+		err = fdt_open_into((void *)of_data, (void *)of_start, of_len);
+		if (err != 0) {
+			puts ("ERROR: fdt move failed - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+		puts ("OK\n");
+	}
+	/*
+	 * Add the chosen node if it doesn't exist, add the env and bd_t
+	 * if the user wants it (the logic is in the subroutines).
+	 */
+	if (of_flat_tree) {
+		if (fdt_chosen(of_flat_tree, initrd_start, initrd_end, 0) < 0) {
+			puts ("ERROR: /chosen node create failed - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+#ifdef CONFIG_OF_HAS_UBOOT_ENV
+		if (fdt_env(of_flat_tree) < 0) {
+			puts ("ERROR: /u-boot-env node create failed - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+#endif
+#ifdef CONFIG_OF_HAS_BD_T
+		if (fdt_bd_t(of_flat_tree) < 0) {
+			puts ("ERROR: /bd_t node create failed - "
+				"must RESET the board to recover.\n");
+			do_reset (cmdtp, flag, argc, argv);
+		}
+#endif
+#ifdef CONFIG_OF_BOARD_SETUP
+		/* Call the board-specific fixup routine */
+		ft_board_setup(of_flat_tree, gd->bd);
+#endif
+	}
+#endif /* CONFIG_OF_LIBFDT */
+#if defined(CONFIG_OF_FLAT_TREE)
+#ifdef CFG_BOOTMAPSZ
+	/*
+	 * The blob must be within CFG_BOOTMAPSZ,
+	 * so we flag it to be copied if it is not.
+	 */
+	if (of_flat_tree >= (char *)CFG_BOOTMAPSZ)
+		of_data = (ulong)of_flat_tree;
+#endif
+
+	/* move of_flat_tree if needed */
+	if (of_data) {
+		ulong of_start, of_len;
+		of_len = ((struct boot_param_header *)of_data)->totalsize;
+
+		/* provide extra 8k pad */
+		of_start  = (ulong)kbd - of_len - 8192;
+		of_start &= ~(4096 - 1);	/* align on page */
+		debug ("## device tree at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
+			of_data, of_data + of_len - 1, of_len, of_len);
+
+		of_flat_tree = (char *)of_start;
+		printf ("   Loading Device Tree to %08lx, end %08lx ... ",
+			of_start, of_start + of_len - 1);
+		memmove ((void *)of_start, (void *)of_data, of_len);
+		puts ("OK\n");
+	}
+	/*
+	 * Create the /chosen node and modify the blob with board specific
+	 * values as needed.
+	 */
+	ft_setup(of_flat_tree, kbd, initrd_start, initrd_end);
+	/* ft_dump_blob(of_flat_tree); */
+#endif
+	debug ("## Transferring control to Linux (at address %08lx) ...\n",
+		(ulong)kernel);
+
+	show_boot_progress (15);
+
+#if defined(CFG_INIT_RAM_LOCK) && !defined(CONFIG_E500)
+	unlock_ram_in_cache();
+#endif
+
+#if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
+	if (of_flat_tree) {	/* device tree; boot new style */
+		/*
+		 * Linux Kernel Parameters (passing device tree):
+		 *   r3: pointer to the fdt, followed by the board info data
+		 *   r4: physical pointer to the kernel itself
+		 *   r5: NULL
+		 *   r6: NULL
+		 *   r7: NULL
+		 */
+		(*kernel) ((bd_t *)of_flat_tree, (ulong)kernel, 0, 0, 0);
+		/* does not return */
+	}
+#endif
+	/*
+	 * Linux Kernel Parameters (passing board info data):
+	 *   r3: ptr to board info data
+	 *   r4: initrd_start or 0 if no initrd
+	 *   r5: initrd_end - unused if r4 is 0
+	 *   r6: Start of command line string
+	 *   r7: End   of command line string
+	 */
+	(*kernel) (kbd, initrd_start, initrd_end, cmd_start, cmd_end);
+	/* does not return */
+}
+#endif /* CONFIG_PPC */
+
+static void
+do_bootm_netbsd (cmd_tbl_t *cmdtp, int flag,
+		int	argc, char *argv[],
+		ulong	addr,
+		ulong	*len_ptr,
+		int	verify)
+{
+	image_header_t *hdr = &header;
+
+	void	(*loader)(bd_t *, image_header_t *, char *, char *);
+	image_header_t *img_addr;
+	char     *consdev;
+	char     *cmdline;
+
+
+	/*
+	 * Booting a (NetBSD) kernel image
+	 *
+	 * This process is pretty similar to a standalone application:
+	 * The (first part of an multi-) image must be a stage-2 loader,
+	 * which in turn is responsible for loading & invoking the actual
+	 * kernel.  The only differences are the parameters being passed:
+	 * besides the board info strucure, the loader expects a command
+	 * line, the name of the console device, and (optionally) the
+	 * address of the original image header.
+	 */
+
+	img_addr = 0;
+	if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]))
+		img_addr = (image_header_t *) addr;
+
+
+	consdev = "";
+#if   defined (CONFIG_8xx_CONS_SMC1)
+	consdev = "smc1";
+#elif defined (CONFIG_8xx_CONS_SMC2)
+	consdev = "smc2";
+#elif defined (CONFIG_8xx_CONS_SCC2)
+	consdev = "scc2";
+#elif defined (CONFIG_8xx_CONS_SCC3)
+	consdev = "scc3";
+#endif
+
+	if (argc > 2) {
+		ulong len;
+		int   i;
+
+		for (i=2, len=0 ; i<argc ; i+=1)
+			len += strlen (argv[i]) + 1;
+		cmdline = malloc (len);
+
+		for (i=2, len=0 ; i<argc ; i+=1) {
+			if (i > 2)
+				cmdline[len++] = ' ';
+			strcpy (&cmdline[len], argv[i]);
+			len += strlen (argv[i]);
+		}
+	} else if ((cmdline = getenv("bootargs")) == NULL) {
+		cmdline = "";
+	}
+
+	loader = (void (*)(bd_t *, image_header_t *, char *, char *)) ntohl(hdr->ih_ep);
+
+	printf ("## Transferring control to NetBSD stage-2 loader (at address %08lx) ...\n",
+		(ulong)loader);
+
+	show_boot_progress (15);
+
+	/*
+	 * NetBSD Stage-2 Loader Parameters:
+	 *   r3: ptr to board info data
+	 *   r4: image address
+	 *   r5: console device
+	 *   r6: boot args string
+	 */
+	(*loader) (gd->bd, img_addr, consdev, cmdline);
+}
+
+#if defined(CONFIG_ARTOS) && defined(CONFIG_PPC)
+
+/* Function that returns a character from the environment */
+extern uchar (*env_get_char)(int);
+
+static void
+do_bootm_artos (cmd_tbl_t *cmdtp, int flag,
+		int	argc, char *argv[],
+		ulong	addr,
+		ulong	*len_ptr,
+		int	verify)
+{
+	ulong top;
+	char *s, *cmdline;
+	char **fwenv, **ss;
+	int i, j, nxt, len, envno, envsz;
+	bd_t *kbd;
+	void (*entry)(bd_t *bd, char *cmdline, char **fwenv, ulong top);
+	image_header_t *hdr = &header;
+
+	/*
+	 * Booting an ARTOS kernel image + application
+	 */
+
+	/* this used to be the top of memory, but was wrong... */
+#ifdef CONFIG_PPC
+	/* get stack pointer */
+	asm volatile ("mr %0,1" : "=r"(top) );
+#endif
+	debug ("## Current stack ends at 0x%08lX ", top);
+
+	top -= 2048;		/* just to be sure */
+	if (top > CFG_BOOTMAPSZ)
+		top = CFG_BOOTMAPSZ;
+	top &= ~0xF;
+
+	debug ("=> set upper limit to 0x%08lX\n", top);
+
+	/* first check the artos specific boot args, then the linux args*/
+	if ((s = getenv("abootargs")) == NULL && (s = getenv("bootargs")) == NULL)
+		s = "";
+
+	/* get length of cmdline, and place it */
+	len = strlen(s);
+	top = (top - (len + 1)) & ~0xF;
+	cmdline = (char *)top;
+	debug ("## cmdline at 0x%08lX ", top);
+	strcpy(cmdline, s);
+
+	/* copy bdinfo */
+	top = (top - sizeof(bd_t)) & ~0xF;
+	debug ("## bd at 0x%08lX ", top);
+	kbd = (bd_t *)top;
+	memcpy(kbd, gd->bd, sizeof(bd_t));
+
+	/* first find number of env entries, and their size */
+	envno = 0;
+	envsz = 0;
+	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
+		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt)
+			;
+		envno++;
+		envsz += (nxt - i) + 1;	/* plus trailing zero */
+	}
+	envno++;	/* plus the terminating zero */
+	debug ("## %u envvars total size %u ", envno, envsz);
+
+	top = (top - sizeof(char **)*envno) & ~0xF;
+	fwenv = (char **)top;
+	debug ("## fwenv at 0x%08lX ", top);
+
+	top = (top - envsz) & ~0xF;
+	s = (char *)top;
+	ss = fwenv;
+
+	/* now copy them */
+	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
+		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt)
+			;
+		*ss++ = s;
+		for (j = i; j < nxt; ++j)
+			*s++ = env_get_char(j);
+		*s++ = '\0';
+	}
+	*ss++ = NULL;	/* terminate */
+
+	entry = (void (*)(bd_t *, char *, char **, ulong))ntohl(hdr->ih_ep);
+	(*entry)(kbd, cmdline, fwenv, top);
+}
+#endif
+
+
+#if defined(CONFIG_CMD_BOOTD)
+int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int rcode = 0;
+#ifndef CFG_HUSH_PARSER
+	if (run_command (getenv ("bootcmd"), flag) < 0) rcode = 1;
+#else
+	if (parse_string_outer(getenv("bootcmd"),
+		FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0 ) rcode = 1;
+#endif
+	return rcode;
+}
+
+U_BOOT_CMD(
+ 	boot,	1,	1,	do_bootd,
+ 	"boot    - boot default, i.e., run 'bootcmd'\n",
+	NULL
+);
+
+/* keep old command name "bootd" for backward compatibility */
+U_BOOT_CMD(
+ 	bootd, 1,	1,	do_bootd,
+ 	"bootd   - boot default, i.e., run 'bootcmd'\n",
+	NULL
+);
+
+#endif
+
+#if defined(CONFIG_CMD_IMI)
+int do_iminfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int	arg;
+	ulong	addr;
+	int     rcode=0;
+
+	if (argc < 2) {
+		return image_info (load_addr);
+	}
+
+	for (arg=1; arg <argc; ++arg) {
+		addr = simple_strtoul(argv[arg], NULL, 16);
+		if (image_info (addr) != 0) rcode = 1;
+	}
+	return rcode;
+}
+
+static int image_info (ulong addr)
+{
+	ulong	data, len, checksum;
+	image_header_t *hdr = &header;
+
+	printf ("\n## Checking Image at %08lx ...\n", addr);
+
+	/* Copy header so we can blank CRC field for re-calculation */
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		puts ("   Bad Magic Number\n");
+		return 1;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+
+	if (crc32 (0, (uchar *)data, len) != checksum) {
+		puts ("   Bad Header Checksum\n");
+		return 1;
+	}
+
+	/* for multi-file images we need the data part, too */
+	print_image_hdr ((image_header_t *)addr);
+
+	data = addr + sizeof(image_header_t);
+	len  = ntohl(hdr->ih_size);
+
+	puts ("   Verifying Checksum ... ");
+	if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
+		puts ("   Bad Data CRC\n");
+		return 1;
+	}
+	puts ("OK\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	iminfo,	CFG_MAXARGS,	1,	do_iminfo,
+	"iminfo  - print header information for application image\n",
+	"addr [addr ...]\n"
+	"    - print header information for application image starting at\n"
+	"      address 'addr' in memory; this includes verification of the\n"
+	"      image contents (magic number, header and payload checksums)\n"
+);
+
+#endif
+
+#if defined(CONFIG_CMD_IMLS)
+/*-----------------------------------------------------------------------
+ * List all images found in flash.
+ */
+int do_imls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	flash_info_t *info;
+	int i, j;
+	image_header_t *hdr;
+	ulong data, len, checksum;
+
+	for (i=0, info=&flash_info[0]; i<CFG_MAX_FLASH_BANKS; ++i, ++info) {
+		if (info->flash_id == FLASH_UNKNOWN)
+			goto next_bank;
+		for (j=0; j<info->sector_count; ++j) {
+
+			if (!(hdr=(image_header_t *)info->start[j]) ||
+			    (ntohl(hdr->ih_magic) != IH_MAGIC))
+				goto next_sector;
+
+			/* Copy header so we can blank CRC field for re-calculation */
+			memmove (&header, (char *)hdr, sizeof(image_header_t));
+
+			checksum = ntohl(header.ih_hcrc);
+			header.ih_hcrc = 0;
+
+			if (crc32 (0, (uchar *)&header, sizeof(image_header_t))
+			    != checksum)
+				goto next_sector;
+
+			printf ("Image at %08lX:\n", (ulong)hdr);
+			print_image_hdr( hdr );
+
+			data = (ulong)hdr + sizeof(image_header_t);
+			len  = ntohl(hdr->ih_size);
+
+			puts ("   Verifying Checksum ... ");
+			if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
+				puts ("   Bad Data CRC\n");
+			}
+			puts ("OK\n");
+next_sector:		;
+		}
+next_bank:	;
+	}
+
+	return (0);
+}
+
+U_BOOT_CMD(
+	imls,	1,		1,	do_imls,
+	"imls    - list all images found in flash\n",
+	"\n"
+	"    - Prints information about all images found at sector\n"
+	"      boundaries in flash.\n"
+);
+#endif
+
+void
+print_image_hdr (image_header_t *hdr)
+{
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE)
+	time_t timestamp = (time_t)ntohl(hdr->ih_time);
+	struct rtc_time tm;
+#endif
+
+	printf ("   Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE)
+	to_tm (timestamp, &tm);
+	printf ("   Created:      %4d-%02d-%02d  %2d:%02d:%02d UTC\n",
+		tm.tm_year, tm.tm_mon, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec);
+#endif
+	puts ("   Image Type:   "); print_type(hdr);
+	printf ("\n   Data Size:    %d Bytes = ", ntohl(hdr->ih_size));
+	print_size (ntohl(hdr->ih_size), "\n");
+	printf ("   Load Address: %08x\n"
+		"   Entry Point:  %08x\n",
+		 ntohl(hdr->ih_load), ntohl(hdr->ih_ep));
+
+	if (hdr->ih_type == IH_TYPE_MULTI) {
+		int i;
+		ulong len;
+		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));
+
+		puts ("   Contents:\n");
+		for (i=0; (len = ntohl(*len_ptr)); ++i, ++len_ptr) {
+			printf ("   Image %d: %8ld Bytes = ", i, len);
+			print_size (len, "\n");
+		}
+	}
+}
+
+
+static void
+print_type (image_header_t *hdr)
+{
+	char *os, *arch, *type, *comp;
+
+	switch (hdr->ih_os) {
+	case IH_OS_INVALID:	os = "Invalid OS";		break;
+	case IH_OS_NETBSD:	os = "NetBSD";			break;
+	case IH_OS_LINUX:	os = "Linux";			break;
+	case IH_OS_VXWORKS:	os = "VxWorks";			break;
+	case IH_OS_QNX:		os = "QNX";			break;
+	case IH_OS_U_BOOT:	os = "U-Boot";			break;
+	case IH_OS_RTEMS:	os = "RTEMS";			break;
+#ifdef CONFIG_ARTOS
+	case IH_OS_ARTOS:	os = "ARTOS";			break;
+#endif
+#ifdef CONFIG_LYNXKDI
+	case IH_OS_LYNXOS:	os = "LynxOS";			break;
+#endif
+	default:		os = "Unknown OS";		break;
+	}
+
+	switch (hdr->ih_arch) {
+	case IH_CPU_INVALID:	arch = "Invalid CPU";		break;
+	case IH_CPU_ALPHA:	arch = "Alpha";			break;
+	case IH_CPU_ARM:	arch = "ARM";			break;
+	case IH_CPU_AVR32:	arch = "AVR32";			break;
+	case IH_CPU_BLACKFIN:	arch = "Blackfin";		break;
+	case IH_CPU_I386:	arch = "Intel x86";		break;
+	case IH_CPU_IA64:	arch = "IA64";			break;
+	case IH_CPU_M68K:	arch = "M68K"; 			break;
+	case IH_CPU_MICROBLAZE:	arch = "Microblaze"; 		break;
+	case IH_CPU_MIPS64:	arch = "MIPS 64 Bit";		break;
+	case IH_CPU_MIPS:	arch = "MIPS";			break;
+	case IH_CPU_NIOS2:	arch = "Nios-II";		break;
+	case IH_CPU_NIOS:	arch = "Nios";			break;
+	case IH_CPU_PPC:	arch = "PowerPC";		break;
+	case IH_CPU_S390:	arch = "IBM S390";		break;
+	case IH_CPU_SH:		arch = "SuperH";		break;
+	case IH_CPU_SPARC64:	arch = "SPARC 64 Bit";		break;
+	case IH_CPU_SPARC:	arch = "SPARC";			break;
+	case IH_CPU_ST200:	arch = "ST200";			break;
+	default:		arch = "Unknown Architecture";	break;
+	}
+
+	switch (hdr->ih_type) {
+	case IH_TYPE_INVALID:	type = "Invalid Image";		break;
+	case IH_TYPE_STANDALONE:type = "Standalone Program";	break;
+	case IH_TYPE_KERNEL:	type = "Kernel Image";		break;
+	case IH_TYPE_RAMDISK:	type = "RAMDisk Image";		break;
+	case IH_TYPE_MULTI:	type = "Multi-File Image";	break;
+	case IH_TYPE_FIRMWARE:	type = "Firmware";		break;
+	case IH_TYPE_SCRIPT:	type = "Script";		break;
+	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
+	default:		type = "Unknown Image";		break;
+	}
+
+	switch (hdr->ih_comp) {
+	case IH_COMP_NONE:	comp = "uncompressed";		break;
+	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
+	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
+	default:		comp = "unknown compression";	break;
+	}
+
+	printf ("%s %s %s (%s)", arch, os, type, comp);
+}
+
+#define	ZALLOC_ALIGNMENT	16
+
+static void *zalloc(void *x, unsigned items, unsigned size)
+{
+	void *p;
+
+	size *= items;
+	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
+
+	p = malloc (size);
+
+	return (p);
+}
+
+static void zfree(void *x, void *addr, unsigned nb)
+{
+	free (addr);
+}
+
+#define HEAD_CRC	2
+#define EXTRA_FIELD	4
+#define ORIG_NAME	8
+#define COMMENT		0x10
+#define RESERVED	0xe0
+
+#define DEFLATED	8
+
+int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
+{
+	z_stream s;
+	int r, i, flags;
+
+	/* skip header */
+	i = 10;
+	flags = src[3];
+	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
+		puts ("Error: Bad gzipped data\n");
+		return (-1);
+	}
+	if ((flags & EXTRA_FIELD) != 0)
+		i = 12 + src[10] + (src[11] << 8);
+	if ((flags & ORIG_NAME) != 0)
+		while (src[i++] != 0)
+			;
+	if ((flags & COMMENT) != 0)
+		while (src[i++] != 0)
+			;
+	if ((flags & HEAD_CRC) != 0)
+		i += 2;
+	if (i >= *lenp) {
+		puts ("Error: gunzip out of data in header\n");
+		return (-1);
+	}
+
+	s.zalloc = zalloc;
+	s.zfree = zfree;
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	s.outcb = (cb_func)WATCHDOG_RESET;
+#else
+	s.outcb = Z_NULL;
+#endif	/* CONFIG_HW_WATCHDOG */
+
+	r = inflateInit2(&s, -MAX_WBITS);
+	if (r != Z_OK) {
+		printf ("Error: inflateInit2() returned %d\n", r);
+		return (-1);
+	}
+	s.next_in = src + i;
+	s.avail_in = *lenp - i;
+	s.next_out = dst;
+	s.avail_out = dstlen;
+	r = inflate(&s, Z_FINISH);
+	if (r != Z_OK && r != Z_STREAM_END) {
+		printf ("Error: inflate() returned %d\n", r);
+		return (-1);
+	}
+	*lenp = s.next_out - (unsigned char *) dst;
+	inflateEnd(&s);
+
+	return (0);
+}
+
+#ifdef CONFIG_BZIP2
+void bz_internal_error(int errcode)
+{
+	printf ("BZIP2 internal error %d\n", errcode);
+}
+#endif /* CONFIG_BZIP2 */
+
+static void
+do_bootm_rtems (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		ulong addr, ulong *len_ptr, int verify)
+{
+	image_header_t *hdr = &header;
+	void	(*entry_point)(bd_t *);
+
+	entry_point = (void (*)(bd_t *)) ntohl(hdr->ih_ep);
+
+	printf ("## Transferring control to RTEMS (at address %08lx) ...\n",
+		(ulong)entry_point);
+
+	show_boot_progress (15);
+
+	/*
+	 * RTEMS Parameters:
+	 *   r3: ptr to board info data
+	 */
+
+	(*entry_point ) ( gd->bd );
+}
+
+#if defined(CONFIG_CMD_ELF)
+static void
+do_bootm_vxworks (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		  ulong addr, ulong *len_ptr, int verify)
+{
+	image_header_t *hdr = &header;
+	char str[80];
+
+	sprintf(str, "%x", ntohl(hdr->ih_ep)); /* write entry-point into string */
+	setenv("loadaddr", str);
+	do_bootvx(cmdtp, 0, 0, NULL);
+}
+
+static void
+do_bootm_qnxelf (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		 ulong addr, ulong *len_ptr, int verify)
+{
+	image_header_t *hdr = &header;
+	char *local_args[2];
+	char str[16];
+
+	sprintf(str, "%x", ntohl(hdr->ih_ep)); /* write entry-point into string */
+	local_args[0] = argv[0];
+	local_args[1] = str;	/* and provide it via the arguments */
+	do_bootelf(cmdtp, 0, 2, local_args);
+}
+#endif
+
+#ifdef CONFIG_LYNXKDI
+static void
+do_bootm_lynxkdi (cmd_tbl_t *cmdtp, int flag,
+		 int	argc, char *argv[],
+		 ulong	addr,
+		 ulong	*len_ptr,
+		 int	verify)
+{
+	lynxkdi_boot( &header );
+}
+
+#endif /* CONFIG_LYNXKDI */
diff -Nur u-boot-1.3.1/include/image.h u-boot-1.3.1-patched/include/image.h
--- u-boot-1.3.1/include/image.h	2007-12-06 10:21:19.000000000 +0100
+++ u-boot-1.3.1-patched/include/image.h	2011-07-02 21:07:24.588080757 +0200
@@ -134,6 +134,7 @@
 #define IH_COMP_NONE		0	/*  No	 Compression Used	*/
 #define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
 #define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+#define IH_COMP_LZMA		3	/* lzma  Compression Used	*/
 
 #define IH_MAGIC	0x27051956	/* Image Magic Number		*/
 #define IH_NMLEN		32	/* Image Name Length		*/
diff -Nur u-boot-1.3.1/include/image.h.orig u-boot-1.3.1-patched/include/image.h.orig
--- u-boot-1.3.1/include/image.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/include/image.h.orig	2007-12-06 10:21:19.000000000 +0100
@@ -0,0 +1,161 @@
+/*
+ * (C) Copyright 2000-2005
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ ********************************************************************
+ * NOTE: This header file defines an interface to U-Boot. Including
+ * this (unmodified) header file in another file is considered normal
+ * use of U-Boot, and does *not* fall under the heading of "derived
+ * work".
+ ********************************************************************
+ */
+
+#ifndef __IMAGE_H__
+#define __IMAGE_H__
+
+/*
+ * Operating System Codes
+ */
+#define IH_OS_INVALID		0	/* Invalid OS	*/
+#define IH_OS_OPENBSD		1	/* OpenBSD	*/
+#define IH_OS_NETBSD		2	/* NetBSD	*/
+#define IH_OS_FREEBSD		3	/* FreeBSD	*/
+#define IH_OS_4_4BSD		4	/* 4.4BSD	*/
+#define IH_OS_LINUX		5	/* Linux	*/
+#define IH_OS_SVR4		6	/* SVR4		*/
+#define IH_OS_ESIX		7	/* Esix		*/
+#define IH_OS_SOLARIS		8	/* Solaris	*/
+#define IH_OS_IRIX		9	/* Irix		*/
+#define IH_OS_SCO		10	/* SCO		*/
+#define IH_OS_DELL		11	/* Dell		*/
+#define IH_OS_NCR		12	/* NCR		*/
+#define IH_OS_LYNXOS		13	/* LynxOS	*/
+#define IH_OS_VXWORKS		14	/* VxWorks	*/
+#define IH_OS_PSOS		15	/* pSOS		*/
+#define IH_OS_QNX		16	/* QNX		*/
+#define IH_OS_U_BOOT		17	/* Firmware	*/
+#define IH_OS_RTEMS		18	/* RTEMS	*/
+#define IH_OS_ARTOS		19	/* ARTOS	*/
+#define IH_OS_UNITY		20	/* Unity OS	*/
+
+/*
+ * CPU Architecture Codes (supported by Linux)
+ */
+#define IH_CPU_INVALID		0	/* Invalid CPU	*/
+#define IH_CPU_ALPHA		1	/* Alpha	*/
+#define IH_CPU_ARM		2	/* ARM		*/
+#define IH_CPU_I386		3	/* Intel x86	*/
+#define IH_CPU_IA64		4	/* IA64		*/
+#define IH_CPU_MIPS		5	/* MIPS		*/
+#define IH_CPU_MIPS64		6	/* MIPS	 64 Bit */
+#define IH_CPU_PPC		7	/* PowerPC	*/
+#define IH_CPU_S390		8	/* IBM S390	*/
+#define IH_CPU_SH		9	/* SuperH	*/
+#define IH_CPU_SPARC		10	/* Sparc	*/
+#define IH_CPU_SPARC64		11	/* Sparc 64 Bit */
+#define IH_CPU_M68K		12	/* M68K		*/
+#define IH_CPU_NIOS		13	/* Nios-32	*/
+#define IH_CPU_MICROBLAZE	14	/* MicroBlaze   */
+#define IH_CPU_NIOS2		15	/* Nios-II	*/
+#define IH_CPU_BLACKFIN		16	/* Blackfin	*/
+#define IH_CPU_AVR32		17	/* AVR32	*/
+#define IH_CPU_ST200	        18	/* STMicroelectronics ST200  */
+
+/*
+ * Image Types
+ *
+ * "Standalone Programs" are directly runnable in the environment
+ *	provided by U-Boot; it is expected that (if they behave
+ *	well) you can continue to work in U-Boot after return from
+ *	the Standalone Program.
+ * "OS Kernel Images" are usually images of some Embedded OS which
+ *	will take over control completely. Usually these programs
+ *	will install their own set of exception handlers, device
+ *	drivers, set up the MMU, etc. - this means, that you cannot
+ *	expect to re-enter U-Boot except by resetting the CPU.
+ * "RAMDisk Images" are more or less just data blocks, and their
+ *	parameters (address, size) are passed to an OS kernel that is
+ *	being started.
+ * "Multi-File Images" contain several images, typically an OS
+ *	(Linux) kernel image and one or more data images like
+ *	RAMDisks. This construct is useful for instance when you want
+ *	to boot over the network using BOOTP etc., where the boot
+ *	server provides just a single image file, but you want to get
+ *	for instance an OS kernel and a RAMDisk image.
+ *
+ *	"Multi-File Images" start with a list of image sizes, each
+ *	image size (in bytes) specified by an "uint32_t" in network
+ *	byte order. This list is terminated by an "(uint32_t)0".
+ *	Immediately after the terminating 0 follow the images, one by
+ *	one, all aligned on "uint32_t" boundaries (size rounded up to
+ *	a multiple of 4 bytes - except for the last file).
+ *
+ * "Firmware Images" are binary images containing firmware (like
+ *	U-Boot or FPGA images) which usually will be programmed to
+ *	flash memory.
+ *
+ * "Script files" are command sequences that will be executed by
+ *	U-Boot's command interpreter; this feature is especially
+ *	useful when you configure U-Boot to use a real shell (hush)
+ *	as command interpreter (=> Shell Scripts).
+ */
+
+#define IH_TYPE_INVALID		0	/* Invalid Image		*/
+#define IH_TYPE_STANDALONE	1	/* Standalone Program		*/
+#define IH_TYPE_KERNEL		2	/* OS Kernel Image		*/
+#define IH_TYPE_RAMDISK		3	/* RAMDisk Image		*/
+#define IH_TYPE_MULTI		4	/* Multi-File Image		*/
+#define IH_TYPE_FIRMWARE	5	/* Firmware Image		*/
+#define IH_TYPE_SCRIPT		6	/* Script file			*/
+#define IH_TYPE_FILESYSTEM	7	/* Filesystem Image (any type)	*/
+#define IH_TYPE_FLATDT		8	/* Binary Flat Device Tree Blob	*/
+
+/*
+ * Compression Types
+ */
+#define IH_COMP_NONE		0	/*  No	 Compression Used	*/
+#define IH_COMP_GZIP		1	/* gzip	 Compression Used	*/
+#define IH_COMP_BZIP2		2	/* bzip2 Compression Used	*/
+
+#define IH_MAGIC	0x27051956	/* Image Magic Number		*/
+#define IH_NMLEN		32	/* Image Name Length		*/
+
+/*
+ * all data in network byte order (aka natural aka bigendian)
+ */
+
+typedef struct image_header {
+	uint32_t	ih_magic;	/* Image Header Magic Number	*/
+	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
+	uint32_t	ih_time;	/* Image Creation Timestamp	*/
+	uint32_t	ih_size;	/* Image Data Size		*/
+	uint32_t	ih_load;	/* Data	 Load  Address		*/
+	uint32_t	ih_ep;		/* Entry Point Address		*/
+	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
+	uint8_t		ih_os;		/* Operating System		*/
+	uint8_t		ih_arch;	/* CPU architecture		*/
+	uint8_t		ih_type;	/* Image Type			*/
+	uint8_t		ih_comp;	/* Compression Type		*/
+	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
+} image_header_t;
+
+
+#endif	/* __IMAGE_H__ */
diff -Nur u-boot-1.3.1/include/lzma/LzmaDecode.h u-boot-1.3.1-patched/include/lzma/LzmaDecode.h
--- u-boot-1.3.1/include/lzma/LzmaDecode.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/include/lzma/LzmaDecode.h	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,31 @@
+/*
+ * Fake include for LzmaDecode.h
+ *
+ * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
+ * Luigi 'Comio' Mantellini (luigi.mantellini at idf-hit.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LZMADECODE_H__FAKE__
+#define __LZMADECODE_H__FAKE__
+
+#include "../../lib_generic/lzma/LzmaDecode.h"
+
+#endif
diff -Nur u-boot-1.3.1/include/lzma/LzmaTools.h u-boot-1.3.1-patched/include/lzma/LzmaTools.h
--- u-boot-1.3.1/include/lzma/LzmaTools.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/include/lzma/LzmaTools.h	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,31 @@
+/*
+ * Fake include for LzmaTools.h
+ *
+ * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
+ * Luigi 'Comio' Mantellini (luigi.mantellini at idf-hit.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LZMATOOLS_H__FAKE__
+#define __LZMATOOLS_H__FAKE__
+
+#include "../../lib_generic/lzma/LzmaTools.h"
+
+#endif
diff -Nur u-boot-1.3.1/include/lzma/LzmaTypes.h u-boot-1.3.1-patched/include/lzma/LzmaTypes.h
--- u-boot-1.3.1/include/lzma/LzmaTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/include/lzma/LzmaTypes.h	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,31 @@
+/*
+ * Fake include for LzmaTypes.h
+ *
+ * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
+ * Luigi 'Comio' Mantellini (luigi.mantellini at idf-hit.com)
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LZMATYPES_H__FAKE__
+#define __LZMATYPES_H__FAKE__
+
+#include "../../lib_generic/lzma/LzmaTypes.h"
+
+#endif
diff -Nur u-boot-1.3.1/lib_generic/lzma/history.txt u-boot-1.3.1-patched/lib_generic/lzma/history.txt
--- u-boot-1.3.1/lib_generic/lzma/history.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/history.txt	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,198 @@
+HISTORY of the LZMA SDK
+-----------------------
+
+  4.57           2007-12-12
+  -------------------------
+    - Speed optimizations in ++ LZMA Decoder. 
+    - Small changes for more compatibility with some C/C++ compilers.
+
+  
+  4.49 beta      2007-07-05
+  -------------------------
+    - .7z ANSI-C Decoder:
+         - now it supports BCJ and BCJ2 filters
+         - now it supports files larger than 4 GB.
+         - now it supports "Last Write Time" field for files.
+    - C++ code for .7z archives compressing/decompressing from 7-zip 
+      was included to LZMA SDK.
+      
+
+  4.43           2006-06-04
+  -------------------------
+    - Small changes for more compatibility with some C/C++ compilers.
+      
+
+  4.42           2006-05-15
+  -------------------------
+    - Small changes in .h files in ANSI-C version.
+      
+
+  4.39 beta      2006-04-14
+  -------------------------
+    - Bug in versions 4.33b:4.38b was fixed:
+      C++ version of LZMA encoder could not correctly compress 
+      files larger than 2 GB with HC4 match finder (-mfhc4).
+      
+
+  4.37 beta      2005-04-06
+  -------------------------
+    - Fixes in C++ code: code could no be compiled if _NO_EXCEPTIONS was defined. 
+
+  
+  4.35 beta      2005-03-02
+  -------------------------
+    - Bug was fixed in C++ version of LZMA Decoder:
+       If encoded stream was corrupted, decoder could access memory 
+       outside of allocated range.
+
+  
+  4.34 beta      2006-02-27
+  -------------------------
+    - Compressing speed and memory requirements for compressing were increased
+    - LZMA now can use only these match finders: HC4, BT2, BT3, BT4
+
+  
+  4.32           2005-12-09
+  -------------------------
+    - Java version of LZMA SDK was included
+
+
+  4.30           2005-11-20
+  -------------------------
+    - Compression ratio was improved in -a2 mode
+    - Speed optimizations for compressing in -a2 mode
+    - -fb switch now supports values up to 273
+    - Bug in 7z_C (7zIn.c) was fixed:
+      It used Alloc/Free functions from different memory pools.
+      So if program used two memory pools, it worked incorrectly.
+    - 7z_C: .7z format supporting was improved
+    - LZMA# SDK (C#.NET version) was included
+
+
+  4.27 (Updated) 2005-09-21
+  -------------------------
+   - Some GUIDs/interfaces in C++ were changed.
+     IStream.h:
+       ISequentialInStream::Read now works as old ReadPart
+       ISequentialOutStream::Write now works as old WritePart
+
+  
+  4.27           2005-08-07
+  -------------------------
+    - Bug in LzmaDecodeSize.c was fixed:
+       if _LZMA_IN_CB and _LZMA_OUT_READ were defined,
+       decompressing worked incorrectly.
+
+
+  4.26           2005-08-05
+  -------------------------
+    - Fixes in 7z_C code and LzmaTest.c:
+      previous versions could work incorrectly,
+      if malloc(0) returns 0
+
+
+  4.23           2005-06-29
+  -------------------------
+    - Small fixes in C++ code
+
+
+  4.22           2005-06-10
+  -------------------------
+    - Small fixes
+
+
+  4.21           2005-06-08
+  -------------------------
+    - Interfaces for ANSI-C LZMA Decoder (LzmaDecode.c) were changed
+    - New additional version of ANSI-C LZMA Decoder with zlib-like interface:
+        - LzmaStateDecode.h
+        - LzmaStateDecode.c
+        - LzmaStateTest.c
+    - ANSI-C LZMA Decoder now can decompress files larger than 4 GB
+
+  
+  4.17           2005-04-18
+  -------------------------
+    - New example for RAM->RAM compressing/decompressing: 
+      LZMA + BCJ (filter for x86 code):
+        - LzmaRam.h
+        - LzmaRam.cpp
+        - LzmaRamDecode.h
+        - LzmaRamDecode.c
+        - -f86 switch for lzma.exe
+
+  
+  4.16           2005-03-29
+  -------------------------
+    - Bug was fixed in LzmaDecode.c (ANSI-C LZMA Decoder): 
+       If _LZMA_OUT_READ was defined, and if encoded stream was corrupted,
+       decoder could access memory outside of allocated range.
+    - Speed optimization of ANSI-C LZMA Decoder (now it's about 20% faster).
+      Old version of LZMA Decoder now is in file LzmaDecodeSize.c. 
+      LzmaDecodeSize.c can provide slightly smaller code than LzmaDecode.c
+    - Small speed optimization in LZMA C++ code
+    - filter for SPARC's code was added
+    - Simplified version of .7z ANSI-C Decoder was included
+
+
+  4.06           2004-09-05
+  -------------------------
+    - Bug in v4.05 was fixed:
+        LZMA-Encoder didn't release output stream in some cases.
+
+
+  4.05           2004-08-25
+  -------------------------
+    - Source code of filters for x86, IA-64, ARM, ARM-Thumb 
+      and PowerPC code was included to SDK
+    - Some internal minor changes
+
+
+  4.04           2004-07-28
+  -------------------------
+    - More compatibility with some C++ compilers
+
+
+  4.03           2004-06-18
+  -------------------------
+    - "Benchmark" command was added. It measures compressing 
+      and decompressing speed and shows rating values. 
+      Also it checks hardware errors.
+
+
+  4.02           2004-06-10
+  -------------------------
+    - C++ LZMA Encoder/Decoder code now is more portable
+      and it can be compiled by GCC on Linux.
+
+
+  4.01           2004-02-15
+  -------------------------
+    - Some detection of data corruption was enabled.
+        LzmaDecode.c / RangeDecoderReadByte
+        .....
+        {
+          rd->ExtraBytes = 1;
+          return 0xFF;
+        }
+
+
+  4.00           2004-02-13
+  -------------------------
+    - Original version of LZMA SDK
+
+
+
+HISTORY of the LZMA
+-------------------
+  2001-2007:  Improvements to LZMA compressing/decompressing code, 
+              keeping compatibility with original LZMA format
+  1996-2001:  Development of LZMA compression format
+
+  Some milestones:
+
+  2001-08-30: LZMA compression was added to 7-Zip
+  1999-01-02: First version of 7-Zip was released
+  
+
+End of document
diff -Nur u-boot-1.3.1/lib_generic/lzma/import_lzmasdk.sh u-boot-1.3.1-patched/lib_generic/lzma/import_lzmasdk.sh
--- u-boot-1.3.1/lib_generic/lzma/import_lzmasdk.sh	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/import_lzmasdk.sh	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,38 @@
+#!/bin/sh
+
+usage() {
+	echo "Usage: $0 lzmaVERSION.tar.bz2" >&2
+	echo >&2
+	exit 1
+}
+
+if [ "$1" = "" ] ; then
+ 	 usage
+fi
+
+if [ ! -f $1 ] ; then
+	echo "$1 doesn't exist!" >&2
+	exit 1
+fi
+
+BASENAME=`basename $1 .tar.bz2`
+TMPDIR=/tmp/tmp_lib_$BASENAME
+FILES="C/Compress/Lzma/LzmaDecode.h
+      C/Compress/Lzma/LzmaTypes.h  
+      C/Compress/Lzma/LzmaDecode.c 
+      history.txt                  
+      LGPL.txt                     
+      lzma.txt"
+
+
+mkdir -p $TMPDIR
+echo "Untar $1 -> $TMPDIR"
+tar -jxf $1 -C $TMPDIR
+
+for i in $FILES; do
+	echo Copying  $TMPDIR/$i \-\> `basename $i`
+	cp $TMPDIR/$i .
+	chmod -x `basename $i`
+done
+
+echo "done!"
diff -Nur u-boot-1.3.1/lib_generic/lzma/LGPL.txt u-boot-1.3.1-patched/lib_generic/lzma/LGPL.txt
--- u-boot-1.3.1/lib_generic/lzma/LGPL.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LGPL.txt	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,504 @@
+      GNU LESSER GENERAL PUBLIC LICENSE
+           Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+          Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+      GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+          NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+         END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -Nur u-boot-1.3.1/lib_generic/lzma/LzmaDecode.c u-boot-1.3.1-patched/lib_generic/lzma/LzmaDecode.c
--- u-boot-1.3.1/lib_generic/lzma/LzmaDecode.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LzmaDecode.c	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,584 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff -Nur u-boot-1.3.1/lib_generic/lzma/LzmaDecode.h u-boot-1.3.1-patched/lib_generic/lzma/LzmaDecode.h
--- u-boot-1.3.1/lib_generic/lzma/LzmaDecode.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LzmaDecode.h	2011-07-02 21:07:24.588080757 +0200
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff -Nur u-boot-1.3.1/lib_generic/lzma/LzmaTools.c u-boot-1.3.1-patched/lib_generic/lzma/LzmaTools.c
--- u-boot-1.3.1/lib_generic/lzma/LzmaTools.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LzmaTools.c	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,142 @@
+/*
+ * Usefuls routines based on the LzmaTest.c file from LZMA SDK 4.57
+ *
+ * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
+ * Luigi 'Comio' Mantellini (luigi.mantellini at idf-hit.com)
+ *
+ * Copyright (C) 1999-2005 Igor Pavlov
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * LZMA_Alone stream format:
+ *
+ * uchar   Properties[5]
+ * uint64  Uncompressed size
+ * uchar   data[*]
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+
+#ifdef CONFIG_LZMA
+
+#define LZMA_PROPERTIES_OFFSET 0
+#define LZMA_SIZE_OFFSET       LZMA_PROPERTIES_SIZE
+#define LZMA_DATA_OFFSET       LZMA_SIZE_OFFSET+sizeof(uint64_t)
+
+#include "LzmaTools.h"
+#include "LzmaDecode.h"
+
+#include <linux/string.h>
+#include <malloc.h>
+
+int lzmaBuffToBuffDecompress (unsigned char *outStream, SizeT *uncompressedSize,
+			      unsigned char *inStream,  SizeT  length)
+{
+	int res = LZMA_RESULT_DATA_ERROR;
+	int i;
+	
+	SizeT outSizeFull = 0xFFFFFFFF; /* 4GBytes limit */
+	SizeT inProcessed;
+	SizeT outProcessed;
+	SizeT outSize;
+	SizeT outSizeHigh;
+	CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+	unsigned char properties[LZMA_PROPERTIES_SIZE];
+	SizeT compressedSize = (SizeT)(length - LZMA_DATA_OFFSET);
+
+	debug ("LZMA: Image address............... 0x%lx\n", inStream);
+	debug ("LZMA: Properties address.......... 0x%lx\n", inStream + LZMA_PROPERTIES_OFFSET);
+	debug ("LZMA: Uncompressed size address... 0x%lx\n", inStream + LZMA_SIZE_OFFSET);
+	debug ("LZMA: Compressed data address..... 0x%lx\n", inStream + LZMA_DATA_OFFSET);
+	debug ("LZMA: Destination address......... 0x%lx\n", outStream);
+
+	memcpy(properties, inStream + LZMA_PROPERTIES_OFFSET, LZMA_PROPERTIES_SIZE);
+ 
+  	memset(&state, 0, sizeof(state));
+	res = LzmaDecodeProperties(&state.Properties,
+				 properties,
+				 LZMA_PROPERTIES_SIZE);
+	if (res != LZMA_RESULT_OK) {
+		return res;
+	}
+
+	outSize = 0;
+	outSizeHigh = 0;
+	/* Read the uncompressed size */
+	for (i = 0; i < 8; i++) {
+        	unsigned char b = inStream[LZMA_SIZE_OFFSET + i];
+	        if (i < 4) {
+        	        outSize     += (UInt32)(b) << (i * 8);
+        	} else {
+	                outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+        	}
+	}
+
+	outSizeFull = (SizeT)outSize;
+	if (sizeof(SizeT) >= 8) {
+        	/*
+	         * SizeT is a 64 bit uint => We can manage files larger than 4GB!
+        	 *
+        	 */
+	        outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+	} else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize) {
+	        /*
+        	 * SizeT is a 32 bit uint => We cannot manage files larger than
+        	 * 4GB!
+        	 *
+        	 */
+		debug ("LZMA: 64bit support not enabled.\n");
+	        return LZMA_RESULT_DATA_ERROR;
+	}
+
+	debug ("LZMA: Uncompresed size............ 0x%lx\n", outSizeFull);
+	debug ("LZMA: Compresed size.............. 0x%lx\n", compressedSize);
+	debug ("LZMA: Dynamic memory needed....... 0x%lx", LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+	state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+	if (state.Probs == 0
+	    || (outStream == 0 && outSizeFull != 0)
+	    || (inStream == 0 && compressedSize != 0)) {
+		free(state.Probs);
+		debug ("\n");
+		return LZMA_RESULT_DATA_ERROR;
+	}
+
+	debug (" allocated.\n");
+
+	/* Decompress */
+
+	res = LzmaDecode(&state,
+		inStream + LZMA_DATA_OFFSET, compressedSize, &inProcessed,
+		outStream, outSizeFull,  &outProcessed);
+	if (res != LZMA_RESULT_OK)  {
+		return res;
+	}
+
+	*uncompressedSize = outProcessed;
+	free(state.Probs);
+	return res;
+}
+
+#endif
diff -Nur u-boot-1.3.1/lib_generic/lzma/LzmaTools.h u-boot-1.3.1-patched/lib_generic/lzma/LzmaTools.h
--- u-boot-1.3.1/lib_generic/lzma/LzmaTools.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LzmaTools.h	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,35 @@
+/*
+ * Usefuls routines based on the LzmaTest.c file from LZMA SDK 4.57
+ *
+ * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
+ * Luigi 'Comio' Mantellini (luigi.mantellini at idf-hit.com)
+ *
+ * Copyright (C) 1999-2005 Igor Pavlov
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+ 
+#ifndef __LZMA_TOOL_H__
+#define __LZMA_TOOL_H__
+
+#include "LzmaTypes.h"
+
+extern int lzmaBuffToBuffDecompress (unsigned char *outStream, SizeT *uncompressedSize,
+			      unsigned char *inStream,  SizeT  length);
+#endif
diff -Nur u-boot-1.3.1/lib_generic/lzma/lzma.txt u-boot-1.3.1-patched/lib_generic/lzma/lzma.txt
--- u-boot-1.3.1/lib_generic/lzma/lzma.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/lzma.txt	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,663 @@
+LZMA SDK 4.57
+-------------
+
+LZMA SDK   Copyright (C) 1999-2007 Igor Pavlov
+
+LZMA SDK provides the documentation, samples, header files, libraries, 
+and tools you need to develop applications that use LZMA compression.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+LZMA is an improved version of famous LZ77 compression algorithm. 
+It was improved in way of maximum increasing of compression ratio,
+keeping high decompression speed and low memory requirements for 
+decompressing.
+
+
+
+LICENSE
+-------
+
+LZMA SDK is available under any of the following licenses:
+
+1) GNU Lesser General Public License (GNU LGPL)
+2) Common Public License (CPL)
+3) Simplified license for unmodified code (read SPECIAL EXCEPTION) 
+4) Proprietary license 
+
+It means that you can select one of these four options and follow rules of that license.
+
+
+1,2) GNU LGPL and CPL licenses are pretty similar and both these
+licenses are classified as 
+ - "Free software licenses" at http://www.gnu.org/ 
+ - "OSI-approved" at http://www.opensource.org/
+
+
+3) SPECIAL EXCEPTION
+
+Igor Pavlov, as the author of this code, expressly permits you 
+to statically or dynamically link your code (or bind by name) 
+to the files from LZMA SDK without subjecting your linked 
+code to the terms of the CPL or GNU LGPL. 
+Any modifications or additions to files from LZMA SDK, however, 
+are subject to the GNU LGPL or CPL terms.
+
+SPECIAL EXCEPTION allows you to use LZMA SDK in applications with closed code, 
+while you keep LZMA SDK code unmodified.
+
+
+SPECIAL EXCEPTION #2: Igor Pavlov, as the author of this code, expressly permits 
+you to use this code under the same terms and conditions contained in the License 
+Agreement you have for any previous version of LZMA SDK developed by Igor Pavlov.
+
+SPECIAL EXCEPTION #2 allows owners of proprietary licenses to use latest version 
+of LZMA SDK as update for previous versions.
+
+
+SPECIAL EXCEPTION #3: Igor Pavlov, as the author of this code, expressly permits 
+you to use code of the following files: 
+BranchTypes.h, LzmaTypes.h, LzmaTest.c, LzmaStateTest.c, LzmaAlone.cpp, 
+LzmaAlone.cs, LzmaAlone.java
+as public domain code. 
+
+
+4) Proprietary license
+
+LZMA SDK also can be available under a proprietary license which 
+can include:
+
+1) Right to modify code without subjecting modified code to the 
+terms of the CPL or GNU LGPL
+2) Technical support for code
+
+To request such proprietary license or any additional consultations,
+send email message from that page:
+http://www.7-zip.org/support.html
+
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+You should have received a copy of the Common Public License
+along with this library.
+
+
+LZMA SDK Contents
+-----------------
+
+LZMA SDK includes:
+
+  - C++ source code of LZMA compressing and decompressing
+  - ANSI-C compatible source code for LZMA decompressing
+  - C# source code for LZMA compressing and decompressing
+  - Java source code for LZMA compressing and decompressing
+  - Compiled file->file LZMA compressing/decompressing program for Windows system
+
+ANSI-C LZMA decompression code was ported from original C++ sources to C.
+Also it was simplified and optimized for code size. 
+But it is fully compatible with LZMA from 7-Zip.
+
+
+UNIX/Linux version 
+------------------
+To compile C++ version of file->file LZMA, go to directory
+C/7zip/Compress/LZMA_Alone 
+and type "make" or "make clean all" to recompile all.
+
+In some UNIX/Linux versions you must compile LZMA with static libraries.
+To compile with static libraries, change string in makefile
+LIB = -lm
+to string  
+LIB = -lm -static
+
+
+Files
+---------------------
+C        - C source code
+CPP      - CPP source code
+CS       - C# source code
+Java     - Java source code
+lzma.txt - LZMA SDK description (this file)
+7zFormat.txt - 7z Format description
+7zC.txt  - 7z ANSI-C Decoder description (this file)
+methods.txt  - Compression method IDs for .7z
+LGPL.txt - GNU Lesser General Public License
+CPL.html - Common Public License
+lzma.exe - Compiled file->file LZMA encoder/decoder for Windows
+history.txt - history of the LZMA SDK
+
+
+Source code structure
+---------------------
+
+C  - C files
+    Compress - files related to compression/decompression
+      Lz     - files related to LZ (Lempel-Ziv) compression algorithm
+      Lzma   - ANSI-C compatible LZMA decompressor
+
+        LzmaDecode.h  - interface for LZMA decoding on ANSI-C
+        LzmaDecode.c      - LZMA decoding on ANSI-C (new fastest version)
+        LzmaDecodeSize.c  - LZMA decoding on ANSI-C (old size-optimized version)
+        LzmaTest.c        - test application that decodes LZMA encoded file
+        LzmaTypes.h       - basic types for LZMA Decoder
+        LzmaStateDecode.h - interface for LZMA decoding (State version)
+        LzmaStateDecode.c - LZMA decoding on ANSI-C (State version)
+        LzmaStateTest.c   - test application (State version)
+
+      Branch       - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+
+    Archive - files related to archiving
+      7z_C     - 7z ANSI-C Decoder
+
+
+CPP -- CPP files
+
+  Common  - common files for C++ projects
+  Windows - common files for Windows related code
+  7zip    - files related to 7-Zip Project
+
+    Common   - common files for 7-Zip
+
+    Compress - files related to compression/decompression
+
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+
+      Copy         - Copy coder
+      RangeCoder   - Range Coder (special code of compression/decompression)
+      LZMA         - LZMA compression/decompression on C++
+      LZMA_Alone   - file->file LZMA compression/decompression
+
+      Branch       - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+
+    Archive - files related to archiving
+
+      Common   - common files for archive handling
+      7z       - 7z C++ Encoder/Decoder
+
+    Bundles    - Modules that are bundles of other modules
+  
+      Alone7z           - 7zr.exe: Standalone version of 7z.exe that supports only 7z/LZMA/BCJ/BCJ2
+      Format7zR         - 7zr.dll: Reduced version of 7za.dll: extracting/compressing to 7z/LZMA/BCJ/BCJ2
+      Format7zExtractR  - 7zxr.dll: Reduced version of 7zxa.dll: extracting from 7z/LZMA/BCJ/BCJ2.
+
+    UI        - User Interface files
+         
+      Client7z - Test application for 7za.dll,  7zr.dll, 7zxr.dll
+      Common   - Common UI files
+      Console  - Code for console archiver
+
+
+
+CS - C# files
+  7zip
+    Common   - some common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      LzmaAlone    - file->file LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+Java  - Java files
+  SevenZip
+    Compression    - files related to compression/decompression
+      LZ           - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+C/C++ source code of LZMA SDK is part of 7-Zip project.
+
+You can find ANSI-C LZMA decompressing code at folder 
+  C/7zip/Compress/Lzma
+7-Zip doesn't use that ANSI-C LZMA code and that code was developed 
+specially for this SDK. And files from C/7zip/Compress/Lzma do not need 
+files from other directories of SDK for compiling.
+
+7-Zip source code can be downloaded from 7-Zip's SourceForge page:
+
+  http://sourceforge.net/projects/sevenzip/
+
+
+LZMA features
+-------------
+  - Variable dictionary size (up to 1 GB)
+  - Estimated compressing speed: about 1 MB/s on 1 GHz CPU
+  - Estimated decompressing speed: 
+      - 8-12 MB/s on 1 GHz Intel Pentium 3 or AMD Athlon
+      - 500-1000 KB/s on 100 MHz ARM, MIPS, PowerPC or other simple RISC
+  - Small memory requirements for decompressing (8-32 KB + DictionarySize)
+  - Small code size for decompressing: 2-8 KB (depending from 
+    speed optimizations) 
+
+LZMA decoder uses only integer operations and can be 
+implemented in any modern 32-bit CPU (or on 16-bit CPU with some conditions).
+
+Some critical operations that affect to speed of LZMA decompression:
+  1) 32*16 bit integer multiply
+  2) Misspredicted branches (penalty mostly depends from pipeline length)
+  3) 32-bit shift and arithmetic operations
+
+Speed of LZMA decompressing mostly depends from CPU speed.
+Memory speed has no big meaning. But if your CPU has small data cache, 
+overall weight of memory speed will slightly increase.
+
+
+How To Use
+----------
+
+Using LZMA encoder/decoder executable
+--------------------------------------
+
+Usage:  LZMA <e|d> inputFile outputFile [<switches>...]
+
+  e: encode file
+
+  d: decode file
+
+  b: Benchmark. There are two tests: compressing and decompressing 
+     with LZMA method. Benchmark shows rating in MIPS (million 
+     instructions per second). Rating value is calculated from 
+     measured speed and it is normalized with AMD Athlon 64 X2 CPU
+     results. Also Benchmark checks possible hardware errors (RAM 
+     errors in most cases). Benchmark uses these settings:
+     (-a1, -d21, -fb32, -mfbt4). You can change only -d. Also you 
+     can change number of iterations. Example for 30 iterations:
+       LZMA b 30
+     Default number of iterations is 10.
+
+<Switches>
+  
+
+  -a{N}:  set compression mode 0 = fast, 1 = normal
+          default: 1 (normal)
+
+  d{N}:   Sets Dictionary size - [0, 30], default: 23 (8MB)
+          The maximum value for dictionary size is 1 GB = 2^30 bytes.
+          Dictionary size is calculated as DictionarySize = 2^N bytes. 
+          For decompressing file compressed by LZMA method with dictionary 
+          size D = 2^N you need about D bytes of memory (RAM).
+
+  -fb{N}: set number of fast bytes - [5, 273], default: 128
+          Usually big number gives a little bit better compression ratio 
+          and slower compression process.
+
+  -lc{N}: set number of literal context bits - [0, 8], default: 3
+          Sometimes lc=4 gives gain for big files.
+
+  -lp{N}: set number of literal pos bits - [0, 4], default: 0
+          lp switch is intended for periodical data when period is 
+          equal 2^N. For example, for 32-bit (4 bytes) 
+          periodical data you can use lp=2. Often it's better to set lc0, 
+          if you change lp switch.
+
+  -pb{N}: set number of pos bits - [0, 4], default: 2
+          pb switch is intended for periodical data 
+          when period is equal 2^N.
+
+  -mf{MF_ID}: set Match Finder. Default: bt4. 
+              Algorithms from hc* group doesn't provide good compression 
+              ratio, but they often works pretty fast in combination with 
+              fast mode (-a0).
+
+              Memory requirements depend from dictionary size 
+              (parameter "d" in table below). 
+
+               MF_ID     Memory                   Description
+
+                bt2    d *  9.5 + 4MB  Binary Tree with 2 bytes hashing.
+                bt3    d * 11.5 + 4MB  Binary Tree with 3 bytes hashing.
+                bt4    d * 11.5 + 4MB  Binary Tree with 4 bytes hashing.
+                hc4    d *  7.5 + 4MB  Hash Chain with 4 bytes hashing.
+
+  -eos:   write End Of Stream marker. By default LZMA doesn't write 
+          eos marker, since LZMA decoder knows uncompressed size 
+          stored in .lzma file header.
+
+  -si:    Read data from stdin (it will write End Of Stream marker).
+  -so:    Write data to stdout
+
+
+Examples:
+
+1) LZMA e file.bin file.lzma -d16 -lc0 
+
+compresses file.bin to file.lzma with 64 KB dictionary (2^16=64K)  
+and 0 literal context bits. -lc0 allows to reduce memory requirements 
+for decompression.
+
+
+2) LZMA e file.bin file.lzma -lc0 -lp2
+
+compresses file.bin to file.lzma with settings suitable 
+for 32-bit periodical data (for example, ARM or MIPS code).
+
+3) LZMA d file.lzma file.bin
+
+decompresses file.lzma to file.bin.
+
+
+Compression ratio hints
+-----------------------
+
+Recommendations
+---------------
+
+To increase compression ratio for LZMA compressing it's desirable 
+to have aligned data (if it's possible) and also it's desirable to locate
+data in such order, where code is grouped in one place and data is 
+grouped in other place (it's better than such mixing: code, data, code,
+data, ...).
+
+
+Using Filters
+-------------
+You can increase compression ratio for some data types, using
+special filters before compressing. For example, it's possible to 
+increase compression ratio on 5-10% for code for those CPU ISAs: 
+x86, IA-64, ARM, ARM-Thumb, PowerPC, SPARC.
+
+You can find C/C++ source code of such filters in folder "7zip/Compress/Branch"
+
+You can check compression ratio gain of these filters with such 
+7-Zip commands (example for ARM code):
+No filter:
+  7z a a1.7z a.bin -m0=lzma
+
+With filter for little-endian ARM code:
+  7z a a2.7z a.bin -m0=bc_arm -m1=lzma        
+
+With filter for big-endian ARM code (using additional Swap4 filter):
+  7z a a3.7z a.bin -m0=swap4 -m1=bc_arm -m2=lzma
+
+It works in such manner:
+Compressing    = Filter_encoding + LZMA_encoding
+Decompressing  = LZMA_decoding + Filter_decoding
+
+Compressing and decompressing speed of such filters is very high,
+so it will not increase decompressing time too much.
+Moreover, it reduces decompression time for LZMA_decoding, 
+since compression ratio with filtering is higher.
+
+These filters convert CALL (calling procedure) instructions 
+from relative offsets to absolute addresses, so such data becomes more 
+compressible. Source code of these CALL filters is pretty simple
+(about 20 lines of C++), so you can convert it from C++ version yourself.
+
+For some ISAs (for example, for MIPS) it's impossible to get gain from such filter.
+
+
+LZMA compressed file format
+---------------------------
+Offset Size Description
+  0     1   Special LZMA properties for compressed data
+  1     4   Dictionary size (little endian)
+  5     8   Uncompressed size (little endian). -1 means unknown size
+ 13         Compressed data
+
+
+ANSI-C LZMA Decoder
+~~~~~~~~~~~~~~~~~~~
+
+To compile ANSI-C LZMA Decoder you can use one of the following files sets:
+1) LzmaDecode.h + LzmaDecode.c + LzmaTest.c  (fastest version)
+2) LzmaDecode.h + LzmaDecodeSize.c + LzmaTest.c  (old size-optimized version)
+3) LzmaStateDecode.h + LzmaStateDecode.c + LzmaStateTest.c  (zlib-like interface)
+
+
+Memory requirements for LZMA decoding
+-------------------------------------
+
+LZMA decoder doesn't allocate memory itself, so you must 
+allocate memory and send it to LZMA.
+
+Stack usage of LZMA decoding function for local variables is not 
+larger than 200 bytes.
+
+How To decompress data
+----------------------
+
+LZMA Decoder (ANSI-C version) now supports 5 interfaces:
+1) Single-call Decompressing
+2) Single-call Decompressing with input stream callback
+3) Multi-call Decompressing with output buffer
+4) Multi-call Decompressing with input callback and output buffer
+5) Multi-call State Decompressing (zlib-like interface)
+
+Variant-5 is similar to Variant-4, but Variant-5 doesn't use callback functions.
+
+Decompressing steps
+-------------------
+
+1) read LZMA properties (5 bytes):
+   unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+2) read uncompressed size (8 bytes, little-endian)
+
+3) Decode properties:
+
+  CLzmaDecoderState state;  /* it's 24-140 bytes structure, if int is 32-bit */
+
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, "Incorrect stream properties");
+
+4) Allocate memory block for internal Structures:
+
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return PrintError(rs, kCantAllocateMessage);
+
+  LZMA decoder uses array of CProb variables as internal structure.
+  By default, CProb is unsigned_short. But you can define _LZMA_PROB32 to make 
+  it unsigned_int. It can increase speed on some 32-bit CPUs, but memory 
+  usage will be doubled in that case.
+
+
+5) Main Decompressing
+
+You must use one of the following interfaces:
+
+5.1 Single-call Decompressing
+-----------------------------
+When to use: RAM->RAM decompressing
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: no defines
+Memory Requirements:
+  - Input buffer: compressed size
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  int res = LzmaDecode(&state, 
+      inStream, compressedSize, &inProcessed,
+      outStream, outSize, &outProcessed);
+
+
+5.2 Single-call Decompressing with input stream callback
+--------------------------------------------------------
+When to use: File->RAM or Flash->RAM decompressing.
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB
+Memory Requirements:
+  - Buffer for input stream: any size (for example, 16 KB)
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  typedef struct _CBuffer
+  {
+    ILzmaInCallback InCallback;
+    FILE *File;
+    unsigned char Buffer[kInBufferSize];
+  } CBuffer;
+
+  int LzmaReadCompressed(void *object, const unsigned char **buffer, SizeT *size)
+  {
+    CBuffer *bo = (CBuffer *)object;
+    *buffer = bo->Buffer;
+    *size = MyReadFile(bo->File, bo->Buffer, kInBufferSize);
+    return LZMA_RESULT_OK;
+  }
+
+  CBuffer g_InBuffer;
+
+  g_InBuffer.File = inFile;
+  g_InBuffer.InCallback.Read = LzmaReadCompressed;
+  int res = LzmaDecode(&state, 
+      &g_InBuffer.InCallback,
+      outStream, outSize, &outProcessed);
+
+
+5.3 Multi-call decompressing with output buffer
+-----------------------------------------------
+When to use: RAM->File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_OUT_READ
+Memory Requirements:
+ - Input buffer: compressed size
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  LzmaDecoderInit(&state);
+  do
+  {
+    LzmaDecode(&state,
+      inBuffer, inAvail, &inProcessed,
+      g_OutBuffer, outAvail, &outProcessed);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details.
+
+
+5.4 Multi-call decompressing with input callback and output buffer
+------------------------------------------------------------------
+When to use: File->File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB, _LZMA_OUT_READ
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+ 
+  LzmaDecoderInit(&state);
+  do
+  {
+    LzmaDecode(&state,
+      &bo.InCallback,
+      g_OutBuffer, outAvail, &outProcessed);
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details:
+
+
+5.5 Multi-call State Decompressing (zlib-like interface)
+------------------------------------------------------------------
+When to use: file->file decompressing 
+Compile files: LzmaStateDecode.h, LzmaStateDecode.c
+Compile defines:
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  
+  LzmaDecoderInit(&state);
+  do
+  {
+    res = LzmaDecode(&state,
+      inBuffer, inAvail, &inProcessed,
+      g_OutBuffer, outAvail, &outProcessed,
+      finishDecoding);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaStateTest.c for more details:
+
+
+6) Free all allocated blocks
+
+
+Note
+----
+LzmaDecodeSize.c is size-optimized version of LzmaDecode.c.
+But compiled code of LzmaDecodeSize.c can be larger than 
+compiled code of LzmaDecode.c. So it's better to use 
+LzmaDecode.c in most cases.
+
+
+EXIT codes
+-----------
+
+LZMA decoder can return one of the following codes:
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+If you use callback function for input data and you return some 
+error code, LZMA Decoder also returns that code.
+
+
+
+LZMA Defines
+------------
+
+_LZMA_IN_CB    - Use callback for input data
+
+_LZMA_OUT_READ - Use read function for output data
+
+_LZMA_LOC_OPT  - Enable local speed optimizations inside code.
+                 _LZMA_LOC_OPT is only for LzmaDecodeSize.c (size-optimized version).
+                 _LZMA_LOC_OPT doesn't affect LzmaDecode.c (speed-optimized version)
+                 and LzmaStateDecode.c
+
+_LZMA_PROB32   - It can increase speed on some 32-bit CPUs, 
+                 but memory usage will be doubled in that case
+
+_LZMA_UINT32_IS_ULONG  - Define it if int is 16-bit on your compiler
+                         and long is 32-bit.
+
+_LZMA_SYSTEM_SIZE_T  - Define it if you want to use system's size_t.
+                       You can use it to enable 64-bit sizes supporting
+
+
+
+C++ LZMA Encoder/Decoder 
+~~~~~~~~~~~~~~~~~~~~~~~~
+C++ LZMA code use COM-like interfaces. So if you want to use it, 
+you can study basics of COM/OLE.
+
+By default, LZMA Encoder contains all Match Finders.
+But for compressing it's enough to have just one of them.
+So for reducing size of compressing code you can define:
+  #define COMPRESS_MF_BT
+  #define COMPRESS_MF_BT4
+and it will use only bt4 match finder.
+
+
+---
+
+http://www.7-zip.org
+http://www.7-zip.org/support.html
diff -Nur u-boot-1.3.1/lib_generic/lzma/LzmaTypes.h u-boot-1.3.1-patched/lib_generic/lzma/LzmaTypes.h
--- u-boot-1.3.1/lib_generic/lzma/LzmaTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/LzmaTypes.h	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_NO_SYSTEM_SIZE_T */
+/* You can use it, if you don't want <stddef.h> */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+#include <stddef.h>
+typedef size_t SizeT;
+#endif
+#endif
+
+#endif
diff -Nur u-boot-1.3.1/lib_generic/lzma/README.txt u-boot-1.3.1-patched/lib_generic/lzma/README.txt
--- u-boot-1.3.1/lib_generic/lzma/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/lib_generic/lzma/README.txt	2011-07-02 21:07:24.592079171 +0200
@@ -0,0 +1,28 @@
+The lib_lzma functionality was written by Igor Pavlov. 
+The original source cames from the LZMA SDK web page:
+
+URL: 		http://www.7-zip.org/sdk.html
+Author:         Igor Pavlov
+
+The import is made using the import_lzmasdk.sh script that:
+
+* untars the lzmaXYY.tar.bz2 file (from the download web page)
+* copies the files LzmaDecode.h, LzmaTypes.h, LzmaDecode.c, history.txt,
+  LGPL.txt, and lzma.txt from source archive into the lib_lzma directory (pwd).
+
+Example:
+
+ ./import_lzmasdk.sh ~/lzma457.tar.bz2
+
+Notice: The files from lzma sdk are not _modified_ by this script!
+
+The files LzmaTools.{c,h} are provided to export the lzmaBuffToBuffDecompress()
+function that wraps the complex LzmaDecode() function from the LZMA SDK. The
+do_bootm() function uses the lzmaBuffToBuffDecopress() function to expand the
+compressed image.
+
+The directory U-BOOT/include/lzma contains stubs files that permit to use the
+library directly from U-BOOT code without touching the original LZMA SDK's
+files.
+
+Luigi 'Comio' Mantellini <luigi.mantellini at idf-hit.com>
diff -Nur u-boot-1.3.1/Makefile u-boot-1.3.1-patched/Makefile
--- u-boot-1.3.1/Makefile	2011-07-02 21:08:15.724078807 +0200
+++ u-boot-1.3.1-patched/Makefile	2011-07-02 21:07:24.580080647 +0200
@@ -196,6 +196,7 @@
 OBJS := $(addprefix $(obj),$(OBJS))
 
 LIBS  = lib_generic/libgeneric.a
+LIBS += lib_generic/lzma/liblzma.a
 LIBS += $(shell if [ -f board/$(VENDOR)/common/Makefile ]; then echo \
 	"board/$(VENDOR)/common/lib$(VENDOR).a"; fi)
 LIBS += board/$(BOARDDIR)/lib$(BOARD).a
diff -Nur u-boot-1.3.1/Makefile.orig u-boot-1.3.1-patched/Makefile.orig
--- u-boot-1.3.1/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/Makefile.orig	2011-07-02 21:06:32.403078780 +0200
@@ -0,0 +1,2950 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundatio; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+VERSION = 1
+PATCHLEVEL = 3
+SUBLEVEL = 1
+EXTRAVERSION =
+U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+VERSION_FILE = $(obj)include/version_autogenerated.h
+
+HOSTARCH := $(shell uname -m | \
+	sed -e s/i.86/i386/ \
+	    -e s/sun4u/sparc64/ \
+	    -e s/arm.*/arm/ \
+	    -e s/sa110/arm/ \
+	    -e s/powerpc/ppc/ \
+	    -e s/ppc64/ppc/ \
+	    -e s/macppc/ppc/)
+
+HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
+	    sed -e 's/\(cygwin\).*/cygwin/')
+
+export	HOSTARCH HOSTOS
+
+# Deal with colliding definitions from tcsh etc.
+VENDOR=
+
+#########################################################################
+#
+# U-boot build supports producing a object files to the separate external
+# directory. Two use cases are supported:
+#
+# 1) Add O= to the make command line
+# 'make O=/tmp/build all'
+#
+# 2) Set environement variable BUILD_DIR to point to the desired location
+# 'export BUILD_DIR=/tmp/build'
+# 'make'
+#
+# The second approach can also be used with a MAKEALL script
+# 'export BUILD_DIR=/tmp/build'
+# './MAKEALL'
+#
+# Command line 'O=' setting overrides BUILD_DIR environent variable.
+#
+# When none of the above methods is used the local build is performed and
+# the object files are placed in the source directory.
+#
+
+ifdef O
+ifeq ("$(origin O)", "command line")
+BUILD_DIR := $(O)
+endif
+endif
+
+ifneq ($(BUILD_DIR),)
+saved-output := $(BUILD_DIR)
+
+# Attempt to create a output directory.
+$(shell [ -d ${BUILD_DIR} ] || mkdir -p ${BUILD_DIR})
+
+# Verify if it was successful.
+BUILD_DIR := $(shell cd $(BUILD_DIR) && /bin/pwd)
+$(if $(BUILD_DIR),,$(error output directory "$(saved-output)" does not exist))
+endif # ifneq ($(BUILD_DIR),)
+
+OBJTREE		:= $(if $(BUILD_DIR),$(BUILD_DIR),$(CURDIR))
+SRCTREE		:= $(CURDIR)
+TOPDIR		:= $(SRCTREE)
+LNDIR		:= $(OBJTREE)
+export	TOPDIR SRCTREE OBJTREE
+
+MKCONFIG	:= $(SRCTREE)/mkconfig
+export MKCONFIG
+
+ifneq ($(OBJTREE),$(SRCTREE))
+REMOTE_BUILD	:= 1
+export REMOTE_BUILD
+endif
+
+# $(obj) and (src) are defined in config.mk but here in main Makefile
+# we also need them before config.mk is included which is the case for
+# some targets like unconfig, clean, clobber, distclean, etc.
+ifneq ($(OBJTREE),$(SRCTREE))
+obj := $(OBJTREE)/
+src := $(SRCTREE)/
+else
+obj :=
+src :=
+endif
+export obj src
+
+#########################################################################
+
+ifeq ($(OBJTREE)/include/config.mk,$(wildcard $(OBJTREE)/include/config.mk))
+
+# load ARCH, BOARD, and CPU configuration
+include $(OBJTREE)/include/config.mk
+export	ARCH CPU BOARD VENDOR SOC
+
+ifndef CROSS_COMPILE
+ifeq ($(HOSTARCH),$(ARCH))
+CROSS_COMPILE =
+else
+ifeq ($(ARCH),ppc)
+CROSS_COMPILE = ppc_8xx-
+endif
+ifeq ($(ARCH),arm)
+CROSS_COMPILE = arm-linux-
+endif
+ifeq ($(ARCH),i386)
+CROSS_COMPILE = i386-linux-
+endif
+ifeq ($(ARCH),mips)
+CROSS_COMPILE = mips_4KC-
+endif
+ifeq ($(ARCH),nios)
+CROSS_COMPILE = nios-elf-
+endif
+ifeq ($(ARCH),nios2)
+CROSS_COMPILE = nios2-elf-
+endif
+ifeq ($(ARCH),m68k)
+CROSS_COMPILE = m68k-elf-
+endif
+ifeq ($(ARCH),microblaze)
+CROSS_COMPILE = mb-
+endif
+ifeq ($(ARCH),blackfin)
+CROSS_COMPILE = bfin-uclinux-
+endif
+ifeq ($(ARCH),avr32)
+CROSS_COMPILE = avr32-linux-
+endif
+ifeq ($(ARCH),sh)
+CROSS_COMPILE = sh4-linux-
+endif
+ifeq ($(ARCH),st200)
+CROSS_COMPILE = st231-linux-
+endif
+endif
+endif
+
+export	CROSS_COMPILE
+
+# load other configuration
+include $(TOPDIR)/config.mk
+
+#########################################################################
+# U-Boot objects....order is important (i.e. start must be first)
+
+OBJS  = cpu/$(CPU)/start.o
+ifeq ($(CPU),i386)
+OBJS += cpu/$(CPU)/start16.o
+OBJS += cpu/$(CPU)/reset.o
+endif
+ifeq ($(CPU),ppc4xx)
+OBJS += cpu/$(CPU)/resetvec.o
+endif
+ifeq ($(CPU),mpc85xx)
+OBJS += cpu/$(CPU)/resetvec.o
+endif
+ifeq ($(CPU),bf533)
+OBJS += cpu/$(CPU)/start1.o	cpu/$(CPU)/interrupt.o	cpu/$(CPU)/cache.o
+OBJS += cpu/$(CPU)/flush.o	cpu/$(CPU)/init_sdram.o
+endif
+ifeq ($(CPU),bf537)
+OBJS += cpu/$(CPU)/start1.o	cpu/$(CPU)/interrupt.o	cpu/$(CPU)/cache.o
+OBJS += cpu/$(CPU)/flush.o	cpu/$(CPU)/init_sdram.o
+endif
+ifeq ($(CPU),bf561)
+OBJS += cpu/$(CPU)/start1.o	cpu/$(CPU)/interrupt.o	cpu/$(CPU)/cache.o
+OBJS += cpu/$(CPU)/flush.o 	cpu/$(CPU)/init_sdram.o
+endif
+
+OBJS := $(addprefix $(obj),$(OBJS))
+
+LIBS  = lib_generic/libgeneric.a
+LIBS += $(shell if [ -f board/$(VENDOR)/common/Makefile ]; then echo \
+	"board/$(VENDOR)/common/lib$(VENDOR).a"; fi)
+LIBS += board/$(BOARDDIR)/lib$(BOARD).a
+LIBS += cpu/$(CPU)/lib$(CPU).a
+ifdef SOC
+LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a
+endif
+ifeq ($(CPU),ixp)
+LIBS += cpu/ixp/npe/libnpe.a
+endif
+LIBS += lib_$(ARCH)/lib$(ARCH).a
+LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
+	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a
+LIBS += net/libnet.a
+LIBS += disk/libdisk.a
+LIBS += drivers/bios_emulator/libatibiosemu.a
+LIBS += drivers/block/libblock.a
+LIBS += drivers/hwmon/libhwmon.a
+LIBS += drivers/i2c/libi2c.a
+LIBS += drivers/input/libinput.a
+LIBS += drivers/misc/libmisc.a
+LIBS += drivers/mtd/libmtd.a
+LIBS += drivers/mtd/nand/libnand.a
+LIBS += drivers/mtd/nand_legacy/libnand_legacy.a
+LIBS += drivers/mtd/onenand/libonenand.a
+LIBS += drivers/net/libnet.a
+LIBS += drivers/net/sk98lin/libsk98lin.a
+LIBS += drivers/pci/libpci.a
+LIBS += drivers/pcmcia/libpcmcia.a
+ifeq ($(CPU),mpc83xx)
+LIBS += drivers/qe/qe.a
+endif
+ifeq ($(CPU),mpc85xx)
+LIBS += drivers/qe/qe.a
+endif
+LIBS += drivers/rtc/librtc.a
+LIBS += drivers/serial/libserial.a
+LIBS += drivers/usb/libusb.a
+LIBS += drivers/video/libvideo.a
+LIBS += post/libpost.a post/drivers/libpostdrivers.a
+LIBS += $(shell if [ -d post/lib_$(ARCH) ]; then echo \
+	"post/lib_$(ARCH)/libpost$(ARCH).a"; fi)
+LIBS += $(shell if [ -d post/lib_$(ARCH)/fpu ]; then echo \
+	"post/lib_$(ARCH)/fpu/libpost$(ARCH)fpu.a"; fi)
+LIBS += $(shell if [ -d post/cpu/$(CPU) ]; then echo \
+	"post/cpu/$(CPU)/libpost$(CPU).a"; fi)
+LIBS += $(shell if [ -d post/board/$(BOARDDIR) ]; then echo \
+	"post/board/$(BOARDDIR)/libpost$(BOARD).a"; fi)
+LIBS += common/libcommon.a
+LIBS += libfdt/libfdt.a
+
+LIBS := $(addprefix $(obj),$(LIBS))
+.PHONY : $(LIBS)
+
+# Add GCC lib
+PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+
+# The "tools" are needed early, so put this first
+# Don't include stuff already done in $(LIBS)
+SUBDIRS	= tools \
+	  examples
+
+.PHONY : $(SUBDIRS)
+
+ifeq ($(CONFIG_NAND_U_BOOT),y)
+NAND_SPL = nand_spl
+U_BOOT_NAND = $(obj)u-boot-nand.bin
+endif
+
+__OBJS := $(subst $(obj),,$(OBJS))
+__LIBS := $(subst $(obj),,$(LIBS))
+
+#########################################################################
+#########################################################################
+
+ALL += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)
+
+all:		$(ALL)
+
+$(obj)u-boot.hex:	$(obj)u-boot
+		$(OBJCOPY) ${OBJCFLAGS} -O ihex $< $@
+
+$(obj)u-boot.srec:	$(obj)u-boot
+		$(OBJCOPY) ${OBJCFLAGS} -O srec $< $@
+
+$(obj)u-boot.bin:	$(obj)u-boot
+		$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(obj)u-boot.img:	$(obj)u-boot.bin
+		./tools/mkimage -A $(ARCH) -T firmware -C none \
+		-a $(TEXT_BASE) -e 0 \
+		-n $(shell sed -n -e 's/.*U_BOOT_VERSION//p' $(VERSION_FILE) | \
+			sed -e 's/"[	 ]*$$/ for $(BOARD) board"/') \
+		-d $< $@
+
+$(obj)u-boot.sha1:	$(obj)u-boot.bin
+		$(obj)tools/ubsha1 $(obj)u-boot.bin
+
+$(obj)u-boot.dis:	$(obj)u-boot
+		$(OBJDUMP) -d $< > $@
+
+$(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)
+		UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e 's/.*\(__u_boot_cmd_.*\)/-u\1/p'|sort|uniq`;\
+		cd $(LNDIR) && $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \
+			--start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \
+			-Map u-boot.map -o u-boot
+
+$(OBJS):
+		$(MAKE) -C cpu/$(CPU) $(if $(REMOTE_BUILD),$@,$(notdir $@))
+
+$(LIBS):
+		$(MAKE) -C $(dir $(subst $(obj),,$@))
+
+$(SUBDIRS):
+		$(MAKE) -C $@ all
+
+$(NAND_SPL):	version
+		$(MAKE) -C nand_spl/board/$(BOARDDIR) all
+
+$(U_BOOT_NAND):	$(NAND_SPL) $(obj)u-boot.bin
+		cat $(obj)nand_spl/u-boot-spl-16k.bin $(obj)u-boot.bin > $(obj)u-boot-nand.bin
+
+version:
+		@echo -n "#define U_BOOT_VERSION \"U-Boot " > $(VERSION_FILE); \
+		echo -n "$(U_BOOT_VERSION)" >> $(VERSION_FILE); \
+		echo -n $(shell $(CONFIG_SHELL) $(TOPDIR)/tools/setlocalversion \
+			 $(TOPDIR)) >> $(VERSION_FILE); \
+		echo "\"" >> $(VERSION_FILE)
+
+gdbtools:
+		$(MAKE) -C tools/gdb all || exit 1
+
+updater:
+		$(MAKE) -C tools/updater all || exit 1
+
+env:
+		$(MAKE) -C tools/env all || exit 1
+
+depend dep:	version
+		for dir in $(SUBDIRS) ; do $(MAKE) -C $$dir _depend ; done
+
+TAG_SUBDIRS += include
+TAG_SUBDIRS += lib_generic board/$(BOARDDIR)
+TAG_SUBDIRS += cpu/$(CPU)
+TAG_SUBDIRS += lib_$(ARCH)
+TAG_SUBDIRS += fs/cramfs
+TAG_SUBDIRS += fs/fat
+TAG_SUBDIRS += fs/fdos
+TAG_SUBDIRS += fs/jffs2
+TAG_SUBDIRS += net
+TAG_SUBDIRS += disk
+TAG_SUBDIRS += common
+TAG_SUBDIRS += drivers/bios_emulator
+TAG_SUBDIRS += drivers/block
+TAG_SUBDIRS += drivers/hwmon
+TAG_SUBDIRS += drivers/i2c
+TAG_SUBDIRS += drivers/input
+TAG_SUBDIRS += drivers/misc
+TAG_SUBDIRS += drivers/mtd
+TAG_SUBDIRS += drivers/mtd/nand
+TAG_SUBDIRS += drivers/mtd/nand_legacy
+TAG_SUBDIRS += drivers/mtd/onenand
+TAG_SUBDIRS += drivers/net
+TAG_SUBDIRS += drivers/net/sk98lin
+TAG_SUBDIRS += drivers/pci
+TAG_SUBDIRS += drivers/pcmcia
+TAG_SUBDIRS += drivers/qe
+TAG_SUBDIRS += drivers/rtc
+TAG_SUBDIRS += drivers/serial
+TAG_SUBDIRS += drivers/usb
+TAG_SUBDIRS += drivers/video
+
+tags ctags:
+		ctags -w -o $(OBJTREE)/ctags `find $(SUBDIRS) $(TAG_SUBDIRS) \
+						-name '*.[ch]' -print`
+
+etags:
+		etags -a -o $(OBJTREE)/etags `find $(SUBDIRS) $(TAG_SUBDIRS) \
+						-name '*.[ch]' -print`
+
+$(obj)System.map:	$(obj)u-boot
+		@$(NM) $< | \
+		grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | \
+		sort > $(obj)System.map
+
+#
+# Auto-generate the autoconf.mk file (which is included by all makefiles)
+#
+# This target actually generates 2 files; autoconf.mk and autoconf.mk.dep.
+# the dep file is only include in this top level makefile to determine when
+# to regenerate the autoconf.mk file.
+$(OBJTREE)/include/autoconf.mk: $(obj)include/config.h
+	@echo Generating include/autoconf.mk
+	@# Generate the dependancies
+	@$(CC) -M $(HOST_CFLAGS) $(CPPFLAGS) -MQ $@ include/common.h > $@.dep
+	@# Extract the config macros
+	@$(CPP) $(CFLAGS) -dM include/common.h | sed -n -f tools/scripts/define2mk.sed >> $@
+
+sinclude $(OBJTREE)/include/autoconf.mk.dep
+
+#########################################################################
+else
+all $(obj)u-boot.hex $(obj)u-boot.srec $(obj)u-boot.bin \
+$(obj)u-boot.img $(obj)u-boot.dis $(obj)u-boot \
+$(SUBDIRS) version gdbtools updater env depend \
+dep tags ctags etags $(obj)System.map:
+	@echo "System not configured - see README" >&2
+	@ exit 1
+endif
+
+.PHONY : CHANGELOG
+CHANGELOG:
+	git log --no-merges U-Boot-1_1_5.. | \
+	unexpand -a | sed -e 's/\s\s*$$//' > $@
+
+#########################################################################
+
+unconfig:
+	@rm -f $(obj)include/config.h $(obj)include/config.mk \
+		$(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \
+		$(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep
+
+#========================================================================
+# PowerPC
+#========================================================================
+
+#########################################################################
+## MPC5xx Systems
+#########################################################################
+
+canmb_config:	unconfig
+	@$(MKCONFIG) -a canmb ppc mpc5xxx canmb
+
+cmi_mpc5xx_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc5xx cmi
+
+PATI_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc5xx pati mpl
+
+#########################################################################
+## MPC5xxx Systems
+#########################################################################
+
+aev_config: unconfig
+	@$(MKCONFIG) -a aev ppc mpc5xxx tqm5200
+
+BC3450_config:	unconfig
+	@$(MKCONFIG) -a BC3450 ppc mpc5xxx bc3450
+
+cpci5200_config:  unconfig
+	@$(MKCONFIG) -a cpci5200  ppc mpc5xxx cpci5200 esd
+
+hmi1001_config:	unconfig
+	@$(MKCONFIG) hmi1001 ppc mpc5xxx hmi1001
+
+Lite5200_config				\
+Lite5200_LOWBOOT_config			\
+Lite5200_LOWBOOT08_config		\
+icecube_5200_config			\
+icecube_5200_LOWBOOT_config		\
+icecube_5200_LOWBOOT08_config		\
+icecube_5200_DDR_config			\
+icecube_5200_DDR_LOWBOOT_config		\
+icecube_5200_DDR_LOWBOOT08_config	\
+icecube_5100_config:			unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/icecube
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring LOWBOOT_,$@)" ] || \
+		{ if [ "$(findstring DDR,$@)" ] ; \
+			then echo "TEXT_BASE = 0xFF800000" >$(obj)board/icecube/config.tmp ; \
+			else echo "TEXT_BASE = 0xFF000000" >$(obj)board/icecube/config.tmp ; \
+		  fi ; \
+		  echo "... with LOWBOOT configuration" ; \
+		}
+	@[ -z "$(findstring LOWBOOT08,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFF800000" >$(obj)board/icecube/config.tmp ; \
+		  echo "... with 8 MB flash only" ; \
+		  echo "... with LOWBOOT configuration" ; \
+		}
+	@[ -z "$(findstring DDR,$@)" ] || \
+		{ echo "#define CONFIG_MPC5200_DDR"	>>$(obj)include/config.h ; \
+		  echo "... DDR memory revision" ; \
+		}
+	@[ -z "$(findstring 5200,$@)" ] || \
+		{ echo "#define CONFIG_MPC5200"		>>$(obj)include/config.h ; \
+		  echo "... with MPC5200 processor" ; \
+		}
+	@[ -z "$(findstring 5100,$@)" ] || \
+		{ echo "#define CONFIG_MGT5100"		>>$(obj)include/config.h ; \
+		  echo "... with MGT5100 processor" ; \
+		}
+	@$(MKCONFIG) -a IceCube ppc mpc5xxx icecube
+
+jupiter_config:	unconfig
+	@$(MKCONFIG) jupiter ppc mpc5xxx jupiter
+
+v38b_config: unconfig
+	@$(MKCONFIG) -a v38b ppc mpc5xxx v38b
+
+inka4x0_config:	unconfig
+	@$(MKCONFIG) inka4x0 ppc mpc5xxx inka4x0
+
+lite5200b_config	\
+lite5200b_PM_config	\
+lite5200b_LOWBOOT_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/icecube
+	@ >$(obj)include/config.h
+	@ echo "#define CONFIG_MPC5200_DDR"	>>$(obj)include/config.h
+	@ echo "... DDR memory revision"
+	@ echo "#define CONFIG_MPC5200"		>>$(obj)include/config.h
+	@ echo "#define CONFIG_LITE5200B"	>>$(obj)include/config.h
+	@[ -z "$(findstring _PM_,$@)" ] || \
+		{ echo "#define CONFIG_LITE5200B_PM"	>>$(obj)include/config.h ; \
+		  echo "... with power management (low-power mode) support" ; \
+		}
+	@[ -z "$(findstring LOWBOOT_,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFF000000" >$(obj)board/icecube/config.tmp ; \
+		  echo "... with LOWBOOT configuration" ; \
+		}
+	@ echo "... with MPC5200B processor"
+	@$(MKCONFIG) -a IceCube  ppc mpc5xxx icecube
+
+mcc200_config	\
+mcc200_SDRAM_config	\
+mcc200_highboot_config	\
+mcc200_COM12_config	\
+mcc200_COM12_SDRAM_config	\
+mcc200_COM12_highboot_config	\
+mcc200_COM12_highboot_SDRAM_config	\
+mcc200_highboot_SDRAM_config	\
+prs200_config	\
+prs200_DDR_config	\
+prs200_highboot_config	\
+prs200_highboot_DDR_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/mcc200
+	@ >$(obj)include/config.h
+	@[ -n "$(findstring highboot,$@)" ] || \
+		{ echo "... with lowboot configuration" ; \
+		}
+	@[ -z "$(findstring highboot,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFFF00000" >$(obj)board/mcc200/config.tmp ; \
+		  echo "... with highboot configuration" ; \
+		}
+	@[ -n "$(findstring _SDRAM,$@)" ] || \
+		{ if [ -n "$(findstring mcc200,$@)" ]; \
+		  then \
+			echo "... with DDR" ; \
+		  else \
+			if [ -n "$(findstring _DDR,$@)" ];\
+			then \
+				echo "... with DDR" ; \
+			else \
+				echo "#define CONFIG_MCC200_SDRAM" >>$(obj)include/config.h ;\
+				echo "... with SDRAM" ; \
+			fi; \
+		  fi; \
+		}
+	@[ -z "$(findstring _SDRAM,$@)" ] || \
+		{ echo "#define CONFIG_MCC200_SDRAM"	>>$(obj)include/config.h ; \
+		  echo "... with SDRAM" ; \
+		}
+	@[ -z "$(findstring COM12,$@)" ] || \
+		{ echo "#define CONFIG_CONSOLE_COM12"	>>$(obj)include/config.h ; \
+		  echo "... with console on COM12" ; \
+		}
+	@[ -z "$(findstring prs200,$@)" ] || \
+		{ echo "#define CONFIG_PRS200"  >>$(obj)include/config.h ;\
+		}
+	@$(MKCONFIG) -n $@ -a mcc200 ppc mpc5xxx mcc200
+
+mecp5200_config:  unconfig
+	@$(MKCONFIG) -a mecp5200  ppc mpc5xxx mecp5200 esd
+
+o2dnt_config:
+	@$(MKCONFIG) o2dnt ppc mpc5xxx o2dnt
+
+pf5200_config:  unconfig
+	@$(MKCONFIG) pf5200  ppc mpc5xxx pf5200 esd
+
+PM520_config \
+PM520_DDR_config \
+PM520_ROMBOOT_config \
+PM520_ROMBOOT_DDR_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring DDR,$@)" ] || \
+		{ echo "#define CONFIG_MPC5200_DDR"	>>$(obj)include/config.h ; \
+		  echo "... DDR memory revision" ; \
+		}
+	@[ -z "$(findstring ROMBOOT,$@)" ] || \
+		{ echo "#define CONFIG_BOOT_ROM" >>$(obj)include/config.h ; \
+		  echo "... booting from 8-bit flash" ; \
+		}
+	@$(MKCONFIG) -a PM520 ppc mpc5xxx pm520
+
+smmaco4_config: unconfig
+	@$(MKCONFIG) -a smmaco4 ppc mpc5xxx tqm5200
+
+cm5200_config:	unconfig
+	@./mkconfig -a cm5200 ppc mpc5xxx cm5200
+
+spieval_config:	unconfig
+	@$(MKCONFIG) -a spieval ppc mpc5xxx tqm5200
+
+TB5200_B_config \
+TB5200_config:	unconfig
+	@mkdir -p $(obj)include
+	@[ -z "$(findstring _B,$@)" ] || \
+		{ echo "#define CONFIG_TQM5200_B"	>>$(obj)include/config.h ; \
+		  echo "... with MPC5200B processor" ; \
+		}
+	@$(MKCONFIG) -n $@ -a TB5200 ppc mpc5xxx tqm5200
+
+MINI5200_config	\
+EVAL5200_config	\
+TOP5200_config:	unconfig
+	@mkdir -p $(obj)include
+	@ echo "#define CONFIG_$(@:_config=) 1"	>$(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a TOP5200 ppc mpc5xxx top5200 emk
+
+Total5100_config		\
+Total5200_config		\
+Total5200_lowboot_config	\
+Total5200_Rev2_config		\
+Total5200_Rev2_lowboot_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/total5200
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring 5100,$@)" ] || \
+		{ echo "#define CONFIG_MGT5100"		>>$(obj)include/config.h ; \
+		  echo "... with MGT5100 processor" ; \
+		}
+	@[ -z "$(findstring 5200,$@)" ] || \
+		{ echo "#define CONFIG_MPC5200"		>>$(obj)include/config.h ; \
+		  echo "... with MPC5200 processor" ; \
+		}
+	@[ -n "$(findstring Rev,$@)" ] || \
+		{ echo "#define CONFIG_TOTAL5200_REV 1"	>>$(obj)include/config.h ; \
+		  echo "... revision 1 board" ; \
+		}
+	@[ -z "$(findstring Rev2_,$@)" ] || \
+		{ echo "#define CONFIG_TOTAL5200_REV 2"	>>$(obj)include/config.h ; \
+		  echo "... revision 2 board" ; \
+		}
+	@[ -z "$(findstring lowboot_,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFE000000" >$(obj)board/total5200/config.tmp ; \
+		  echo "... with lowboot configuration" ; \
+		}
+	@$(MKCONFIG) -a Total5200 ppc mpc5xxx total5200
+
+cam5200_config \
+cam5200_niosflash_config \
+fo300_config \
+MiniFAP_config \
+TQM5200S_config \
+TQM5200S_HIGHBOOT_config \
+TQM5200_B_config \
+TQM5200_B_HIGHBOOT_config \
+TQM5200_config	\
+TQM5200_STK100_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/tqm5200
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring cam5200,$@)" ] || \
+		{ echo "#define CONFIG_CAM5200"	>>$(obj)include/config.h ; \
+		  echo "#define CONFIG_TQM5200S"	>>$(obj)include/config.h ; \
+		  echo "#define CONFIG_TQM5200_B"	>>$(obj)include/config.h ; \
+		  echo "... TQM5200S on Cam5200" ; \
+		}
+	@[ -z "$(findstring niosflash,$@)" ] || \
+		{ echo "#define CONFIG_CAM5200_NIOSFLASH"	>>$(obj)include/config.h ; \
+		  echo "... with NIOS flash driver" ; \
+		}
+	@[ -z "$(findstring fo300,$@)" ] || \
+		{ echo "#define CONFIG_FO300"	>>$(obj)include/config.h ; \
+		  echo "... TQM5200 on FO300" ; \
+		}
+	@[ -z "$(findstring MiniFAP,$@)" ] || \
+		{ echo "#define CONFIG_MINIFAP"	>>$(obj)include/config.h ; \
+		  echo "... TQM5200_AC on MiniFAP" ; \
+		}
+	@[ -z "$(findstring STK100,$@)" ] || \
+		{ echo "#define CONFIG_STK52XX_REV100"	>>$(obj)include/config.h ; \
+		  echo "... on a STK52XX.100 base board" ; \
+		}
+	@[ -z "$(findstring TQM5200_B,$@)" ] || \
+		{ echo "#define CONFIG_TQM5200_B"	>>$(obj)include/config.h ; \
+		}
+	@[ -z "$(findstring TQM5200S,$@)" ] || \
+		{ echo "#define CONFIG_TQM5200S"	>>$(obj)include/config.h ; \
+		  echo "#define CONFIG_TQM5200_B"	>>$(obj)include/config.h ; \
+		}
+	@[ -z "$(findstring HIGHBOOT,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFFF00000" >$(obj)board/tqm5200/config.tmp ; \
+		}
+	@$(MKCONFIG) -n $@ -a TQM5200 ppc mpc5xxx tqm5200
+uc101_config:		unconfig
+	@$(MKCONFIG) uc101 ppc mpc5xxx uc101
+motionpro_config:	unconfig
+	@$(MKCONFIG) motionpro ppc mpc5xxx motionpro
+
+
+#########################################################################
+## MPC512x Systems
+#########################################################################
+ads5121_config: unconfig
+	@$(MKCONFIG) ads5121 ppc mpc512x ads5121
+
+
+#########################################################################
+## MPC8xx Systems
+#########################################################################
+
+Adder_config    \
+Adder87x_config \
+AdderII_config  \
+	:		unconfig
+	@mkdir -p $(obj)include
+	$(if $(findstring AdderII,$@), \
+	@echo "#define CONFIG_MPC852T" > $(obj)include/config.h)
+	@$(MKCONFIG) -a Adder ppc mpc8xx adder
+
+AdderUSB_config:	unconfig
+	@./mkconfig -a AdderUSB ppc mpc8xx adder
+
+ADS860_config     \
+FADS823_config    \
+FADS850SAR_config \
+MPC86xADS_config  \
+MPC885ADS_config  \
+FADS860T_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx fads
+
+AMX860_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx amx860 westel
+
+c2mon_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx c2mon
+
+CCM_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx CCM siemens
+
+cogent_mpc8xx_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx cogent
+
+ELPT860_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx elpt860 LEOX
+
+EP88x_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx ep88x
+
+ESTEEM192E_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx esteem192e
+
+ETX094_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx etx094
+
+FLAGADM_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx flagadm
+
+xtract_GEN860T = $(subst _SC,,$(subst _config,,$1))
+
+GEN860T_SC_config	\
+GEN860T_config: unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _SC,$@)" ] || \
+		{ echo "#define CONFIG_SC" >>$(obj)include/config.h ; \
+		  echo "With reduced H/W feature set (SC)..." ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_GEN860T,$@) ppc mpc8xx gen860t
+
+GENIETV_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx genietv
+
+GTH_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx gth
+
+hermes_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx hermes
+
+HMI10_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx tqm8xx
+
+IAD210_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx IAD210 siemens
+
+xtract_ICU862 = $(subst _100MHz,,$(subst _config,,$1))
+
+ICU862_100MHz_config	\
+ICU862_config: unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _100MHz,$@)" ] || \
+		{ echo "#define CONFIG_100MHz"	>>$(obj)include/config.h ; \
+		  echo "... with 100MHz system clock" ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_ICU862,$@) ppc mpc8xx icu862
+
+IP860_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx ip860
+
+IVML24_256_config \
+IVML24_128_config \
+IVML24_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring IVML24_config,$@)" ] || \
+		 { echo "#define CONFIG_IVML24_16M"	>>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring IVML24_128_config,$@)" ] || \
+		 { echo "#define CONFIG_IVML24_32M"	>>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring IVML24_256_config,$@)" ] || \
+		 { echo "#define CONFIG_IVML24_64M"	>>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a IVML24 ppc mpc8xx ivm
+
+IVMS8_256_config \
+IVMS8_128_config \
+IVMS8_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring IVMS8_config,$@)" ] || \
+		 { echo "#define CONFIG_IVMS8_16M"	>>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring IVMS8_128_config,$@)" ] || \
+		 { echo "#define CONFIG_IVMS8_32M"	>>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring IVMS8_256_config,$@)" ] || \
+		 { echo "#define CONFIG_IVMS8_64M"	>>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a IVMS8 ppc mpc8xx ivm
+
+KUP4K_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx kup4k kup
+
+KUP4X_config    :       unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx kup4x kup
+
+LANTEC_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx lantec
+
+lwmon_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx lwmon
+
+MBX_config	\
+MBX860T_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx mbx8xx
+
+MHPC_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx mhpc eltec
+
+MVS1_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx mvs1
+
+xtract_NETVIA = $(subst _V2,,$(subst _config,,$1))
+
+NETVIA_V2_config \
+NETVIA_config:		unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring NETVIA_config,$@)" ] || \
+		 { echo "#define CONFIG_NETVIA_VERSION 1" >>$(obj)include/config.h ; \
+		  echo "... Version 1" ; \
+		 }
+	@[ -z "$(findstring NETVIA_V2_config,$@)" ] || \
+		 { echo "#define CONFIG_NETVIA_VERSION 2" >>$(obj)include/config.h ; \
+		  echo "... Version 2" ; \
+		 }
+	@$(MKCONFIG) -a $(call xtract_NETVIA,$@) ppc mpc8xx netvia
+
+xtract_NETPHONE = $(subst _V2,,$(subst _config,,$1))
+
+NETPHONE_V2_config \
+NETPHONE_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring NETPHONE_config,$@)" ] || \
+		 { echo "#define CONFIG_NETPHONE_VERSION 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring NETPHONE_V2_config,$@)" ] || \
+		 { echo "#define CONFIG_NETPHONE_VERSION 2" >>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a $(call xtract_NETPHONE,$@) ppc mpc8xx netphone
+
+xtract_NETTA = $(subst _SWAPHOOK,,$(subst _6412,,$(subst _ISDN,,$(subst _config,,$1))))
+
+NETTA_ISDN_6412_SWAPHOOK_config \
+NETTA_ISDN_SWAPHOOK_config \
+NETTA_6412_SWAPHOOK_config \
+NETTA_SWAPHOOK_config \
+NETTA_ISDN_6412_config \
+NETTA_ISDN_config \
+NETTA_6412_config \
+NETTA_config:		unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring ISDN_,$@)" ] || \
+		 { echo "#define CONFIG_NETTA_ISDN 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -n "$(findstring ISDN_,$@)" ] || \
+		 { echo "#undef CONFIG_NETTA_ISDN" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring 6412_,$@)" ] || \
+		 { echo "#define CONFIG_NETTA_6412 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -n "$(findstring 6412_,$@)" ] || \
+		 { echo "#undef CONFIG_NETTA_6412" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring SWAPHOOK_,$@)" ] || \
+		 { echo "#define CONFIG_NETTA_SWAPHOOK 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -n "$(findstring SWAPHOOK_,$@)" ] || \
+		 { echo "#undef CONFIG_NETTA_SWAPHOOK" >>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a $(call xtract_NETTA,$@) ppc mpc8xx netta
+
+xtract_NETTA2 = $(subst _V2,,$(subst _config,,$1))
+
+NETTA2_V2_config \
+NETTA2_config:		unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring NETTA2_config,$@)" ] || \
+		 { echo "#define CONFIG_NETTA2_VERSION 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring NETTA2_V2_config,$@)" ] || \
+		 { echo "#define CONFIG_NETTA2_VERSION 2" >>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a $(call xtract_NETTA2,$@) ppc mpc8xx netta2
+
+NC650_Rev1_config \
+NC650_Rev2_config \
+CP850_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring CP850,$@)" ] || \
+		 { echo "#define CONFIG_CP850 1" >>$(obj)include/config.h ; \
+		   echo "#define CONFIG_IDS852_REV2 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring Rev1,$@)" ] || \
+		 { echo "#define CONFIG_IDS852_REV1 1" >>$(obj)include/config.h ; \
+		 }
+	@[ -z "$(findstring Rev2,$@)" ] || \
+		 { echo "#define CONFIG_IDS852_REV2 1" >>$(obj)include/config.h ; \
+		 }
+	@$(MKCONFIG) -a NC650 ppc mpc8xx nc650
+
+NX823_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx nx823
+
+pcu_e_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx pcu_e siemens
+
+QS850_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx qs850 snmc
+
+QS823_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx qs850 snmc
+
+QS860T_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx qs860t snmc
+
+quantum_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx quantum
+
+R360MPI_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx r360mpi
+
+RBC823_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx rbc823
+
+RPXClassic_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx RPXClassic
+
+RPXlite_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx RPXlite
+
+RPXlite_DW_64_config		\
+RPXlite_DW_LCD_config		\
+RPXlite_DW_64_LCD_config	\
+RPXlite_DW_NVRAM_config		\
+RPXlite_DW_NVRAM_64_config      \
+RPXlite_DW_NVRAM_LCD_config	\
+RPXlite_DW_NVRAM_64_LCD_config  \
+RPXlite_DW_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _64,$@)" ] || \
+		{ echo "#define RPXlite_64MHz"		>>$(obj)include/config.h ; \
+		  echo "... with 64MHz system clock ..."; \
+		}
+	@[ -z "$(findstring _LCD,$@)" ] || \
+		{ echo "#define CONFIG_LCD"		>>$(obj)include/config.h ; \
+		  echo "#define CONFIG_NEC_NL6448BC20"	>>$(obj)include/config.h ; \
+		  echo "... with LCD display ..."; \
+		}
+	@[ -z "$(findstring _NVRAM,$@)" ] || \
+		{ echo "#define  CFG_ENV_IS_IN_NVRAM"	>>$(obj)include/config.h ; \
+		  echo "... with ENV in NVRAM ..."; \
+		}
+	@$(MKCONFIG) -a RPXlite_DW ppc mpc8xx RPXlite_dw
+
+rmu_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx rmu
+
+RRvision_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx RRvision
+
+RRvision_LCD_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_LCD" >$(obj)include/config.h
+	@echo "#define CONFIG_SHARP_LQ104V7DS01" >>$(obj)include/config.h
+	@$(MKCONFIG) -a RRvision ppc mpc8xx RRvision
+
+SM850_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx tqm8xx
+
+spc1920_config:
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx spc1920
+
+SPD823TS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx spd8xx
+
+stxxtc_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx stxxtc
+
+svm_sc8xx_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx svm_sc8xx
+
+SXNI855T_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx sixnet
+
+# EMK MPC8xx based modules
+TOP860_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx top860 emk
+
+# Play some tricks for configuration selection
+# Only 855 and 860 boards may come with FEC
+# and only 823 boards may have LCD support
+xtract_8xx = $(subst _LCD,,$(subst _config,,$1))
+
+FPS850L_config		\
+FPS860L_config		\
+NSCU_config		\
+TQM823L_config		\
+TQM823L_LCD_config	\
+TQM850L_config		\
+TQM855L_config		\
+TQM860L_config		\
+TQM862L_config		\
+TQM823M_config		\
+TQM850M_config		\
+TQM855M_config		\
+TQM860M_config		\
+TQM862M_config		\
+TQM866M_config		\
+TQM885D_config		\
+virtlab2_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _LCD,$@)" ] || \
+		{ echo "#define CONFIG_LCD"		>>$(obj)include/config.h ; \
+		  echo "#define CONFIG_NEC_NL6448BC20"	>>$(obj)include/config.h ; \
+		  echo "... with LCD display" ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_8xx,$@) ppc mpc8xx tqm8xx
+
+TTTech_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_LCD" >$(obj)include/config.h
+	@echo "#define CONFIG_SHARP_LQ104V7DS01" >>$(obj)include/config.h
+	@$(MKCONFIG) -a TQM823L ppc mpc8xx tqm8xx
+
+uc100_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx uc100
+
+v37_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_LCD" >$(obj)include/config.h
+	@echo "#define CONFIG_SHARP_LQ084V1DG21" >>$(obj)include/config.h
+	@$(MKCONFIG) $(@:_config=) ppc mpc8xx v37
+
+wtk_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_LCD" >$(obj)include/config.h
+	@echo "#define CONFIG_SHARP_LQ065T9DR51U" >>$(obj)include/config.h
+	@$(MKCONFIG) -a TQM823L ppc mpc8xx tqm8xx
+
+#########################################################################
+## PPC4xx Systems
+#########################################################################
+xtract_4xx = $(subst _25,,$(subst _33,,$(subst _BA,,$(subst _ME,,$(subst _HI,,$(subst _config,,$1))))))
+
+acadia_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx acadia amcc
+
+acadia_nand_config:	unconfig
+	@mkdir -p $(obj)include $(obj)board/amcc/acadia
+	@mkdir -p $(obj)nand_spl/board/amcc/acadia
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a acadia ppc ppc4xx acadia amcc
+	@echo "TEXT_BASE = 0x01000000" > $(obj)board/amcc/acadia/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+ADCIOP_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx adciop esd
+
+alpr_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx alpr prodrive
+
+AP1000_config:unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ap1000 amirix
+
+APC405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx apc405 esd
+
+AR405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ar405 esd
+
+ASH405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ash405 esd
+
+bamboo_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx bamboo amcc
+
+bamboo_nand_config:	unconfig
+	@mkdir -p $(obj)include $(obj)board/amcc/bamboo
+	@mkdir -p $(obj)nand_spl/board/amcc/bamboo
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a bamboo ppc ppc4xx bamboo amcc
+	@echo "TEXT_BASE = 0x01000000" > $(obj)board/amcc/bamboo/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+bubinga_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx bubinga amcc
+
+CANBT_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx canbt esd
+
+CATcenter_config	\
+CATcenter_25_config	\
+CATcenter_33_config:	unconfig
+	@mkdir -p $(obj)include
+	@ echo "/* CATcenter uses PPChameleon Model ME */"  > $(obj)include/config.h
+	@ echo "#define CONFIG_PPCHAMELEON_MODULE_MODEL 1" >> $(obj)include/config.h
+	@[ -z "$(findstring _25,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_CLK_25" >> $(obj)include/config.h ; \
+		  echo "SysClk = 25MHz" ; \
+		}
+	@[ -z "$(findstring _33,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_CLK_33" >> $(obj)include/config.h ; \
+		  echo "SysClk = 33MHz" ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_4xx,$@) ppc ppc4xx PPChameleonEVB dave
+
+CPCI2DP_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx cpci2dp esd
+
+CPCI405_config	\
+CPCI4052_config	\
+CPCI405DT_config	\
+CPCI405AB_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx cpci405 esd
+	@echo "BOARD_REVISION = $(@:_config=)"	>> $(obj)include/config.mk
+
+CPCI440_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx cpci440 esd
+
+CPCIISER4_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx cpciiser4 esd
+
+CRAYL1_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx L1 cray
+
+csb272_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx csb272
+
+csb472_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx csb472
+
+DASA_SIM_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx dasa_sim esd
+
+DP405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx dp405 esd
+
+DU405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx du405 esd
+
+ebony_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ebony amcc
+
+ERIC_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx eric
+
+EXBITGEN_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx exbitgen
+
+G2000_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx g2000
+
+hcu4_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx hcu4 netstal
+
+hcu5_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx hcu5 netstal
+
+HH405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx hh405 esd
+
+HUB405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx hub405 esd
+
+JSE_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx jse
+
+KAREF_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx karef sandburst
+
+katmai_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx katmai amcc
+
+luan_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx luan amcc
+
+lwmon5_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx lwmon5
+
+METROBOX_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx metrobox sandburst
+
+MIP405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx mip405 mpl
+
+MIP405T_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_MIP405T" >$(obj)include/config.h
+	@echo "Enable subset config for MIP405T"
+	@$(MKCONFIG) -a MIP405 ppc ppc4xx mip405 mpl
+
+ML2_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ml2
+
+ml300_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ml300 xilinx
+
+ocotea_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ocotea amcc
+
+OCRTC_config		\
+ORSG_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx ocrtc esd
+
+p3p440_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx p3p440 prodrive
+
+PCI405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx pci405 esd
+
+pcs440ep_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx pcs440ep
+
+PIP405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx pip405 mpl
+
+PLU405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx plu405 esd
+
+PMC405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx pmc405 esd
+
+PPChameleonEVB_config		\
+PPChameleonEVB_BA_25_config	\
+PPChameleonEVB_ME_25_config	\
+PPChameleonEVB_HI_25_config	\
+PPChameleonEVB_BA_33_config	\
+PPChameleonEVB_ME_33_config	\
+PPChameleonEVB_HI_33_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring EVB_BA,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_MODULE_MODEL 0" >>$(obj)include/config.h ; \
+		  echo "... BASIC model" ; \
+		}
+	@[ -z "$(findstring EVB_ME,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_MODULE_MODEL 1" >>$(obj)include/config.h ; \
+		  echo "... MEDIUM model" ; \
+		}
+	@[ -z "$(findstring EVB_HI,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_MODULE_MODEL 2" >>$(obj)include/config.h ; \
+		  echo "... HIGH-END model" ; \
+		}
+	@[ -z "$(findstring _25,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_CLK_25" >>$(obj)include/config.h ; \
+		  echo "SysClk = 25MHz" ; \
+		}
+	@[ -z "$(findstring _33,$@)" ] || \
+		{ echo "#define CONFIG_PPCHAMELEON_CLK_33" >>$(obj)include/config.h ; \
+		  echo "SysClk = 33MHz" ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_4xx,$@) ppc ppc4xx PPChameleonEVB dave
+
+sbc405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx sbc405
+
+sequoia_config \
+rainier_config: unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_$$(echo $(subst ,,$(@:_config=)) | \
+		tr '[:lower:]' '[:upper:]')" >$(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a sequoia ppc ppc4xx sequoia amcc
+
+sequoia_nand_config \
+rainier_nand_config: unconfig
+	@mkdir -p $(obj)include $(obj)board/amcc/sequoia
+	@mkdir -p $(obj)nand_spl/board/amcc/sequoia
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "#define CONFIG_$$(echo $(subst ,,$(@:_config=)) | \
+		tr '[:lower:]' '[:upper:]')" >> $(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a sequoia ppc ppc4xx sequoia amcc
+	@echo "TEXT_BASE = 0x01000000" > $(obj)board/amcc/sequoia/config.tmp
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+sc3_config:unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx sc3
+
+taihu_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx taihu amcc
+
+taishan_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx taishan amcc
+
+VOH405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx voh405 esd
+
+VOM405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx vom405 esd
+
+CMS700_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx cms700 esd
+
+W7OLMC_config	\
+W7OLMG_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx w7o
+
+# Walnut & Sycamore images are identical (recognized via PVR)
+walnut_config \
+sycamore_config: unconfig
+	@$(MKCONFIG) -n $@ -a walnut ppc ppc4xx walnut amcc
+
+WUH405_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx wuh405 esd
+
+XPEDITE1K_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx xpedite1k
+
+yosemite_config \
+yellowstone_config: unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_$$(echo $(subst ,,$(@:_config=)) | \
+		tr '[:lower:]' '[:upper:]')" >$(obj)include/config.h
+	@$(MKCONFIG) -n $@ -a yosemite ppc ppc4xx yosemite amcc
+
+yucca_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx yucca amcc
+
+zeus_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc ppc4xx zeus
+
+#########################################################################
+## MPC8220 Systems
+#########################################################################
+
+Alaska8220_config	\
+Yukon8220_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8220 alaska
+
+sorcery_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8220 sorcery
+
+#########################################################################
+## MPC824x Systems
+#########################################################################
+xtract_82xx = $(subst _BIGFLASH,,$(subst _ROMBOOT,,$(subst _L2,,$(subst _266MHz,,$(subst _300MHz,,$(subst _config,,$1))))))
+
+A3000_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x a3000
+
+barco_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x barco
+
+BMW_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x bmw
+
+CPC45_config	\
+CPC45_ROMBOOT_config:	unconfig
+	@$(MKCONFIG) $(call xtract_82xx,$@) ppc mpc824x cpc45
+	@cd $(obj)include ;				\
+	if [ "$(findstring _ROMBOOT_,$@)" ] ; then \
+		echo "CONFIG_BOOT_ROM = y" >> config.mk ; \
+		echo "... booting from 8-bit flash" ; \
+	else \
+		echo "CONFIG_BOOT_ROM = n" >> config.mk ; \
+		echo "... booting from 64-bit flash" ; \
+	fi; \
+	echo "export CONFIG_BOOT_ROM" >> config.mk;
+
+CU824_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x cu824
+
+debris_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x debris etin
+
+eXalion_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x eXalion
+
+HIDDEN_DRAGON_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x hidden_dragon
+
+kvme080_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x kvme080 etin
+
+MOUSSE_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x mousse
+
+MUSENKI_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x musenki
+
+MVBLUE_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x mvblue
+
+OXC_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x oxc
+
+PN62_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x pn62
+
+Sandpoint8240_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x sandpoint
+
+Sandpoint8245_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x sandpoint
+
+sbc8240_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x sbc8240
+
+SL8245_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x sl8245
+
+utx8245_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc824x utx8245
+
+#########################################################################
+## MPC8260 Systems
+#########################################################################
+
+atc_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 atc
+
+cogent_mpc8260_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 cogent
+
+CPU86_config	\
+CPU86_ROMBOOT_config: unconfig
+	@$(MKCONFIG) $(call xtract_82xx,$@) ppc mpc8260 cpu86
+	@cd $(obj)include ;				\
+	if [ "$(findstring _ROMBOOT_,$@)" ] ; then \
+		echo "CONFIG_BOOT_ROM = y" >> config.mk ; \
+		echo "... booting from 8-bit flash" ; \
+	else \
+		echo "CONFIG_BOOT_ROM = n" >> config.mk ; \
+		echo "... booting from 64-bit flash" ; \
+	fi; \
+	echo "export CONFIG_BOOT_ROM" >> config.mk;
+
+CPU87_config	\
+CPU87_ROMBOOT_config: unconfig
+	@$(MKCONFIG) $(call xtract_82xx,$@) ppc mpc8260 cpu87
+	@cd $(obj)include ;				\
+	if [ "$(findstring _ROMBOOT_,$@)" ] ; then \
+		echo "CONFIG_BOOT_ROM = y" >> config.mk ; \
+		echo "... booting from 8-bit flash" ; \
+	else \
+		echo "CONFIG_BOOT_ROM = n" >> config.mk ; \
+		echo "... booting from 64-bit flash" ; \
+	fi; \
+	echo "export CONFIG_BOOT_ROM" >> config.mk;
+
+ep8248_config	\
+ep8248E_config	:	unconfig
+	@$(MKCONFIG) ep8248 ppc mpc8260 ep8248
+
+ep8260_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 ep8260
+
+ep82xxm_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 ep82xxm
+
+gw8260_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 gw8260
+
+hymod_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 hymod
+
+IDS8247_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 ids8247
+
+IPHASE4539_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 iphase4539
+
+ISPAN_config		\
+ISPAN_REVB_config:	unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _REVB_,$@)" ] ; then \
+		echo "#define CFG_REV_B" > $(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a ISPAN ppc mpc8260 ispan
+
+MPC8260ADS_config	\
+MPC8260ADS_lowboot_config	\
+MPC8260ADS_33MHz_config	\
+MPC8260ADS_33MHz_lowboot_config	\
+MPC8260ADS_40MHz_config	\
+MPC8260ADS_40MHz_lowboot_config	\
+MPC8272ADS_config	\
+MPC8272ADS_lowboot_config	\
+PQ2FADS_config		\
+PQ2FADS_lowboot_config		\
+PQ2FADS-VR_config	\
+PQ2FADS-VR_lowboot_config	\
+PQ2FADS-ZU_config	\
+PQ2FADS-ZU_lowboot_config	\
+PQ2FADS-ZU_66MHz_config	\
+PQ2FADS-ZU_66MHz_lowboot_config	\
+	:		unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/mpc8260ads
+	$(if $(findstring PQ2FADS,$@), \
+	@echo "#define CONFIG_ADSTYPE CFG_PQ2FADS" > $(obj)include/config.h, \
+	@echo "#define CONFIG_ADSTYPE CFG_"$(subst MPC,,$(word 1,$(subst _, ,$@))) > $(obj)include/config.h)
+	$(if $(findstring MHz,$@), \
+	@echo "#define CONFIG_8260_CLKIN" $(subst MHz,,$(word 2,$(subst _, ,$@)))"000000" >> $(obj)include/config.h, \
+	$(if $(findstring VR,$@), \
+	@echo "#define CONFIG_8260_CLKIN 66000000" >> $(obj)include/config.h))
+	@[ -z "$(findstring lowboot_,$@)" ] || \
+		{ echo "TEXT_BASE = 0xFF800000" >$(obj)board/mpc8260ads/config.tmp ; \
+		  echo "... with lowboot configuration" ; \
+		}
+	@$(MKCONFIG) -a MPC8260ADS ppc mpc8260 mpc8260ads
+
+MPC8266ADS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 mpc8266ads
+
+# PM825/PM826 default configuration:  small (= 8 MB) Flash / boot from 64-bit flash
+PM825_config	\
+PM825_ROMBOOT_config	\
+PM825_BIGFLASH_config	\
+PM825_ROMBOOT_BIGFLASH_config	\
+PM826_config	\
+PM826_ROMBOOT_config	\
+PM826_BIGFLASH_config	\
+PM826_ROMBOOT_BIGFLASH_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/pm826
+	@if [ "$(findstring PM825_,$@)" ] ; then \
+		echo "#define CONFIG_PCI"	>$(obj)include/config.h ; \
+	else \
+		>$(obj)include/config.h ; \
+	fi
+	@if [ "$(findstring _ROMBOOT_,$@)" ] ; then \
+		echo "... booting from 8-bit flash" ; \
+		echo "#define CONFIG_BOOT_ROM" >>$(obj)include/config.h ; \
+		echo "TEXT_BASE = 0xFF800000" >$(obj)board/pm826/config.tmp ; \
+		if [ "$(findstring _BIGFLASH_,$@)" ] ; then \
+			echo "... with 32 MB Flash" ; \
+			echo "#define CONFIG_FLASH_32MB" >>$(obj)include/config.h ; \
+		fi; \
+	else \
+		echo "... booting from 64-bit flash" ; \
+		if [ "$(findstring _BIGFLASH_,$@)" ] ; then \
+			echo "... with 32 MB Flash" ; \
+			echo "#define CONFIG_FLASH_32MB" >>$(obj)include/config.h ; \
+			echo "TEXT_BASE = 0x40000000" >$(obj)board/pm826/config.tmp ; \
+		else \
+			echo "TEXT_BASE = 0xFF000000" >$(obj)board/pm826/config.tmp ; \
+		fi; \
+	fi
+	@$(MKCONFIG) -a PM826 ppc mpc8260 pm826
+
+PM828_config	\
+PM828_PCI_config	\
+PM828_ROMBOOT_config	\
+PM828_ROMBOOT_PCI_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/pm826
+	@if [ "$(findstring _PCI_,$@)" ] ; then \
+		echo "#define CONFIG_PCI"  >>$(obj)include/config.h ; \
+		echo "... with PCI enabled" ; \
+	else \
+		>$(obj)include/config.h ; \
+	fi
+	@if [ "$(findstring _ROMBOOT_,$@)" ] ; then \
+		echo "... booting from 8-bit flash" ; \
+		echo "#define CONFIG_BOOT_ROM" >>$(obj)include/config.h ; \
+		echo "TEXT_BASE = 0xFF800000" >$(obj)board/pm826/config.tmp ; \
+	fi
+	@$(MKCONFIG) -a PM828 ppc mpc8260 pm828
+
+ppmc8260_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 ppmc8260
+
+Rattler8248_config	\
+Rattler_config:		unconfig
+	@mkdir -p $(obj)include
+	$(if $(findstring 8248,$@), \
+	@echo "#define CONFIG_MPC8248" > $(obj)include/config.h)
+	@$(MKCONFIG) -a Rattler ppc mpc8260 rattler
+
+RPXsuper_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 rpxsuper
+
+rsdproto_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 rsdproto
+
+sacsng_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 sacsng
+
+sbc8260_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 sbc8260
+
+SCM_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 SCM siemens
+
+TQM8255_AA_config \
+TQM8260_AA_config \
+TQM8260_AB_config \
+TQM8260_AC_config \
+TQM8260_AD_config \
+TQM8260_AE_config \
+TQM8260_AF_config \
+TQM8260_AG_config \
+TQM8260_AH_config \
+TQM8260_AI_config \
+TQM8265_AA_config:  unconfig
+	@mkdir -p $(obj)include
+	@case "$@" in \
+	TQM8255_AA_config) CTYPE=MPC8255; CFREQ=300; CACHE=no;	BMODE=8260;;  \
+	TQM8260_AA_config) CTYPE=MPC8260; CFREQ=200; CACHE=no;	BMODE=8260;; \
+	TQM8260_AB_config) CTYPE=MPC8260; CFREQ=200; CACHE=yes;	BMODE=60x;;  \
+	TQM8260_AC_config) CTYPE=MPC8260; CFREQ=200; CACHE=yes;	BMODE=60x;;  \
+	TQM8260_AD_config) CTYPE=MPC8260; CFREQ=300; CACHE=no;	BMODE=60x;;  \
+	TQM8260_AE_config) CTYPE=MPC8260; CFREQ=266; CACHE=no;	BMODE=8260;; \
+	TQM8260_AF_config) CTYPE=MPC8260; CFREQ=300; CACHE=no;	BMODE=60x;;  \
+	TQM8260_AG_config) CTYPE=MPC8260; CFREQ=300; CACHE=no;	BMODE=8260;; \
+	TQM8260_AH_config) CTYPE=MPC8260; CFREQ=300; CACHE=yes;	BMODE=60x;;  \
+	TQM8260_AI_config) CTYPE=MPC8260; CFREQ=300; CACHE=no;	BMODE=60x;;  \
+	TQM8265_AA_config) CTYPE=MPC8265; CFREQ=300; CACHE=no;	BMODE=60x;;  \
+	esac; \
+	>$(obj)include/config.h ; \
+	if [ "$${CTYPE}" != "MPC8260" ] ; then \
+		echo "#define CONFIG_$${CTYPE}"	>>$(obj)include/config.h ; \
+	fi; \
+	echo "#define CONFIG_$${CFREQ}MHz"	>>$(obj)include/config.h ; \
+	echo "... with $${CFREQ}MHz system clock" ; \
+	if [ "$${CACHE}" == "yes" ] ; then \
+		echo "#define CONFIG_L2_CACHE"	>>$(obj)include/config.h ; \
+		echo "... with L2 Cache support" ; \
+	else \
+		echo "#undef CONFIG_L2_CACHE"	>>$(obj)include/config.h ; \
+		echo "... without L2 Cache support" ; \
+	fi; \
+	if [ "$${BMODE}" == "60x" ] ; then \
+		echo "#define CONFIG_BUSMODE_60x" >>$(obj)include/config.h ; \
+		echo "... with 60x Bus Mode" ; \
+	else \
+		echo "#undef CONFIG_BUSMODE_60x"  >>$(obj)include/config.h ; \
+		echo "... without 60x Bus Mode" ; \
+	fi
+	@$(MKCONFIG) -a TQM8260 ppc mpc8260 tqm8260
+
+TQM8272_config: unconfig
+	@$(MKCONFIG) -a TQM8272 ppc mpc8260 tqm8272
+
+VoVPN-GW_66MHz_config	\
+VoVPN-GW_100MHz_config:		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_CLKIN_$(word 2,$(subst _, ,$@))" > $(obj)include/config.h
+	@$(MKCONFIG) -a VoVPN-GW ppc mpc8260 vovpn-gw funkwerk
+
+ZPC1900_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc8260 zpc1900
+
+#########################################################################
+## Coldfire
+#########################################################################
+
+M5235EVB_config \
+M5235EVB_Flash16_config \
+M5235EVB_Flash32_config:	unconfig
+	@case "$@" in \
+	M5235EVB_config)		FLASH=16;; \
+	M5235EVB_Flash16_config)	FLASH=16;; \
+	M5235EVB_Flash32_config)	FLASH=32;; \
+	esac; \
+	>include/config.h ; \
+	if [ "$${FLASH}" != "16" ] ; then \
+		echo "#define NORFLASH_PS32BIT	1" >> include/config.h ; \
+		echo "TEXT_BASE = 0xFFC00000" > $(obj)board/freescale/m5235evb/config.tmp ; \
+		cp $(obj)board/freescale/m5235evb/u-boot.32 $(obj)board/freescale/m5235evb/u-boot.lds ; \
+	else \
+		echo "TEXT_BASE = 0xFFE00000" > $(obj)board/freescale/m5235evb/config.tmp ; \
+		cp $(obj)board/freescale/m5235evb/u-boot.16 $(obj)board/freescale/m5235evb/u-boot.lds ; \
+	fi
+	@$(MKCONFIG) -a M5235EVB m68k mcf523x m5235evb freescale
+
+M5249EVB_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 m5249evb freescale
+
+M5253EVBE_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 m5253evbe freescale
+
+cobra5272_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 cobra5272
+
+EB+MCF-EV123_config :		unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/BuS/EB+MCF-EV123
+	@ >$(obj)include/config.h
+	@echo "TEXT_BASE = 0xFFE00000"|tee $(obj)board/BuS/EB+MCF-EV123/textbase.mk
+	@$(MKCONFIG) EB+MCF-EV123 m68k mcf52x2 EB+MCF-EV123 BuS
+
+EB+MCF-EV123_internal_config :	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/BuS/EB+MCF-EV123
+	@ >$(obj)include/config.h
+	@echo "TEXT_BASE = 0xF0000000"|tee $(obj)board/BuS/EB+MCF-EV123/textbase.mk
+	@$(MKCONFIG) EB+MCF-EV123 m68k mcf52x2 EB+MCF-EV123 BuS
+
+idmr_config :			unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 idmr
+
+M5271EVB_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 m5271evb
+
+M5272C3_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 m5272c3
+
+M5282EVB_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 m5282evb
+
+TASREG_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 tasreg esd
+
+r5200_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) m68k mcf52x2 r5200
+
+M5329AFEE_config \
+M5329BFEE_config :	unconfig
+	@case "$@" in \
+	M5329AFEE_config)	NAND=0;; \
+	M5329BFEE_config)	NAND=16;; \
+	esac; \
+	>include/config.h ; \
+	if [ "$${NAND}" != "0" ] ; then \
+		echo "#define NANDFLASH_SIZE	$${NAND}" > $(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a M5329EVB m68k mcf532x m5329evb freescale
+
+M54455EVB_config \
+M54455EVB_atmel_config \
+M54455EVB_intel_config \
+M54455EVB_a33_config \
+M54455EVB_a66_config \
+M54455EVB_i33_config \
+M54455EVB_i66_config :	unconfig
+	@case "$@" in \
+	M54455EVB_config)		FLASH=ATMEL; FREQ=33333333;; \
+	M54455EVB_atmel_config)		FLASH=ATMEL; FREQ=33333333;; \
+	M54455EVB_intel_config)		FLASH=INTEL; FREQ=33333333;; \
+	M54455EVB_a33_config)		FLASH=ATMEL; FREQ=33333333;; \
+	M54455EVB_a66_config)		FLASH=ATMEL; FREQ=66666666;; \
+	M54455EVB_i33_config)		FLASH=INTEL; FREQ=33333333;; \
+	M54455EVB_i66_config)		FLASH=INTEL; FREQ=66666666;; \
+	esac; \
+	>include/config.h ; \
+	if [ "$${FLASH}" == "INTEL" ] ; then \
+		echo "#undef CFG_ATMEL_BOOT" >> $(obj)include/config.h ; \
+		echo "TEXT_BASE = 0x00000000" > $(obj)board/freescale/m54455evb/config.tmp ; \
+		cp $(obj)board/freescale/m54455evb/u-boot.int $(obj)board/freescale/m54455evb/u-boot.lds ; \
+		echo "... with INTEL boot..." ; \
+	else \
+		echo "#define CFG_ATMEL_BOOT"	>> $(obj)include/config.h ; \
+		echo "TEXT_BASE = 0x04000000" > $(obj)board/freescale/m54455evb/config.tmp ; \
+		cp $(obj)board/freescale/m54455evb/u-boot.atm $(obj)board/freescale/m54455evb/u-boot.lds ; \
+		echo "... with ATMEL boot..." ; \
+	fi; \
+	echo "#define CFG_INPUT_CLKSRC $${FREQ}" >> $(obj)include/config.h ; \
+	echo "... with $${FREQ}Hz input clock"
+	@$(MKCONFIG) -a M54455EVB m68k mcf5445x m54455evb freescale
+
+#########################################################################
+## MPC83xx Systems
+#########################################################################
+
+MPC8313ERDB_33_config \
+MPC8313ERDB_66_config: unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _33_,$@)" ] ; then \
+		echo -n "...33M ..." ; \
+		echo "#define CFG_33MHZ" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _66_,$@)" ] ; then \
+		echo -n "...66M..." ; \
+		echo "#define CFG_66MHZ" >>$(obj)include/config.h ; \
+	fi ;
+	@$(MKCONFIG) -a MPC8313ERDB ppc mpc83xx mpc8313erdb freescale
+
+MPC8323ERDB_config:	unconfig
+	@$(MKCONFIG) -a MPC8323ERDB ppc mpc83xx mpc8323erdb freescale
+
+MPC832XEMDS_config \
+MPC832XEMDS_HOST_33_config \
+MPC832XEMDS_HOST_66_config \
+MPC832XEMDS_SLAVE_config \
+MPC832XEMDS_ATM_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _HOST_,$@)" ] ; then \
+		echo -n "... PCI HOST " ; \
+		echo "#define CONFIG_PCI" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _SLAVE_,$@)" ] ; then \
+		echo "...PCI SLAVE 66M"  ; \
+		echo "#define CONFIG_PCI" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PCISLAVE" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _33_,$@)" ] ; then \
+		echo -n "...33M ..." ; \
+		echo "#define PCI_33M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _66_,$@)" ] ; then \
+		echo -n "...66M..." ; \
+		echo "#define PCI_66M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _ATM_,$@)" ] ; then \
+		echo -n "...ATM..." ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB_ATM     1" >>$(obj)include/config.h ; \
+	fi ;
+	@$(MKCONFIG) -a MPC832XEMDS ppc mpc83xx mpc832xemds freescale
+
+MPC8349EMDS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc83xx mpc8349emds freescale
+
+MPC8349ITX_config \
+MPC8349ITX_LOWBOOT_config \
+MPC8349ITXGP_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/freescale/mpc8349itx
+	@echo "#define CONFIG_$(subst _LOWBOOT,,$(@:_config=))" >> $(obj)include/config.h
+	@if [ "$(findstring GP,$@)" ] ; then \
+		echo "TEXT_BASE = 0xFE000000" >$(obj)board/freescale/mpc8349itx/config.tmp ; \
+	fi
+	@if [ "$(findstring LOWBOOT,$@)" ] ; then \
+		echo "TEXT_BASE = 0xFE000000" >$(obj)board/freescale/mpc8349itx/config.tmp ; \
+	fi
+	@$(MKCONFIG) -a -n $(@:_config=) MPC8349ITX ppc mpc83xx mpc8349itx freescale
+
+MPC8360EMDS_config \
+MPC8360EMDS_HOST_33_config \
+MPC8360EMDS_HOST_66_config \
+MPC8360EMDS_SLAVE_config \
+MPC8360EMDS_ATM_config: unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _HOST_,$@)" ] ; then \
+		echo -n "... PCI HOST " ; \
+		echo "#define CONFIG_PCI" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _SLAVE_,$@)" ] ; then \
+		echo "...PCI SLAVE 66M"  ; \
+		echo "#define CONFIG_PCI" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PCISLAVE" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _33_,$@)" ] ; then \
+		echo -n "...33M ..." ; \
+		echo "#define PCI_33M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _66_,$@)" ] ; then \
+		echo -n "...66M..." ; \
+		echo "#define PCI_66M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _ATM_,$@)" ] ; then \
+		echo -n "...ATM..." ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB_ATM     1" >>$(obj)include/config.h ; \
+	fi ;
+	@$(MKCONFIG) -a MPC8360EMDS ppc mpc83xx mpc8360emds freescale
+
+sbc8349_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc83xx sbc8349
+
+TQM834x_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc83xx tqm834x
+
+
+#########################################################################
+## MPC85xx Systems
+#########################################################################
+
+MPC8540ADS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8540ads
+
+MPC8540EVAL_config \
+MPC8540EVAL_33_config \
+MPC8540EVAL_66_config \
+MPC8540EVAL_33_slave_config \
+MPC8540EVAL_66_slave_config:      unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _33_,$@)" ] ; then \
+		echo "... 33 MHz PCI" ; \
+	else \
+		echo "#define CONFIG_SYSCLK_66M" >>$(obj)include/config.h ; \
+		echo "... 66 MHz PCI" ; \
+	fi ; \
+	if [ "$(findstring _slave_,$@)" ] ; then \
+		echo "#define CONFIG_PCI_SLAVE" >>$(obj)include/config.h ; \
+		echo " slave" ; \
+	else \
+		echo " host" ; \
+	fi
+	@$(MKCONFIG) -a MPC8540EVAL ppc mpc85xx mpc8540eval
+
+MPC8560ADS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8560ads
+
+MPC8541CDS_legacy_config \
+MPC8541CDS_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _legacy_,$@)" ] ; then \
+		echo "#define CONFIG_LEGACY" >>$(obj)include/config.h ; \
+		echo "... legacy" ; \
+	fi
+	@$(MKCONFIG) -a MPC8541CDS ppc mpc85xx mpc8541cds cds
+
+MPC8544DS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8544ds freescale
+
+MPC8548CDS_legacy_config \
+MPC8548CDS_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _legacy_,$@)" ] ; then \
+		echo "#define CONFIG_LEGACY" >>$(obj)include/config.h ; \
+		echo "... legacy" ; \
+	fi
+	@$(MKCONFIG) -a MPC8548CDS ppc mpc85xx mpc8548cds cds
+
+MPC8555CDS_legacy_config \
+MPC8555CDS_config:	unconfig
+	@mkdir -p $(obj)include
+	@echo "" >$(obj)include/config.h ; \
+	if [ "$(findstring _legacy_,$@)" ] ; then \
+		echo "#define CONFIG_LEGACY" >>$(obj)include/config.h ; \
+		echo "... legacy" ; \
+	fi
+	@$(MKCONFIG) -a MPC8555CDS ppc mpc85xx mpc8555cds cds
+
+MPC8568MDS_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx mpc8568mds
+
+PM854_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx pm854
+
+PM856_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx pm856
+
+sbc8540_config \
+sbc8540_33_config \
+sbc8540_66_config:	unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _66_,$@)" ] ; then \
+		echo "#define CONFIG_PCI_66"	>>$(obj)include/config.h ; \
+		echo "... 66 MHz PCI" ; \
+	else \
+		>$(obj)include/config.h ; \
+		echo "... 33 MHz PCI" ; \
+	fi
+	@$(MKCONFIG) -a SBC8540 ppc mpc85xx sbc8560
+
+sbc8560_config \
+sbc8560_33_config \
+sbc8560_66_config:      unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _66_,$@)" ] ; then \
+		echo "#define CONFIG_PCI_66"	>>$(obj)include/config.h ; \
+		echo "... 66 MHz PCI" ; \
+	else \
+		>$(obj)include/config.h ; \
+		echo "... 33 MHz PCI" ; \
+	fi
+	@$(MKCONFIG) -a sbc8560 ppc mpc85xx sbc8560
+
+stxgp3_config:		unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc85xx stxgp3
+
+stxssa_config		\
+stxssa_4M_config:	unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _4M_,$@)" ] ; then \
+		echo "#define CONFIG_STXSSA_4M" >>$(obj)include/config.h ; \
+		echo "... with 4 MiB flash memory" ; \
+	else \
+		>$(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a stxssa ppc mpc85xx stxssa
+
+TQM8540_config		\
+TQM8541_config		\
+TQM8555_config		\
+TQM8560_config:		unconfig
+	@mkdir -p $(obj)include
+	@CTYPE=$(subst TQM,,$(@:_config=)); \
+	>$(obj)include/config.h ; \
+	echo "... TQM"$${CTYPE}; \
+	echo "#define CONFIG_MPC$${CTYPE}">>$(obj)include/config.h; \
+	echo "#define CONFIG_TQM$${CTYPE}">>$(obj)include/config.h; \
+	echo "#define CONFIG_HOSTNAME tqm$${CTYPE}">>$(obj)include/config.h; \
+	echo "#define CONFIG_BOARDNAME \"TQM$${CTYPE}\"">>$(obj)include/config.h; \
+	echo "#define CFG_BOOTFILE_PATH \"/tftpboot/tqm$${CTYPE}/uImage\"">>$(obj)include/config.h
+	@$(MKCONFIG) -a TQM85xx ppc mpc85xx tqm85xx
+
+#########################################################################
+## MPC86xx Systems
+#########################################################################
+
+MPC8641HPCN_config:    unconfig
+	@$(MKCONFIG) $(@:_config=) ppc mpc86xx mpc8641hpcn freescale
+
+sbc8641d_config:	unconfig
+	@./mkconfig $(@:_config=) ppc mpc86xx sbc8641d
+
+#########################################################################
+## 74xx/7xx Systems
+#########################################################################
+
+AmigaOneG3SE_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx AmigaOneG3SE MAI
+
+BAB7xx_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx bab7xx eltec
+
+CPCI750_config:	unconfig
+	@$(MKCONFIG) CPCI750 ppc 74xx_7xx cpci750 esd
+
+DB64360_config:	unconfig
+	@$(MKCONFIG) DB64360 ppc 74xx_7xx db64360 Marvell
+
+DB64460_config:	unconfig
+	@$(MKCONFIG) DB64460 ppc 74xx_7xx db64460 Marvell
+
+ELPPC_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx elppc eltec
+
+EVB64260_config	\
+EVB64260_750CX_config:	unconfig
+	@$(MKCONFIG) EVB64260 ppc 74xx_7xx evb64260
+
+mpc7448hpc2_config:  unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx mpc7448hpc2
+
+P3G4_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx evb64260
+
+p3m750_config	\
+p3m7448_config:		unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring 750_,$@)" ] ; then \
+		echo "#define CONFIG_P3M750" >>$(obj)include/config.h ; \
+	else \
+		echo "#define CONFIG_P3M7448" >>$(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a p3mx ppc 74xx_7xx p3mx prodrive
+
+PCIPPC2_config \
+PCIPPC6_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx pcippc2
+
+ZUMA_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx evb64260
+
+ppmc7xx_config: unconfig
+	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx ppmc7xx
+
+#========================================================================
+# ARM
+#========================================================================
+#########################################################################
+## StrongARM Systems
+#########################################################################
+
+assabet_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm sa1100 assabet
+
+dnp1110_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm sa1100 dnp1110
+
+gcplus_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm sa1100 gcplus
+
+lart_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm sa1100 lart
+
+shannon_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm sa1100 shannon
+
+#########################################################################
+## ARM92xT Systems
+#########################################################################
+
+xtract_trab = $(subst _bigram,,$(subst _bigflash,,$(subst _old,,$(subst _config,,$1))))
+
+xtract_omap1610xxx = $(subst _cs0boot,,$(subst _cs3boot,,$(subst _cs_autoboot,,$(subst _config,,$1))))
+
+xtract_omap730p2 = $(subst _cs0boot,,$(subst _cs3boot,, $(subst _config,,$1)))
+
+at91rm9200dk_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t at91rm9200dk NULL at91rm9200
+
+cmc_pu2_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t cmc_pu2 NULL at91rm9200
+
+csb637_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t csb637 NULL at91rm9200
+
+mp2usb_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t mp2usb NULL at91rm9200
+
+
+########################################################################
+## ARM Integrator boards - see doc/README-integrator for more info.
+integratorap_config	\
+ap_config		\
+ap966_config		\
+ap922_config		\
+ap922_XA10_config	\
+ap7_config		\
+ap720t_config		\
+ap920t_config		\
+ap926ejs_config		\
+ap946es_config: unconfig
+	@board/integratorap/split_by_variant.sh $@
+
+integratorcp_config	\
+cp_config		\
+cp920t_config		\
+cp926ejs_config		\
+cp946es_config		\
+cp1136_config		\
+cp966_config		\
+cp922_config		\
+cp922_XA10_config	\
+cp1026_config: unconfig
+	@board/integratorcp/split_by_variant.sh $@
+
+kb9202_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t kb9202 NULL at91rm9200
+
+lpd7a400_config \
+lpd7a404_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm lh7a40x lpd7a40x
+
+mx1ads_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t mx1ads NULL imx
+
+mx1fs2_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t mx1fs2 NULL imx
+
+netstar_32_config	\
+netstar_config:		unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _32_,$@)" ] ; then \
+		echo "... 32MB SDRAM" ; \
+		echo "#define PHYS_SDRAM_1_SIZE SZ_32M" >>$(obj)include/config.h ; \
+	else \
+		echo "... 64MB SDRAM" ; \
+		echo "#define PHYS_SDRAM_1_SIZE SZ_64M" >>$(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a netstar arm arm925t netstar
+
+omap1510inn_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm925t omap1510inn
+
+omap5912osk_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs omap5912osk NULL omap
+
+davinci_dvevm_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs dv-evm davinci davinci
+
+davinci_schmoogie_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs schmoogie davinci davinci
+
+davinci_sonata_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs sonata davinci davinci
+
+omap1610inn_config \
+omap1610inn_cs0boot_config \
+omap1610inn_cs3boot_config \
+omap1610inn_cs_autoboot_config \
+omap1610h2_config \
+omap1610h2_cs0boot_config \
+omap1610h2_cs3boot_config \
+omap1610h2_cs_autoboot_config:	unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _cs0boot_, $@)" ] ; then \
+		echo "#define CONFIG_CS0_BOOT" >> .$(obj)include/config.h ; \
+		echo "... configured for CS0 boot"; \
+	elif [ "$(findstring _cs_autoboot_, $@)" ] ; then \
+		echo "#define CONFIG_CS_AUTOBOOT" >> $(obj)include/config.h ; \
+		echo "... configured for CS_AUTO boot"; \
+	else \
+		echo "#define CONFIG_CS3_BOOT" >> $(obj)include/config.h ; \
+		echo "... configured for CS3 boot"; \
+	fi;
+	@$(MKCONFIG) -a $(call xtract_omap1610xxx,$@) arm arm926ejs omap1610inn NULL omap
+
+omap730p2_config \
+omap730p2_cs0boot_config \
+omap730p2_cs3boot_config :	unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring _cs0boot_, $@)" ] ; then \
+		echo "#define CONFIG_CS0_BOOT" >> $(obj)include/config.h ; \
+		echo "... configured for CS0 boot"; \
+	else \
+		echo "#define CONFIG_CS3_BOOT" >> $(obj)include/config.h ; \
+		echo "... configured for CS3 boot"; \
+	fi;
+	@$(MKCONFIG) -a $(call xtract_omap730p2,$@) arm arm926ejs omap730p2 NULL omap
+
+sbc2410x_config: unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t sbc2410x NULL s3c24x0
+
+scb9328_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t scb9328 NULL imx
+
+smdk2400_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2400 NULL s3c24x0
+
+smdk2410_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t smdk2410 NULL s3c24x0
+
+SX1_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm925t sx1
+
+# TRAB default configuration:	8 MB Flash, 32 MB RAM
+trab_config \
+trab_bigram_config \
+trab_bigflash_config \
+trab_old_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/trab
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _bigram,$@)" ] || \
+		{ echo "#define CONFIG_FLASH_8MB"  >>$(obj)include/config.h ; \
+		  echo "#define CONFIG_RAM_32MB"   >>$(obj)include/config.h ; \
+		  echo "... with 8 MB Flash, 32 MB RAM" ; \
+		}
+	@[ -z "$(findstring _bigflash,$@)" ] || \
+		{ echo "#define CONFIG_FLASH_16MB" >>$(obj)include/config.h ; \
+		  echo "#define CONFIG_RAM_16MB"   >>$(obj)include/config.h ; \
+		  echo "... with 16 MB Flash, 16 MB RAM" ; \
+		  echo "TEXT_BASE = 0x0CF40000" >$(obj)board/trab/config.tmp ; \
+		}
+	@[ -z "$(findstring _old,$@)" ] || \
+		{ echo "#define CONFIG_FLASH_8MB"  >>$(obj)include/config.h ; \
+		  echo "#define CONFIG_RAM_16MB"   >>$(obj)include/config.h ; \
+		  echo "... with 8 MB Flash, 16 MB RAM" ; \
+		  echo "TEXT_BASE = 0x0CF40000" >$(obj)board/trab/config.tmp ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_trab,$@) arm arm920t trab NULL s3c24x0
+
+VCMA9_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t vcma9 mpl s3c24x0
+
+#========================================================================
+# ARM supplied Versatile development boards
+#========================================================================
+versatile_config	\
+versatileab_config	\
+versatilepb_config :	unconfig
+	@board/versatile/split_by_variant.sh $@
+
+voiceblue_smallflash_config	\
+voiceblue_config:	unconfig
+	@mkdir -p $(obj)include
+	@mkdir -p $(obj)board/voiceblue
+	@if [ "$(findstring _smallflash_,$@)" ] ; then \
+		echo "... boot from lower flash bank" ; \
+		echo "#define VOICEBLUE_SMALL_FLASH" >>$(obj)include/config.h ; \
+		echo "VOICEBLUE_SMALL_FLASH=y" >$(obj)board/voiceblue/config.tmp ; \
+	else \
+		echo "... boot from upper flash bank" ; \
+		>$(obj)include/config.h ; \
+		echo "VOICEBLUE_SMALL_FLASH=n" >$(obj)board/voiceblue/config.tmp ; \
+	fi
+	@$(MKCONFIG) -a voiceblue arm arm925t voiceblue
+
+cm4008_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t cm4008 NULL ks8695
+
+cm41xx_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm920t cm41xx NULL ks8695
+
+gth2_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_GTH2 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a gth2 mips mips gth2
+
+#########################################################################
+## S3C44B0 Systems
+#########################################################################
+
+B2_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm s3c44b0 B2 dave
+
+#########################################################################
+## ARM720T Systems
+#########################################################################
+
+armadillo_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t armadillo
+
+ep7312_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t ep7312
+
+impa7_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t impa7
+
+modnet50_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t modnet50
+
+evb4510_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t evb4510
+
+lpc2292sodimm_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t lpc2292sodimm NULL lpc2292
+
+SMN42_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm720t SMN42 siemens lpc2292
+
+#########################################################################
+## XScale Systems
+#########################################################################
+
+adsvix_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa adsvix
+
+cerf250_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa cerf250
+
+cradle_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa cradle
+
+csb226_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa csb226
+
+delta_config :
+	@$(MKCONFIG) $(@:_config=) arm pxa delta
+
+innokom_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa innokom
+
+ixdp425_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm ixp ixdp425
+
+ixdpg425_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm ixp ixdp425
+
+lubbock_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa lubbock
+
+pleb2_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa pleb2
+
+logodl_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa logodl
+
+pdnb3_config \
+scpu_config:    unconfig
+	@mkdir -p $(obj)include
+	@if [ "$(findstring scpu_,$@)" ] ; then \
+		echo "#define CONFIG_SCPU"      >>$(obj)include/config.h ; \
+		echo "... on SCPU board variant" ; \
+	else \
+		>$(obj)include/config.h ; \
+	fi
+	@$(MKCONFIG) -a pdnb3 arm ixp pdnb3 prodrive
+
+pxa255_idp_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa pxa255_idp
+
+trizepsiv_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa trizepsiv
+
+wepep250_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa wepep250
+
+xaeniax_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa xaeniax
+
+xm250_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa xm250
+
+xsengine_config :	unconfig
+	@$(MKCONFIG) $(@:_config=) arm pxa xsengine
+
+zylonite_config :
+	@$(MKCONFIG) $(@:_config=) arm pxa zylonite
+
+#########################################################################
+## ARM1136 Systems
+#########################################################################
+omap2420h4_config :    unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm1136 omap2420h4
+
+#========================================================================
+# i386
+#========================================================================
+#########################################################################
+## AMD SC520 CDP
+#########################################################################
+sc520_cdp_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_cdp
+
+sc520_spunk_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk
+
+sc520_spunk_rel_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) i386 i386 sc520_spunk
+
+#========================================================================
+# MIPS
+#========================================================================
+#########################################################################
+## MIPS32 4Kc
+#########################################################################
+
+xtract_incaip = $(subst _100MHz,,$(subst _133MHz,,$(subst _150MHz,,$(subst _config,,$1))))
+
+incaip_100MHz_config	\
+incaip_133MHz_config	\
+incaip_150MHz_config	\
+incaip_config: unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _100MHz,$@)" ] || \
+		{ echo "#define CPU_CLOCK_RATE 100000000" >>$(obj)include/config.h ; \
+		  echo "... with 100MHz system clock" ; \
+		}
+	@[ -z "$(findstring _133MHz,$@)" ] || \
+		{ echo "#define CPU_CLOCK_RATE 133000000" >>$(obj)include/config.h ; \
+		  echo "... with 133MHz system clock" ; \
+		}
+	@[ -z "$(findstring _150MHz,$@)" ] || \
+		{ echo "#define CPU_CLOCK_RATE 150000000" >>$(obj)include/config.h ; \
+		  echo "... with 150MHz system clock" ; \
+		}
+	@$(MKCONFIG) -a $(call xtract_incaip,$@) mips mips incaip
+
+tb0229_config: unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips tb0229
+
+#########################################################################
+## MIPS32 AU1X00
+#########################################################################
+dbau1000_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_DBAU1000 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a dbau1x00 mips mips dbau1x00
+
+dbau1100_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_DBAU1100 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a dbau1x00 mips mips dbau1x00
+
+dbau1500_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_DBAU1500 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a dbau1x00 mips mips dbau1x00
+
+dbau1550_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_DBAU1550 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a dbau1x00 mips mips dbau1x00
+
+dbau1550_el_config	:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_DBAU1550 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a dbau1x00 mips mips dbau1x00
+
+pb1000_config		:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_PB1000 1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a pb1x00 mips mips pb1x00
+
+#########################################################################
+## MIPS64 5Kc
+#########################################################################
+
+purple_config :		unconfig
+	@$(MKCONFIG) $(@:_config=) mips mips purple
+
+#========================================================================
+# Nios
+#========================================================================
+#########################################################################
+## Nios32
+#########################################################################
+
+DK1C20_safe_32_config		\
+DK1C20_standard_32_config	\
+DK1C20_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _safe_32,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_SAFE_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'safe_32' configuration" ; \
+		}
+	@[ -z "$(findstring _standard_32,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_STANDARD_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'standard_32' configuration" ; \
+		}
+	@[ -z "$(findstring DK1C20_config,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_STANDARD_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'standard_32' configuration (DEFAULT)" ; \
+		}
+	@$(MKCONFIG) -a DK1C20 nios nios dk1c20 altera
+
+DK1S10_safe_32_config		\
+DK1S10_standard_32_config	\
+DK1S10_mtx_ldk_20_config	\
+DK1S10_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _safe_32,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_SAFE_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'safe_32' configuration" ; \
+		}
+	@[ -z "$(findstring _standard_32,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_STANDARD_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'standard_32' configuration" ; \
+		}
+	@[ -z "$(findstring _mtx_ldk_20,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_MTX_LDK_20 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'mtx_ldk_20' configuration" ; \
+		}
+	@[ -z "$(findstring DK1S10_config,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_STANDARD_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'standard_32' configuration (DEFAULT)" ; \
+		}
+	@$(MKCONFIG) -a DK1S10 nios nios dk1s10 altera
+
+ADNPESC1_DNPEVA2_base_32_config	\
+ADNPESC1_base_32_config		\
+ADNPESC1_config: unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@[ -z "$(findstring _DNPEVA2,$@)" ] || \
+		{ echo "#define CONFIG_DNPEVA2 1" >>$(obj)include/config.h ; \
+		  echo "... DNP/EVA2 configuration" ; \
+		}
+	@[ -z "$(findstring _base_32,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_BASE_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'base_32' configuration" ; \
+		}
+	@[ -z "$(findstring ADNPESC1_config,$@)" ] || \
+		{ echo "#define CONFIG_NIOS_BASE_32 1" >>$(obj)include/config.h ; \
+		  echo "... NIOS 'base_32' configuration (DEFAULT)" ; \
+		}
+	@$(MKCONFIG) -a ADNPESC1 nios nios adnpesc1 ssv
+
+#########################################################################
+## Nios-II
+#########################################################################
+
+EP1C20_config : unconfig
+	@$(MKCONFIG)  EP1C20 nios2 nios2 ep1c20 altera
+
+EP1S10_config : unconfig
+	@$(MKCONFIG)  EP1S10 nios2 nios2 ep1s10 altera
+
+EP1S40_config : unconfig
+	@$(MKCONFIG)  EP1S40 nios2 nios2 ep1s40 altera
+
+PK1C20_config : unconfig
+	@$(MKCONFIG)  PK1C20 nios2 nios2 pk1c20 psyent
+
+PCI5441_config : unconfig
+	@$(MKCONFIG)  PCI5441 nios2 nios2 pci5441 psyent
+
+#========================================================================
+# MicroBlaze
+#========================================================================
+#########################################################################
+## Microblaze
+#########################################################################
+suzaku_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_SUZAKU 1" >> $(obj)include/config.h
+	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze suzaku AtmarkTechno
+
+ml401_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_ML401 1" >> $(obj)include/config.h
+	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze ml401 xilinx
+
+xupv2p_config:	unconfig
+	@mkdir -p $(obj)include
+	@ >$(obj)include/config.h
+	@echo "#define CONFIG_XUPV2P 1" >> $(obj)include/config.h
+	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze xupv2p xilinx
+
+#########################################################################
+## Blackfin
+#########################################################################
+bf533-ezkit_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) blackfin bf533 bf533-ezkit
+
+bf533-stamp_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) blackfin bf533 bf533-stamp
+
+bf537-stamp_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) blackfin bf537 bf537-stamp
+
+bf561-ezkit_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) blackfin bf561 bf561-ezkit
+
+#========================================================================
+# AVR32
+#========================================================================
+#########################################################################
+## AT32AP7xxx
+#########################################################################
+
+atstk1002_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap7000
+
+#========================================================================
+# SuperH
+#========================================================================
+#########################################################################
+## SuperH SH4
+#########################################################################
+
+mb411_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb411 sh sh mb411 st stb7100
+
+mb442_27_config \
+mb442_30_config \
+mb442_27_128_config \
+mb442_30_128_config \
+mb442se_27_config \
+mb442se_30_config \
+mb442se_27_128_config \
+mb442se_30_128_config : 	unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb442
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB442     1" >>$(obj)include/config.h
+	$(if $(findstring 27,$@), \
+	@echo "#define INPUT_CLOCK_RATE    27" >>$(obj)include/config.h)
+	$(if $(findstring 30,$@), \
+	@echo "#define INPUT_CLOCK_RATE    30" >>$(obj)include/config.h)
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_MB442_128 1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb442/config.tmp)
+	@$(MKCONFIG) -a mb442 sh sh mb442 st stb7100
+
+mb448_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB448     1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb448 sh sh mb448 st stb7100
+
+hms1_config \
+hms1_128_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HMS1      1" >>$(obj)include/config.h
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_HMS1_128  1" >>$(obj)include/config.h)
+	@$(MKCONFIG) -a hms1 sh sh hms1 st stb7100
+
+mb519_config \
+mb519se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb519
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB519     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb519/config.tmp)
+	@$(MKCONFIG) -a mb519 sh sh mb519 st stx7200
+
+mb618_config \
+mb618se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb618
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB618     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb618/config.tmp)
+	@$(MKCONFIG) -a mb618 sh sh mb618 st stx7111
+
+hdk7111_config \
+hdk7111se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hdk7111
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HDK7111   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/hdk7111/config.tmp)
+	@$(MKCONFIG) -a hdk7111 sh sh hdk7111 st stx7111
+
+mb628_config \
+mb628se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb628
+	@echo "#define CONFIG_SH_STX7141   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB628     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83900000" >$(obj)board/st/mb628/config.tmp)
+	@$(MKCONFIG) -a mb628 sh sh mb628 st stx7141
+
+mb671_config \
+mb671se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb671
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB671     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb671/config.tmp)
+	@$(MKCONFIG) -a mb671 sh sh mb671 st stx7200
+
+mb680_config \
+mb680se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb680
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB680     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb680/config.tmp)
+	@$(MKCONFIG) -a mb680 sh sh mb680 st stx7105
+
+pdk7105_config \
+pdk7105se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_PDK7105   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a pdk7105 sh sh pdk7105 st stx7105
+
+ipidtv7105_config \
+ipidtv7105se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_IPIDTV7105 1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a ipidtv7105 sh sh pdk7105 st stx7105
+
+mb704_config \
+mb704se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb704
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB704     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb704/config.tmp)
+	@$(MKCONFIG) -a mb704 sh sh mb704 st stx5197
+
+5197cab_config \
+5197cabse_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/5197cab
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_5197CAB   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/5197cab/config.tmp)
+	@$(MKCONFIG) -a 5197cab sh sh 5197cab st stx5197
+
+cb101_config \
+cb101se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/cb101
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB101     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/cb101/config.tmp)
+	@$(MKCONFIG) -a cb101 sh sh cb101 st stx7200
+
+cb102_config \
+cb102se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/cb102
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB102     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/cb102/config.tmp)
+	@$(MKCONFIG) -a cb102 sh sh cb102 st stx7200
+
+fldbse_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/fldb
+	@echo "#define CONFIG_SH_FLI7510   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_FLDB      1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a fldb sh sh fldb st fli7510
+
+
+#========================================================================
+# STMicroelectronics ST200
+#========================================================================
+#########################################################################
+## STMicroelectronics ST231
+#########################################################################
+
+sti5301mb390_config		: 	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB390   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb390 st200 st231 sti5301mb390 st sti5301
+
+sti5301mb424_config		: 	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB424   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb424 st200 st231 sti5301mb424 st sti5301
+
+stm8010mboard_config		:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_STM8010_MBOARD   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a stm8010mboard st200 st231 stm8010mboard st stm8010
+
+traviata_config		:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_TRAVIATA   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a traviata st200 st231 traviata st stm8010
+
+
+#########################################################################
+#########################################################################
+#########################################################################
+
+clean:
+	find $(OBJTREE) -type f \
+		\( -name 'core' -o -name '*.bak' -o -name '*~' \
+		-o -name '*.o'  -o -name '*.a'  \) -print \
+		| xargs rm -f
+	rm -f $(obj)examples/hello_world $(obj)examples/timer \
+	      $(obj)examples/eepro100_eeprom $(obj)examples/sched \
+	      $(obj)examples/mem_to_mem_idma2intr $(obj)examples/82559_eeprom \
+	      $(obj)examples/smc91111_eeprom $(obj)examples/interrupt \
+	      $(obj)examples/test_burst
+	rm -f $(obj)tools/img2srec $(obj)tools/mkimage $(obj)tools/envcrc \
+		$(obj)tools/gen_eth_addr $(obj)tools/ubsha1
+	rm -f $(obj)tools/mpc86x_clk $(obj)tools/ncb
+	rm -f $(obj)tools/easylogo/easylogo $(obj)tools/bmp_logo
+	rm -f $(obj)tools/gdb/astest $(obj)tools/gdb/gdbcont $(obj)tools/gdb/gdbsend
+	rm -f $(obj)tools/env/fw_printenv $(obj)tools/env/fw_setenv
+	rm -f $(obj)board/cray/L1/bootscript.c $(obj)board/cray/L1/bootscript.image
+	rm -f $(obj)board/netstar/eeprom $(obj)board/netstar/crcek $(obj)board/netstar/crcit
+	rm -f $(obj)board/netstar/*.srec $(obj)board/netstar/*.bin
+	rm -f $(obj)board/trab/trab_fkt $(obj)board/voiceblue/eeprom
+	rm -f $(obj)board/integratorap/u-boot.lds $(obj)board/integratorcp/u-boot.lds
+	rm -f $(obj)board/bf533-ezkit/u-boot.lds $(obj)board/bf533-stamp/u-boot.lds
+	rm -f $(obj)board/bf537-stamp/u-boot.lds $(obj)board/bf561-ezkit/u-boot.lds
+	rm -f $(obj)include/bmp_logo.h
+	rm -f $(obj)nand_spl/u-boot-spl $(obj)nand_spl/u-boot-spl.map
+
+clobber:	clean
+	find $(OBJTREE) -type f \( -name .depend \
+		-o -name '*.srec' -o -name '*.bin' -o -name u-boot.img \) \
+		-print0 \
+		| xargs -0 rm -f
+	rm -f $(OBJS) $(obj)*.bak $(obj)ctags $(obj)etags $(obj)TAGS $(obj)include/version_autogenerated.h
+	rm -fr $(obj)*.*~
+	rm -f $(obj)u-boot $(obj)u-boot.map $(obj)u-boot.hex $(ALL)
+	rm -f $(obj)tools/crc32.c $(obj)tools/environment.c $(obj)tools/env/crc32.c $(obj)tools/sha1.c
+	rm -f $(obj)tools/inca-swap-bytes $(obj)cpu/mpc824x/bedbug_603e.c
+	rm -f $(obj)include/asm/proc $(obj)include/asm/arch $(obj)include/asm
+	[ ! -d $(OBJTREE)/nand_spl ] || find $(obj)nand_spl -lname "*" -print | xargs rm -f
+
+ifeq ($(OBJTREE),$(SRCTREE))
+mrproper \
+distclean:	clobber unconfig
+else
+mrproper \
+distclean:	clobber unconfig
+	rm -rf $(OBJTREE)/*
+endif
+
+backup:
+	F=`basename $(TOPDIR)` ; cd .. ; \
+	gtar --force-local -zcvf `date "+$$F-%Y-%m-%d-%T.tar.gz"` $$F
+
+#########################################################################
diff -Nur u-boot-1.3.1/README u-boot-1.3.1-patched/README
--- u-boot-1.3.1/README	2011-07-02 21:08:15.475078713 +0200
+++ u-boot-1.3.1-patched/README	2011-07-02 21:07:24.580080647 +0200
@@ -1022,6 +1022,29 @@
 		the malloc area (as defined by CFG_MALLOC_LEN) should
 		be at least 4MB.
 
+		CONFIG_LZMA
+
+		If this option is set, support for lzma compressed
+		images is included.
+
+		Note: The LZMA algorithm adds between 2 and 4KB of code and it
+		requires an amount of dynamic memory that is given by the
+		formula:
+
+			(1846 + 768 << (lc + lp)) * sizeof(uint16)
+
+		Where lc and lp stand for, respectively, Literal context bits
+		and Literal pos bits.
+
+		This value is upper-bounded by 14MB in the worst case. Anyway,
+		for a ~4MB large kernel image, we have lc=3 and lp=0 for a
+		total amount of (1846 + 768 << (3 + 0)) * 2 = ~41KB... that is
+		a very small buffer.
+
+		Use the lzmainfo tool to determinate the lc and lp values and
+		then calculate the amount of needed dynamic memory (ensuring
+		the appropriate CFG_MALLOC_LEN value).
+
 - MII/PHY support:
 		CONFIG_PHY_ADDR
 
diff -Nur u-boot-1.3.1/README.orig u-boot-1.3.1-patched/README.orig
--- u-boot-1.3.1/README.orig	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.3.1-patched/README.orig	2011-07-02 21:06:32.127078557 +0200
@@ -0,0 +1,3754 @@
+#
+# (C) Copyright 2000 - 2005
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+Summary:
+========
+
+This directory contains the source code for U-Boot, a boot loader for
+Embedded boards based on PowerPC, ARM, MIPS and several other
+processors, which can be installed in a boot ROM and used to
+initialize and test the hardware or to download and run application
+code.
+
+The development of U-Boot is closely related to Linux: some parts of
+the source code originate in the Linux source tree, we have some
+header files in common, and special provision has been made to
+support booting of Linux images.
+
+Some attention has been paid to make this software easily
+configurable and extendable. For instance, all monitor commands are
+implemented with the same call interface, so that it's very easy to
+add new commands. Also, instead of permanently adding rarely used
+code (for instance hardware test utilities) to the monitor, you can
+load and run it dynamically.
+
+
+Status:
+=======
+
+In general, all boards for which a configuration option exists in the
+Makefile have been tested to some extent and can be considered
+"working". In fact, many of them are used in production systems.
+
+In case of problems see the CHANGELOG and CREDITS files to find out
+who contributed the specific port.
+
+
+Where to get help:
+==================
+
+In case you have questions about, problems with or contributions for
+U-Boot you should send a message to the U-Boot mailing list at
+<u-boot-users@lists.sourceforge.net>. There is also an archive of
+previous traffic on the mailing list - please search the archive
+before asking FAQ's. Please see
+http://lists.sourceforge.net/lists/listinfo/u-boot-users/
+
+
+Where we come from:
+===================
+
+- start from 8xxrom sources
+- create PPCBoot project (http://sourceforge.net/projects/ppcboot)
+- clean up code
+- make it easier to add custom boards
+- make it possible to add other [PowerPC] CPUs
+- extend functions, especially:
+  * Provide extended interface to Linux boot loader
+  * S-Record download
+  * network boot
+  * PCMCIA / CompactFLash / ATA disk / SCSI ... boot
+- create ARMBoot project (http://sourceforge.net/projects/armboot)
+- add other CPU families (starting with ARM)
+- create U-Boot project (http://sourceforge.net/projects/u-boot)
+
+
+Names and Spelling:
+===================
+
+The "official" name of this project is "Das U-Boot". The spelling
+"U-Boot" shall be used in all written text (documentation, comments
+in source files etc.). Example:
+
+	This is the README file for the U-Boot project.
+
+File names etc. shall be based on the string "u-boot". Examples:
+
+	include/asm-ppc/u-boot.h
+
+	#include <asm/u-boot.h>
+
+Variable names, preprocessor constants etc. shall be either based on
+the string "u_boot" or on "U_BOOT". Example:
+
+	U_BOOT_VERSION		u_boot_logo
+	IH_OS_U_BOOT		u_boot_hush_start
+
+
+Versioning:
+===========
+
+U-Boot uses a 3 level version number containing a version, a
+sub-version, and a patchlevel: "U-Boot-2.34.5" means version "2",
+sub-version "34", and patchlevel "4".
+
+The patchlevel is used to indicate certain stages of development
+between released versions, i. e. officially released versions of
+U-Boot will always have a patchlevel of "0".
+
+
+Directory Hierarchy:
+====================
+
+- board		Board dependent files
+- common	Misc architecture independent functions
+- cpu		CPU specific files
+  - 74xx_7xx	Files specific to Freescale MPC74xx and 7xx CPUs
+  - arm720t	Files specific to ARM 720 CPUs
+  - arm920t	Files specific to ARM 920 CPUs
+    - at91rm9200 Files specific to Atmel AT91RM9200 CPU
+    - imx	Files specific to Freescale MC9328 i.MX CPUs
+    - s3c24x0	Files specific to Samsung S3C24X0 CPUs
+  - arm925t	Files specific to ARM 925 CPUs
+  - arm926ejs	Files specific to ARM 926 CPUs
+  - arm1136	Files specific to ARM 1136 CPUs
+  - at32ap	Files specific to Atmel AVR32 AP CPUs
+  - i386	Files specific to i386 CPUs
+  - ixp		Files specific to Intel XScale IXP CPUs
+  - mcf52x2	Files specific to Freescale ColdFire MCF52x2 CPUs
+  - mcf532x	Files specific to Freescale ColdFire MCF5329 CPUs
+  - mcf5445x	Files specific to Freescale ColdFire MCF5445x CPUs
+  - mips	Files specific to MIPS CPUs
+  - mpc5xx	Files specific to Freescale MPC5xx  CPUs
+  - mpc5xxx	Files specific to Freescale MPC5xxx CPUs
+  - mpc8xx	Files specific to Freescale MPC8xx  CPUs
+  - mpc8220	Files specific to Freescale MPC8220 CPUs
+  - mpc824x	Files specific to Freescale MPC824x CPUs
+  - mpc8260	Files specific to Freescale MPC8260 CPUs
+  - mpc85xx	Files specific to Freescale MPC85xx CPUs
+  - nios	Files specific to Altera NIOS CPUs
+  - nios2	Files specific to Altera Nios-II CPUs
+  - ppc4xx	Files specific to AMCC PowerPC 4xx CPUs
+  - pxa		Files specific to Intel XScale PXA CPUs
+  - s3c44b0	Files specific to Samsung S3C44B0 CPUs
+  - sa1100	Files specific to Intel StrongARM SA1100 CPUs
+  - sh          Files specific to SuperH (SH) CPUs
+  - st231       Files specific to STMicroelectronics ST200 series CPUs
+- disk		Code for disk drive partition handling
+- doc		Documentation (don't expect too much)
+- drivers	Commonly used device drivers
+- dtt		Digital Thermometer and Thermostat drivers
+- examples	Example code for standalone applications, etc.
+- include	Header Files
+- lib_arm	Files generic to ARM	 architecture
+- lib_avr32	Files generic to AVR32	 architecture
+- lib_generic	Files generic to all	 architectures
+- lib_i386	Files generic to i386	 architecture
+- lib_m68k	Files generic to m68k	 architecture
+- lib_mips	Files generic to MIPS	 architecture
+- lib_nios	Files generic to NIOS	 architecture
+- lib_ppc	Files generic to PowerPC architecture
+- lib_sh	Files generic to SuperH  architecture
+- lib_st200	Files generic to ST200   architecture
+- libfdt 	Library files to support flattened device trees
+- net		Networking code
+- post		Power On Self Test
+- rtc		Real Time Clock drivers
+- tools		Tools to build S-Record or U-Boot images, etc.
+
+Software Configuration:
+=======================
+
+Configuration is usually done using C preprocessor defines; the
+rationale behind that is to avoid dead code whenever possible.
+
+There are two classes of configuration variables:
+
+* Configuration _OPTIONS_:
+  These are selectable by the user and have names beginning with
+  "CONFIG_".
+
+* Configuration _SETTINGS_:
+  These depend on the hardware etc. and should not be meddled with if
+  you don't know what you're doing; they have names beginning with
+  "CFG_".
+
+Later we will add a configuration tool - probably similar to or even
+identical to what's used for the Linux kernel. Right now, we have to
+do the configuration by hand, which means creating some symbolic
+links and editing some configuration files. We use the TQM8xxL boards
+as an example here.
+
+
+Selection of Processor Architecture and Board Type:
+---------------------------------------------------
+
+For all supported boards there are ready-to-use default
+configurations available; just type "make <board_name>_config".
+
+Example: For a TQM823L module type:
+
+	cd u-boot
+	make TQM823L_config
+
+For the Cogent platform, you need to specify the cpu type as well;
+e.g. "make cogent_mpc8xx_config". And also configure the cogent
+directory according to the instructions in cogent/README.
+
+
+Configuration Options:
+----------------------
+
+Configuration depends on the combination of board and CPU type; all
+such information is kept in a configuration file
+"include/configs/<board_name>.h".
+
+Example: For a TQM823L module, all configuration settings are in
+"include/configs/TQM823L.h".
+
+
+Many of the options are named exactly as the corresponding Linux
+kernel configuration options. The intention is to make it easier to
+build a config tool - later.
+
+
+The following options need to be configured:
+
+- CPU Type:	Define exactly one, e.g. CONFIG_MPC85XX.
+
+- Board Type:	Define exactly one, e.g. CONFIG_MPC8540ADS.
+
+- CPU Daughterboard Type: (if CONFIG_ATSTK1000 is defined)
+		Define exactly one of
+		CONFIG_ATSTK1002
+
+
+- CPU Module Type: (if CONFIG_COGENT is defined)
+		Define exactly one of
+		CONFIG_CMA286_60_OLD
+--- FIXME --- not tested yet:
+		CONFIG_CMA286_60, CONFIG_CMA286_21, CONFIG_CMA286_60P,
+		CONFIG_CMA287_23, CONFIG_CMA287_50
+
+- Motherboard Type: (if CONFIG_COGENT is defined)
+		Define exactly one of
+		CONFIG_CMA101, CONFIG_CMA102
+
+- Motherboard I/O Modules: (if CONFIG_COGENT is defined)
+		Define one or more of
+		CONFIG_CMA302
+
+- Motherboard Options: (if CONFIG_CMA101 or CONFIG_CMA102 are defined)
+		Define one or more of
+		CONFIG_LCD_HEARTBEAT	- update a character position on
+					  the lcd display every second with
+					  a "rotator" |\-/|\-/
+
+- Board flavour: (if CONFIG_MPC8260ADS is defined)
+		CONFIG_ADSTYPE
+		Possible values are:
+			CFG_8260ADS	- original MPC8260ADS
+			CFG_8266ADS	- MPC8266ADS
+			CFG_PQ2FADS	- PQ2FADS-ZU or PQ2FADS-VR
+			CFG_8272ADS	- MPC8272ADS
+
+- MPC824X Family Member (if CONFIG_MPC824X is defined)
+		Define exactly one of
+		CONFIG_MPC8240, CONFIG_MPC8245
+
+- 8xx CPU Options: (if using an MPC8xx cpu)
+		CONFIG_8xx_GCLK_FREQ	- deprecated: CPU clock if
+					  get_gclk_freq() cannot work
+					  e.g. if there is no 32KHz
+					  reference PIT/RTC clock
+		CONFIG_8xx_OSCLK	- PLL input clock (either EXTCLK
+					  or XTAL/EXTAL)
+
+- 859/866/885 CPU options: (if using a MPC859 or MPC866 or MPC885 CPU):
+		CFG_8xx_CPUCLK_MIN
+		CFG_8xx_CPUCLK_MAX
+		CONFIG_8xx_CPUCLK_DEFAULT
+			See doc/README.MPC866
+
+		CFG_MEASURE_CPUCLK
+
+		Define this to measure the actual CPU clock instead
+		of relying on the correctness of the configured
+		values. Mostly useful for board bringup to make sure
+		the PLL is locked at the intended frequency. Note
+		that this requires a (stable) reference clock (32 kHz
+		RTC clock or CFG_8XX_XIN)
+
+- Intel Monahans options:
+		CFG_MONAHANS_RUN_MODE_OSC_RATIO
+
+		Defines the Monahans run mode to oscillator
+		ratio. Valid values are 8, 16, 24, 31. The core
+		frequency is this value multiplied by 13 MHz.
+
+		CFG_MONAHANS_TURBO_RUN_MODE_RATIO
+
+		Defines the Monahans turbo mode to oscillator
+		ratio. Valid values are 1 (default if undefined) and
+		2. The core frequency as calculated above is multiplied
+		by this value.
+
+- Linux Kernel Interface:
+		CONFIG_CLOCKS_IN_MHZ
+
+		U-Boot stores all clock information in Hz
+		internally. For binary compatibility with older Linux
+		kernels (which expect the clocks passed in the
+		bd_info data to be in MHz) the environment variable
+		"clocks_in_mhz" can be defined so that U-Boot
+		converts clock data to MHZ before passing it to the
+		Linux kernel.
+		When CONFIG_CLOCKS_IN_MHZ is defined, a definition of
+		"clocks_in_mhz=1" is  automatically  included  in  the
+		default environment.
+
+		CONFIG_MEMSIZE_IN_BYTES		[relevant for MIPS only]
+
+		When transfering memsize parameter to linux, some versions
+		expect it to be in bytes, others in MB.
+		Define CONFIG_MEMSIZE_IN_BYTES to make it in bytes.
+
+		CONFIG_OF_LIBFDT / CONFIG_OF_FLAT_TREE
+
+		New kernel versions are expecting firmware settings to be
+		passed using flattened device trees (based on open firmware
+		concepts).
+
+		CONFIG_OF_LIBFDT
+		 * New libfdt-based support
+		 * Adds the "fdt" command
+		 * The bootm command automatically updates the fdt
+
+		CONFIG_OF_FLAT_TREE
+		 * Deprecated, see CONFIG_OF_LIBFDT
+		 * Original ft_build.c-based support
+		 * Automatically modifies the dft as part of the bootm command
+		 * The environment variable "disable_of", when set,
+		     disables this functionality.
+
+		OF_CPU - The proper name of the cpus node.
+		OF_SOC - The proper name of the soc node.
+		OF_TBCLK - The timebase frequency.
+		OF_STDOUT_PATH - The path to the console device
+
+		boards with QUICC Engines require OF_QE to set UCC mac addresses
+
+		CONFIG_OF_HAS_BD_T
+
+		 * CONFIG_OF_LIBFDT - enables the "fdt bd_t" command
+		 * CONFIG_OF_FLAT_TREE - The resulting flat device tree
+		     will have a copy of the bd_t.  Space should be
+		     pre-allocated in the dts for the bd_t.
+
+		CONFIG_OF_HAS_UBOOT_ENV
+
+		 * CONFIG_OF_LIBFDT - enables the "fdt env" command
+		 * CONFIG_OF_FLAT_TREE - The resulting flat device tree
+		     will have a copy of u-boot's environment variables
+
+		CONFIG_OF_BOARD_SETUP
+
+		Board code has addition modification that it wants to make
+		to the flat device tree before handing it off to the kernel
+
+		CONFIG_OF_BOOT_CPU
+
+		This define fills in the correct boot cpu in the boot
+		param header, the default value is zero if undefined.
+
+- Serial Ports:
+		CFG_PL010_SERIAL
+
+		Define this if you want support for Amba PrimeCell PL010 UARTs.
+
+		CFG_PL011_SERIAL
+
+		Define this if you want support for Amba PrimeCell PL011 UARTs.
+
+		CONFIG_PL011_CLOCK
+
+		If you have Amba PrimeCell PL011 UARTs, set this variable to
+		the clock speed of the UARTs.
+
+		CONFIG_PL01x_PORTS
+
+		If you have Amba PrimeCell PL010 or PL011 UARTs on your board,
+		define this to a list of base addresses for each (supported)
+		port. See e.g. include/configs/versatile.h
+
+
+- Console Interface:
+		Depending on board, define exactly one serial port
+		(like CONFIG_8xx_CONS_SMC1, CONFIG_8xx_CONS_SMC2,
+		CONFIG_8xx_CONS_SCC1, ...), or switch off the serial
+		console by defining CONFIG_8xx_CONS_NONE
+
+		Note: if CONFIG_8xx_CONS_NONE is defined, the serial
+		port routines must be defined elsewhere
+		(i.e. serial_init(), serial_getc(), ...)
+
+		CONFIG_CFB_CONSOLE
+		Enables console device for a color framebuffer. Needs following
+		defines (cf. smiLynxEM, i8042, board/eltec/bab7xx)
+			VIDEO_FB_LITTLE_ENDIAN	graphic memory organisation
+						(default big endian)
+			VIDEO_HW_RECTFILL	graphic chip supports
+						rectangle fill
+						(cf. smiLynxEM)
+			VIDEO_HW_BITBLT		graphic chip supports
+						bit-blit (cf. smiLynxEM)
+			VIDEO_VISIBLE_COLS	visible pixel columns
+						(cols=pitch)
+			VIDEO_VISIBLE_ROWS	visible pixel rows
+			VIDEO_PIXEL_SIZE	bytes per pixel
+			VIDEO_DATA_FORMAT	graphic data format
+						(0-5, cf. cfb_console.c)
+			VIDEO_FB_ADRS		framebuffer address
+			VIDEO_KBD_INIT_FCT	keyboard int fct
+						(i.e. i8042_kbd_init())
+			VIDEO_TSTC_FCT		test char fct
+						(i.e. i8042_tstc)
+			VIDEO_GETC_FCT		get char fct
+						(i.e. i8042_getc)
+			CONFIG_CONSOLE_CURSOR	cursor drawing on/off
+						(requires blink timer
+						cf. i8042.c)
+			CFG_CONSOLE_BLINK_COUNT blink interval (cf. i8042.c)
+			CONFIG_CONSOLE_TIME	display time/date info in
+						upper right corner
+						(requires CONFIG_CMD_DATE)
+			CONFIG_VIDEO_LOGO	display Linux logo in
+						upper left corner
+			CONFIG_VIDEO_BMP_LOGO	use bmp_logo.h instead of
+						linux_logo.h for logo.
+						Requires CONFIG_VIDEO_LOGO
+			CONFIG_CONSOLE_EXTRA_INFO
+						addional board info beside
+						the logo
+
+		When CONFIG_CFB_CONSOLE is defined, video console is
+		default i/o. Serial console can be forced with
+		environment 'console=serial'.
+
+		When CONFIG_SILENT_CONSOLE is defined, all console
+		messages (by U-Boot and Linux!) can be silenced with
+		the "silent" environment variable. See
+		doc/README.silent for more information.
+
+- Console Baudrate:
+		CONFIG_BAUDRATE - in bps
+		Select one of the baudrates listed in
+		CFG_BAUDRATE_TABLE, see below.
+		CFG_BRGCLK_PRESCALE, baudrate prescale
+
+- Interrupt driven serial port input:
+		CONFIG_SERIAL_SOFTWARE_FIFO
+
+		PPC405GP only.
+		Use an interrupt handler for receiving data on the
+		serial port. It also enables using hardware handshake
+		(RTS/CTS) and UART's built-in FIFO. Set the number of
+		bytes the interrupt driven input buffer should have.
+
+		Leave undefined to disable this feature, including
+		disable the buffer and hardware handshake.
+
+- Console UART Number:
+		CONFIG_UART1_CONSOLE
+
+		AMCC PPC4xx only.
+		If defined internal UART1 (and not UART0) is used
+		as default U-Boot console.
+
+- Boot Delay:	CONFIG_BOOTDELAY - in seconds
+		Delay before automatically booting the default image;
+		set to -1 to disable autoboot.
+
+		See doc/README.autoboot for these options that
+		work with CONFIG_BOOTDELAY. None are required.
+		CONFIG_BOOT_RETRY_TIME
+		CONFIG_BOOT_RETRY_MIN
+		CONFIG_AUTOBOOT_KEYED
+		CONFIG_AUTOBOOT_PROMPT
+		CONFIG_AUTOBOOT_DELAY_STR
+		CONFIG_AUTOBOOT_STOP_STR
+		CONFIG_AUTOBOOT_DELAY_STR2
+		CONFIG_AUTOBOOT_STOP_STR2
+		CONFIG_ZERO_BOOTDELAY_CHECK
+		CONFIG_RESET_TO_RETRY
+
+- Autoboot Command:
+		CONFIG_BOOTCOMMAND
+		Only needed when CONFIG_BOOTDELAY is enabled;
+		define a command string that is automatically executed
+		when no character is read on the console interface
+		within "Boot Delay" after reset.
+
+		CONFIG_BOOTARGS
+		This can be used to pass arguments to the bootm
+		command. The value of CONFIG_BOOTARGS goes into the
+		environment value "bootargs".
+
+		CONFIG_RAMBOOT and CONFIG_NFSBOOT
+		The value of these goes into the environment as
+		"ramboot" and "nfsboot" respectively, and can be used
+		as a convenience, when switching between booting from
+		ram and nfs.
+
+- Pre-Boot Commands:
+		CONFIG_PREBOOT
+
+		When this option is #defined, the existence of the
+		environment variable "preboot" will be checked
+		immediately before starting the CONFIG_BOOTDELAY
+		countdown and/or running the auto-boot command resp.
+		entering interactive mode.
+
+		This feature is especially useful when "preboot" is
+		automatically generated or modified. For an example
+		see the LWMON board specific code: here "preboot" is
+		modified when the user holds down a certain
+		combination of keys on the (special) keyboard when
+		booting the systems
+
+- Serial Download Echo Mode:
+		CONFIG_LOADS_ECHO
+		If defined to 1, all characters received during a
+		serial download (using the "loads" command) are
+		echoed back. This might be needed by some terminal
+		emulations (like "cu"), but may as well just take
+		time on others. This setting #define's the initial
+		value of the "loads_echo" environment variable.
+
+- Kgdb Serial Baudrate: (if CONFIG_CMD_KGDB is defined)
+		CONFIG_KGDB_BAUDRATE
+		Select one of the baudrates listed in
+		CFG_BAUDRATE_TABLE, see below.
+
+- Monitor Functions:
+		Monitor commands can be included or excluded
+		from the build by using the #include files
+		"config_cmd_all.h" and #undef'ing unwanted
+		commands, or using "config_cmd_default.h"
+		and augmenting with additional #define's
+		for wanted commands.
+
+		The default command configuration includes all commands
+		except those marked below with a "*".
+
+		CONFIG_CMD_ASKENV	* ask for env variable
+		CONFIG_CMD_AUTOSCRIPT	  Autoscript Support
+		CONFIG_CMD_BDI		  bdinfo
+		CONFIG_CMD_BEDBUG	* Include BedBug Debugger
+		CONFIG_CMD_BMP		* BMP support
+		CONFIG_CMD_BSP		* Board specific commands
+		CONFIG_CMD_BOOTD	  bootd
+		CONFIG_CMD_CACHE	* icache, dcache
+		CONFIG_CMD_CONSOLE	  coninfo
+		CONFIG_CMD_DATE		* support for RTC, date/time...
+		CONFIG_CMD_DHCP		* DHCP support
+		CONFIG_CMD_DIAG		* Diagnostics
+		CONFIG_CMD_DOC		* Disk-On-Chip Support
+		CONFIG_CMD_DTT		* Digital Therm and Thermostat
+		CONFIG_CMD_ECHO		  echo arguments
+		CONFIG_CMD_EEPROM	* EEPROM read/write support
+		CONFIG_CMD_ELF		* bootelf, bootvx
+		CONFIG_CMD_ENV		  saveenv
+		CONFIG_CMD_FDC		* Floppy Disk Support
+		CONFIG_CMD_FAT		* FAT partition support
+		CONFIG_CMD_FDOS		* Dos diskette Support
+		CONFIG_CMD_FLASH	  flinfo, erase, protect
+		CONFIG_CMD_FPGA		  FPGA device initialization support
+		CONFIG_CMD_HWFLOW	* RTS/CTS hw flow control
+		CONFIG_CMD_I2C		* I2C serial bus support
+		CONFIG_CMD_IDE		* IDE harddisk support
+		CONFIG_CMD_IMI		  iminfo
+		CONFIG_CMD_IMLS		  List all found images
+		CONFIG_CMD_IMMAP	* IMMR dump support
+		CONFIG_CMD_IRQ		* irqinfo
+		CONFIG_CMD_ITEST	  Integer/string test of 2 values
+		CONFIG_CMD_JFFS2	* JFFS2 Support
+		CONFIG_CMD_KGDB		* kgdb
+		CONFIG_CMD_LOADB	  loadb
+		CONFIG_CMD_LOADS	  loads
+		CONFIG_CMD_MEMORY	  md, mm, nm, mw, cp, cmp, crc, base,
+					  loop, loopw, mtest
+		CONFIG_CMD_MISC		  Misc functions like sleep etc
+		CONFIG_CMD_MMC		* MMC memory mapped support
+		CONFIG_CMD_MII		* MII utility commands
+		CONFIG_CMD_NAND		* NAND support
+		CONFIG_CMD_NET		  bootp, tftpboot, rarpboot
+		CONFIG_CMD_PCI		* pciinfo
+		CONFIG_CMD_PCMCIA		* PCMCIA support
+		CONFIG_CMD_PING		* send ICMP ECHO_REQUEST to network
+					  host
+		CONFIG_CMD_PORTIO	* Port I/O
+		CONFIG_CMD_REGINFO	* Register dump
+		CONFIG_CMD_RUN		  run command in env variable
+		CONFIG_CMD_SAVES	* save S record dump
+		CONFIG_CMD_SCSI		* SCSI Support
+		CONFIG_CMD_SDRAM	* print SDRAM configuration information
+					  (requires CONFIG_CMD_I2C)
+		CONFIG_CMD_SETGETDCR	  Support for DCR Register access
+					  (4xx only)
+		CONFIG_CMD_SPI		* SPI serial bus support
+		CONFIG_CMD_USB		* USB support
+		CONFIG_CMD_VFD		* VFD support (TRAB)
+		CONFIG_CMD_BSP		* Board SPecific functions
+		CONFIG_CMD_CDP		* Cisco Discover Protocol support
+		CONFIG_CMD_FSL		* Microblaze FSL support
+
+
+		EXAMPLE: If you want all functions except of network
+		support you can write:
+
+		#include "config_cmd_all.h"
+		#undef CONFIG_CMD_NET
+
+	Other Commands:
+		fdt (flattened device tree) command: CONFIG_OF_LIBFDT
+
+	Note:	Don't enable the "icache" and "dcache" commands
+		(configuration option CONFIG_CMD_CACHE) unless you know
+		what you (and your U-Boot users) are doing. Data
+		cache cannot be enabled on systems like the 8xx or
+		8260 (where accesses to the IMMR region must be
+		uncached), and it cannot be disabled on all other
+		systems where we (mis-) use the data cache to hold an
+		initial stack and some data.
+
+
+		XXX - this list needs to get updated!
+
+- Watchdog:
+		CONFIG_WATCHDOG
+		If this variable is defined, it enables watchdog
+		support. There must be support in the platform specific
+		code for a watchdog. For the 8xx and 8260 CPUs, the
+		SIU Watchdog feature is enabled in the SYPCR
+		register.
+
+- U-Boot Version:
+		CONFIG_VERSION_VARIABLE
+		If this variable is defined, an environment variable
+		named "ver" is created by U-Boot showing the U-Boot
+		version as printed by the "version" command.
+		This variable is readonly.
+
+- Real-Time Clock:
+
+		When CONFIG_CMD_DATE is selected, the type of the RTC
+		has to be selected, too. Define exactly one of the
+		following options:
+
+		CONFIG_RTC_MPC8xx	- use internal RTC of MPC8xx
+		CONFIG_RTC_PCF8563	- use Philips PCF8563 RTC
+		CONFIG_RTC_MC146818	- use MC146818 RTC
+		CONFIG_RTC_DS1307	- use Maxim, Inc. DS1307 RTC
+		CONFIG_RTC_DS1337	- use Maxim, Inc. DS1337 RTC
+		CONFIG_RTC_DS1338	- use Maxim, Inc. DS1338 RTC
+		CONFIG_RTC_DS164x	- use Dallas DS164x RTC
+		CONFIG_RTC_MAX6900	- use Maxim, Inc. MAX6900 RTC
+
+		Note that if the RTC uses I2C, then the I2C interface
+		must also be configured. See I2C Support, below.
+
+- Timestamp Support:
+
+		When CONFIG_TIMESTAMP is selected, the timestamp
+		(date and time) of an image is printed by image
+		commands like bootm or iminfo. This option is
+		automatically enabled when you select CONFIG_CMD_DATE .
+
+- Partition Support:
+		CONFIG_MAC_PARTITION and/or CONFIG_DOS_PARTITION
+		and/or CONFIG_ISO_PARTITION
+
+		If IDE or SCSI support	is  enabled  (CONFIG_CMD_IDE or
+		CONFIG_CMD_SCSI) you must configure support for at least
+		one partition type as well.
+
+- IDE Reset method:
+		CONFIG_IDE_RESET_ROUTINE - this is defined in several
+		board configurations files but used nowhere!
+
+		CONFIG_IDE_RESET - is this is defined, IDE Reset will
+		be performed by calling the function
+			ide_set_reset(int reset)
+		which has to be defined in a board specific file
+
+- ATAPI Support:
+		CONFIG_ATAPI
+
+		Set this to enable ATAPI support.
+
+- LBA48 Support
+		CONFIG_LBA48
+
+		Set this to enable support for disks larger than 137GB
+		Also look at CFG_64BIT_LBA ,CFG_64BIT_VSPRINTF and CFG_64BIT_STRTOUL
+		Whithout these , LBA48 support uses 32bit variables and will 'only'
+		support disks up to 2.1TB.
+
+		CFG_64BIT_LBA:
+			When enabled, makes the IDE subsystem use 64bit sector addresses.
+			Default is 32bit.
+
+- SCSI Support:
+		At the moment only there is only support for the
+		SYM53C8XX SCSI controller; define
+		CONFIG_SCSI_SYM53C8XX to enable it.
+
+		CFG_SCSI_MAX_LUN [8], CFG_SCSI_MAX_SCSI_ID [7] and
+		CFG_SCSI_MAX_DEVICE [CFG_SCSI_MAX_SCSI_ID *
+		CFG_SCSI_MAX_LUN] can be adjusted to define the
+		maximum numbers of LUNs, SCSI ID's and target
+		devices.
+		CFG_SCSI_SYM53C8XX_CCF to fix clock timing (80Mhz)
+
+- NETWORK Support (PCI):
+		CONFIG_E1000
+		Support for Intel 8254x gigabit chips.
+
+		CONFIG_EEPRO100
+		Support for Intel 82557/82559/82559ER chips.
+		Optional CONFIG_EEPRO100_SROM_WRITE enables eeprom
+		write routine for first time initialisation.
+
+		CONFIG_TULIP
+		Support for Digital 2114x chips.
+		Optional CONFIG_TULIP_SELECT_MEDIA for board specific
+		modem chip initialisation (KS8761/QS6611).
+
+		CONFIG_NATSEMI
+		Support for National dp83815 chips.
+
+		CONFIG_NS8382X
+		Support for National dp8382[01] gigabit chips.
+
+- NETWORK Support (other):
+
+		CONFIG_DRIVER_LAN91C96
+		Support for SMSC's LAN91C96 chips.
+
+			CONFIG_LAN91C96_BASE
+			Define this to hold the physical address
+			of the LAN91C96's I/O space
+
+			CONFIG_LAN91C96_USE_32_BIT
+			Define this to enable 32 bit addressing
+
+		CONFIG_DRIVER_SMC91111
+		Support for SMSC's LAN91C111 chip
+
+			CONFIG_SMC91111_BASE
+			Define this to hold the physical address
+			of the device (I/O space)
+
+			CONFIG_SMC_USE_32_BIT
+			Define this if data bus is 32 bits
+
+			CONFIG_SMC_USE_IOFUNCS
+			Define this to use i/o functions instead of macros
+			(some hardware wont work with macros)
+
+- USB Support:
+		At the moment only the UHCI host controller is
+		supported (PIP405, MIP405, MPC5200); define
+		CONFIG_USB_UHCI to enable it.
+		define CONFIG_USB_KEYBOARD to enable the USB Keyboard
+		and define CONFIG_USB_STORAGE to enable the USB
+		storage devices.
+		Note:
+		Supported are USB Keyboards and USB Floppy drives
+		(TEAC FD-05PUB).
+		MPC5200 USB requires additional defines:
+			CONFIG_USB_CLOCK
+				for 528 MHz Clock: 0x0001bbbb
+			CONFIG_USB_CONFIG
+				for differential drivers: 0x00001000
+				for single ended drivers: 0x00005000
+			CFG_USB_EVENT_POLL
+				May be defined to allow interrupt polling
+				instead of using asynchronous interrupts
+
+- USB Device:
+		Define the below if you wish to use the USB console.
+		Once firmware is rebuilt from a serial console issue the
+		command "setenv stdin usbtty; setenv stdout usbtty" and
+		attach your usb cable. The Unix command "dmesg" should print
+		it has found a new device. The environment variable usbtty
+		can be set to gserial or cdc_acm to enable your device to
+		appear to a USB host as a Linux gserial device or a
+		Common Device Class Abstract Control Model serial device.
+		If you select usbtty = gserial you should be able to enumerate
+		a Linux host by
+		# modprobe usbserial vendor=0xVendorID product=0xProductID
+		else if using cdc_acm, simply setting the environment
+		variable usbtty to be cdc_acm should suffice. The following
+		might be defined in YourBoardName.h
+
+			CONFIG_USB_DEVICE
+			Define this to build a UDC device
+
+			CONFIG_USB_TTY
+			Define this to have a tty type of device available to
+			talk to the UDC device
+
+			CFG_CONSOLE_IS_IN_ENV
+			Define this if you want stdin, stdout &/or stderr to
+			be set to usbtty.
+
+			mpc8xx:
+				CFG_USB_EXTC_CLK 0xBLAH
+				Derive USB clock from external clock "blah"
+				- CFG_USB_EXTC_CLK 0x02
+
+				CFG_USB_BRG_CLK 0xBLAH
+				Derive USB clock from brgclk
+				- CFG_USB_BRG_CLK 0x04
+
+		If you have a USB-IF assigned VendorID then you may wish to
+		define your own vendor specific values either in BoardName.h
+		or directly in usbd_vendor_info.h. If you don't define
+		CONFIG_USBD_MANUFACTURER, CONFIG_USBD_PRODUCT_NAME,
+		CONFIG_USBD_VENDORID and CONFIG_USBD_PRODUCTID, then U-Boot
+		should pretend to be a Linux device to it's target host.
+
+			CONFIG_USBD_MANUFACTURER
+			Define this string as the name of your company for
+			- CONFIG_USBD_MANUFACTURER "my company"
+
+			CONFIG_USBD_PRODUCT_NAME
+			Define this string as the name of your product
+			- CONFIG_USBD_PRODUCT_NAME "acme usb device"
+
+			CONFIG_USBD_VENDORID
+			Define this as your assigned Vendor ID from the USB
+			Implementors Forum. This *must* be a genuine Vendor ID
+			to avoid polluting the USB namespace.
+			- CONFIG_USBD_VENDORID 0xFFFF
+
+			CONFIG_USBD_PRODUCTID
+			Define this as the unique Product ID
+			for your device
+			- CONFIG_USBD_PRODUCTID 0xFFFF
+
+
+- MMC Support:
+		The MMC controller on the Intel PXA is supported. To
+		enable this define CONFIG_MMC. The MMC can be
+		accessed from the boot prompt by mapping the device
+		to physical memory similar to flash. Command line is
+		enabled with CONFIG_CMD_MMC. The MMC driver also works with
+		the FAT fs. This is enabled with CONFIG_CMD_FAT.
+
+- Journaling Flash filesystem support:
+		CONFIG_JFFS2_NAND, CONFIG_JFFS2_NAND_OFF, CONFIG_JFFS2_NAND_SIZE,
+		CONFIG_JFFS2_NAND_DEV
+		Define these for a default partition on a NAND device
+
+		CFG_JFFS2_FIRST_SECTOR,
+		CFG_JFFS2_FIRST_BANK, CFG_JFFS2_NUM_BANKS
+		Define these for a default partition on a NOR device
+
+		CFG_JFFS_CUSTOM_PART
+		Define this to create an own partition. You have to provide a
+		function struct part_info* jffs2_part_info(int part_num)
+
+		If you define only one JFFS2 partition you may also want to
+		#define CFG_JFFS_SINGLE_PART	1
+		to disable the command chpart. This is the default when you
+		have not defined a custom partition
+
+- Keyboard Support:
+		CONFIG_ISA_KEYBOARD
+
+		Define this to enable standard (PC-Style) keyboard
+		support
+
+		CONFIG_I8042_KBD
+		Standard PC keyboard driver with US (is default) and
+		GERMAN key layout (switch via environment 'keymap=de') support.
+		Export function i8042_kbd_init, i8042_tstc and i8042_getc
+		for cfb_console. Supports cursor blinking.
+
+- Video support:
+		CONFIG_VIDEO
+
+		Define this to enable video support (for output to
+		video).
+
+		CONFIG_VIDEO_CT69000
+
+		Enable Chips & Technologies 69000 Video chip
+
+		CONFIG_VIDEO_SMI_LYNXEM
+		Enable Silicon Motion SMI 712/710/810 Video chip. The
+		video output is selected via environment 'videoout'
+		(1 = LCD and 2 = CRT). If videoout is undefined, CRT is
+		assumed.
+
+		For the CT69000 and SMI_LYNXEM drivers, videomode is
+		selected via environment 'videomode'. Two diferent ways
+		are possible:
+		- "videomode=num"   'num' is a standard LiLo mode numbers.
+		Following standard modes are supported	(* is default):
+
+		      Colors	640x480 800x600 1024x768 1152x864 1280x1024
+		-------------+---------------------------------------------
+		      8 bits |	0x301*	0x303	 0x305	  0x161	    0x307
+		     15 bits |	0x310	0x313	 0x316	  0x162	    0x319
+		     16 bits |	0x311	0x314	 0x317	  0x163	    0x31A
+		     24 bits |	0x312	0x315	 0x318	    ?	    0x31B
+		-------------+---------------------------------------------
+		(i.e. setenv videomode 317; saveenv; reset;)
+
+		- "videomode=bootargs" all the video parameters are parsed
+		from the bootargs. (See drivers/videomodes.c)
+
+
+		CONFIG_VIDEO_SED13806
+		Enable Epson SED13806 driver. This driver supports 8bpp
+		and 16bpp modes defined by CONFIG_VIDEO_SED13806_8BPP
+		or CONFIG_VIDEO_SED13806_16BPP
+
+- Keyboard Support:
+		CONFIG_KEYBOARD
+
+		Define this to enable a custom keyboard support.
+		This simply calls drv_keyboard_init() which must be
+		defined in your board-specific files.
+		The only board using this so far is RBC823.
+
+- LCD Support:	CONFIG_LCD
+
+		Define this to enable LCD support (for output to LCD
+		display); also select one of the supported displays
+		by defining one of these:
+
+		CONFIG_NEC_NL6448AC33:
+
+			NEC NL6448AC33-18. Active, color, single scan.
+
+		CONFIG_NEC_NL6448BC20
+
+			NEC NL6448BC20-08. 6.5", 640x480.
+			Active, color, single scan.
+
+		CONFIG_NEC_NL6448BC33_54
+
+			NEC NL6448BC33-54. 10.4", 640x480.
+			Active, color, single scan.
+
+		CONFIG_SHARP_16x9
+
+			Sharp 320x240. Active, color, single scan.
+			It isn't 16x9, and I am not sure what it is.
+
+		CONFIG_SHARP_LQ64D341
+
+			Sharp LQ64D341 display, 640x480.
+			Active, color, single scan.
+
+		CONFIG_HLD1045
+
+			HLD1045 display, 640x480.
+			Active, color, single scan.
+
+		CONFIG_OPTREX_BW
+
+			Optrex	 CBL50840-2 NF-FW 99 22 M5
+			or
+			Hitachi	 LMG6912RPFC-00T
+			or
+			Hitachi	 SP14Q002
+
+			320x240. Black & white.
+
+		Normally display is black on white background; define
+		CFG_WHITE_ON_BLACK to get it inverted.
+
+- Splash Screen Support: CONFIG_SPLASH_SCREEN
+
+		If this option is set, the environment is checked for
+		a variable "splashimage". If found, the usual display
+		of logo, copyright and system information on the LCD
+		is suppressed and the BMP image at the address
+		specified in "splashimage" is loaded instead. The
+		console is redirected to the "nulldev", too. This
+		allows for a "silent" boot where a splash screen is
+		loaded very quickly after power-on.
+
+- Gzip compressed BMP image support: CONFIG_VIDEO_BMP_GZIP
+
+		If this option is set, additionally to standard BMP
+		images, gzipped BMP images can be displayed via the
+		splashscreen support or the bmp command.
+
+- Compression support:
+		CONFIG_BZIP2
+
+		If this option is set, support for bzip2 compressed
+		images is included. If not, only uncompressed and gzip
+		compressed images are supported.
+
+		NOTE: the bzip2 algorithm requires a lot of RAM, so
+		the malloc area (as defined by CFG_MALLOC_LEN) should
+		be at least 4MB.
+
+- MII/PHY support:
+		CONFIG_PHY_ADDR
+
+		The address of PHY on MII bus.
+
+		CONFIG_PHY_CLOCK_FREQ (ppc4xx)
+
+		The clock frequency of the MII bus
+
+		CONFIG_PHY_GIGE
+
+		If this option is set, support for speed/duplex
+		detection of Gigabit PHY is included.
+
+		CONFIG_PHY_RESET_DELAY
+
+		Some PHY like Intel LXT971A need extra delay after
+		reset before any MII register access is possible.
+		For such PHY, set this option to the usec delay
+		required. (minimum 300usec for LXT971A)
+
+		CONFIG_PHY_CMD_DELAY (ppc4xx)
+
+		Some PHY like Intel LXT971A need extra delay after
+		command issued before MII status register can be read
+
+- Ethernet address:
+		CONFIG_ETHADDR
+		CONFIG_ETH2ADDR
+		CONFIG_ETH3ADDR
+
+		Define a default value for ethernet address to use
+		for the respective ethernet interface, in case this
+		is not determined automatically.
+
+- IP address:
+		CONFIG_IPADDR
+
+		Define a default value for the IP address to use for
+		the default ethernet interface, in case this is not
+		determined through e.g. bootp.
+
+- Server IP address:
+		CONFIG_SERVERIP
+
+		Defines a default value for theIP address of a TFTP
+		server to contact when using the "tftboot" command.
+
+- Multicast TFTP Mode:
+		CONFIG_MCAST_TFTP
+
+		Defines whether you want to support multicast TFTP as per
+		rfc-2090; for example to work with atftp.  Lets lots of targets
+		tftp down the same boot image concurrently.  Note: the ethernet
+		driver in use must provide a function: mcast() to join/leave a
+		multicast group.
+
+		CONFIG_BOOTP_RANDOM_DELAY
+- BOOTP Recovery Mode:
+		CONFIG_BOOTP_RANDOM_DELAY
+
+		If you have many targets in a network that try to
+		boot using BOOTP, you may want to avoid that all
+		systems send out BOOTP requests at precisely the same
+		moment (which would happen for instance at recovery
+		from a power failure, when all systems will try to
+		boot, thus flooding the BOOTP server. Defining
+		CONFIG_BOOTP_RANDOM_DELAY causes a random delay to be
+		inserted before sending out BOOTP requests. The
+		following delays are inserted then:
+
+		1st BOOTP request:	delay 0 ... 1 sec
+		2nd BOOTP request:	delay 0 ... 2 sec
+		3rd BOOTP request:	delay 0 ... 4 sec
+		4th and following
+		BOOTP requests:		delay 0 ... 8 sec
+
+- DHCP Advanced Options:
+		You can fine tune the DHCP functionality by defining
+		CONFIG_BOOTP_* symbols:
+
+		CONFIG_BOOTP_SUBNETMASK
+		CONFIG_BOOTP_GATEWAY
+		CONFIG_BOOTP_HOSTNAME
+		CONFIG_BOOTP_NISDOMAIN
+		CONFIG_BOOTP_BOOTPATH
+		CONFIG_BOOTP_BOOTFILESIZE
+		CONFIG_BOOTP_DNS
+		CONFIG_BOOTP_DNS2
+		CONFIG_BOOTP_SEND_HOSTNAME
+		CONFIG_BOOTP_NTPSERVER
+		CONFIG_BOOTP_TIMEOFFSET
+		CONFIG_BOOTP_VENDOREX
+
+		CONFIG_BOOTP_SERVERIP - TFTP server will be the serverip
+		environment variable, not the BOOTP server.
+
+		CONFIG_BOOTP_DNS2 - If a DHCP client requests the DNS
+		serverip from a DHCP server, it is possible that more
+		than one DNS serverip is offered to the client.
+		If CONFIG_BOOTP_DNS2 is enabled, the secondary DNS
+		serverip will be stored in the additional environment
+		variable "dnsip2". The first DNS serverip is always
+		stored in the variable "dnsip", when CONFIG_BOOTP_DNS
+		is defined.
+
+		CONFIG_BOOTP_SEND_HOSTNAME - Some DHCP servers are capable
+		to do a dynamic update of a DNS server. To do this, they
+		need the hostname of the DHCP requester.
+		If CONFIG_BOOTP_SEND_HOSTNAME is defined, the content
+		of the "hostname" environment variable is passed as
+		option 12 to the DHCP server.
+
+ - CDP Options:
+		CONFIG_CDP_DEVICE_ID
+
+		The device id used in CDP trigger frames.
+
+		CONFIG_CDP_DEVICE_ID_PREFIX
+
+		A two character string which is prefixed to the MAC address
+		of the device.
+
+		CONFIG_CDP_PORT_ID
+
+		A printf format string which contains the ascii name of
+		the port. Normally is set to "eth%d" which sets
+		eth0 for the first ethernet, eth1 for the second etc.
+
+		CONFIG_CDP_CAPABILITIES
+
+		A 32bit integer which indicates the device capabilities;
+		0x00000010 for a normal host which does not forwards.
+
+		CONFIG_CDP_VERSION
+
+		An ascii string containing the version of the software.
+
+		CONFIG_CDP_PLATFORM
+
+		An ascii string containing the name of the platform.
+
+		CONFIG_CDP_TRIGGER
+
+		A 32bit integer sent on the trigger.
+
+		CONFIG_CDP_POWER_CONSUMPTION
+
+		A 16bit integer containing the power consumption of the
+		device in .1 of milliwatts.
+
+		CONFIG_CDP_APPLIANCE_VLAN_TYPE
+
+		A byte containing the id of the VLAN.
+
+- Status LED:	CONFIG_STATUS_LED
+
+		Several configurations allow to display the current
+		status using a LED. For instance, the LED will blink
+		fast while running U-Boot code, stop blinking as
+		soon as a reply to a BOOTP request was received, and
+		start blinking slow once the Linux kernel is running
+		(supported by a status LED driver in the Linux
+		kernel). Defining CONFIG_STATUS_LED enables this
+		feature in U-Boot.
+
+- CAN Support:	CONFIG_CAN_DRIVER
+
+		Defining CONFIG_CAN_DRIVER enables CAN driver support
+		on those systems that support this (optional)
+		feature, like the TQM8xxL modules.
+
+- I2C Support:	CONFIG_HARD_I2C | CONFIG_SOFT_I2C
+
+		These enable I2C serial bus commands. Defining either of
+		(but not both of) CONFIG_HARD_I2C or CONFIG_SOFT_I2C will
+		include the appropriate I2C driver for the selected cpu.
+
+		This will allow you to use i2c commands at the u-boot
+		command line (as long as you set CONFIG_CMD_I2C in
+		CONFIG_COMMANDS) and communicate with i2c based realtime
+		clock chips. See common/cmd_i2c.c for a description of the
+		command line interface.
+
+		CONFIG_I2C_CMD_TREE is a recommended option that places
+		all I2C commands under a single 'i2c' root command.  The
+		older 'imm', 'imd', 'iprobe' etc. commands are considered
+		deprecated and may disappear in the future.
+
+		CONFIG_HARD_I2C selects a hardware I2C controller.
+
+		CONFIG_SOFT_I2C configures u-boot to use a software (aka
+		bit-banging) driver instead of CPM or similar hardware
+		support for I2C.
+
+		There are several other quantities that must also be
+		defined when you define CONFIG_HARD_I2C or CONFIG_SOFT_I2C.
+
+		In both cases you will need to define CFG_I2C_SPEED
+		to be the frequency (in Hz) at which you wish your i2c bus
+		to run and CFG_I2C_SLAVE to be the address of this node (ie
+		the cpu's i2c node address).
+
+		Now, the u-boot i2c code for the mpc8xx (cpu/mpc8xx/i2c.c)
+		sets the cpu up as a master node and so its address should
+		therefore be cleared to 0 (See, eg, MPC823e User's Manual
+		p.16-473). So, set CFG_I2C_SLAVE to 0.
+
+		That's all that's required for CONFIG_HARD_I2C.
+
+		If you use the software i2c interface (CONFIG_SOFT_I2C)
+		then the following macros need to be defined (examples are
+		from include/configs/lwmon.h):
+
+		I2C_INIT
+
+		(Optional). Any commands necessary to enable the I2C
+		controller or configure ports.
+
+		eg: #define I2C_INIT (immr->im_cpm.cp_pbdir |=	PB_SCL)
+
+		I2C_PORT
+
+		(Only for MPC8260 CPU). The I/O port to use (the code
+		assumes both bits are on the same port). Valid values
+		are 0..3 for ports A..D.
+
+		I2C_ACTIVE
+
+		The code necessary to make the I2C data line active
+		(driven).  If the data line is open collector, this
+		define can be null.
+
+		eg: #define I2C_ACTIVE (immr->im_cpm.cp_pbdir |=  PB_SDA)
+
+		I2C_TRISTATE
+
+		The code necessary to make the I2C data line tri-stated
+		(inactive).  If the data line is open collector, this
+		define can be null.
+
+		eg: #define I2C_TRISTATE (immr->im_cpm.cp_pbdir &= ~PB_SDA)
+
+		I2C_READ
+
+		Code that returns TRUE if the I2C data line is high,
+		FALSE if it is low.
+
+		eg: #define I2C_READ ((immr->im_cpm.cp_pbdat & PB_SDA) != 0)
+
+		I2C_SDA(bit)
+
+		If <bit> is TRUE, sets the I2C data line high. If it
+		is FALSE, it clears it (low).
+
+		eg: #define I2C_SDA(bit) \
+			if(bit) immr->im_cpm.cp_pbdat |=  PB_SDA; \
+			else	immr->im_cpm.cp_pbdat &= ~PB_SDA
+
+		I2C_SCL(bit)
+
+		If <bit> is TRUE, sets the I2C clock line high. If it
+		is FALSE, it clears it (low).
+
+		eg: #define I2C_SCL(bit) \
+			if(bit) immr->im_cpm.cp_pbdat |=  PB_SCL; \
+			else	immr->im_cpm.cp_pbdat &= ~PB_SCL
+
+		I2C_DELAY
+
+		This delay is invoked four times per clock cycle so this
+		controls the rate of data transfer.  The data rate thus
+		is 1 / (I2C_DELAY * 4). Often defined to be something
+		like:
+
+		#define I2C_DELAY  udelay(2)
+
+		CFG_I2C_INIT_BOARD
+
+		When a board is reset during an i2c bus transfer
+		chips might think that the current transfer is still
+		in progress. On some boards it is possible to access
+		the i2c SCLK line directly, either by using the
+		processor pin as a GPIO or by having a second pin
+		connected to the bus. If this option is defined a
+		custom i2c_init_board() routine in boards/xxx/board.c
+		is run early in the boot sequence.
+
+		CONFIG_I2CFAST (PPC405GP|PPC405EP only)
+
+		This option enables configuration of bi_iic_fast[] flags
+		in u-boot bd_info structure based on u-boot environment
+		variable "i2cfast". (see also i2cfast)
+
+		CONFIG_I2C_MULTI_BUS
+
+		This option allows the use of multiple I2C buses, each of which
+		must have a controller.  At any point in time, only one bus is
+		active.  To switch to a different bus, use the 'i2c dev' command.
+		Note that bus numbering is zero-based.
+
+		CFG_I2C_NOPROBES
+
+		This option specifies a list of I2C devices that will be skipped
+		when the 'i2c probe' command is issued (or 'iprobe' using the legacy
+		command).  If CONFIG_I2C_MULTI_BUS is set, specify a list of bus-device
+		pairs.  Otherwise, specify a 1D array of device addresses
+
+		e.g.
+			#undef	CONFIG_I2C_MULTI_BUS
+			#define CFG_I2C_NOPROBES	{0x50,0x68}
+
+		will skip addresses 0x50 and 0x68 on a board with one I2C bus
+
+			#define	CONFIG_I2C_MULTI_BUS
+			#define CFG_I2C_MULTI_NOPROBES	{{0,0x50},{0,0x68},{1,0x54}}
+
+		will skip addresses 0x50 and 0x68 on bus 0 and address 0x54 on bus 1
+
+		CFG_SPD_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for DDR SPD.
+		If not defined, then U-Boot assumes that SPD is on I2C bus 0.
+
+		CFG_RTC_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for the RTC.
+		If not defined, then U-Boot assumes that RTC is on I2C bus 0.
+
+		CFG_DTT_BUS_NUM
+
+		If defined, then this indicates the I2C bus number for the DTT.
+		If not defined, then U-Boot assumes that DTT is on I2C bus 0.
+
+		CONFIG_FSL_I2C
+
+		Define this option if you want to use Freescale's I2C driver in
+		drivers/fsl_i2c.c.
+
+
+- SPI Support:	CONFIG_SPI
+
+		Enables SPI driver (so far only tested with
+		SPI EEPROM, also an instance works with Crystal A/D and
+		D/As on the SACSng board)
+
+		CONFIG_SPI_X
+
+		Enables extended (16-bit) SPI EEPROM addressing.
+		(symmetrical to CONFIG_I2C_X)
+
+		CONFIG_SOFT_SPI
+
+		Enables a software (bit-bang) SPI driver rather than
+		using hardware support. This is a general purpose
+		driver that only requires three general I/O port pins
+		(two outputs, one input) to function. If this is
+		defined, the board configuration must define several
+		SPI configuration items (port pins to use, etc). For
+		an example, see include/configs/sacsng.h.
+
+- FPGA Support: CONFIG_FPGA_COUNT
+
+		Specify the number of FPGA devices to support.
+
+		CONFIG_FPGA
+
+		Used to specify the types of FPGA devices.  For example,
+		#define CONFIG_FPGA  CFG_XILINX_VIRTEX2
+
+		CFG_FPGA_PROG_FEEDBACK
+
+		Enable printing of hash marks during FPGA configuration.
+
+		CFG_FPGA_CHECK_BUSY
+
+		Enable checks on FPGA configuration interface busy
+		status by the configuration function. This option
+		will require a board or device specific function to
+		be written.
+
+		CONFIG_FPGA_DELAY
+
+		If defined, a function that provides delays in the FPGA
+		configuration driver.
+
+		CFG_FPGA_CHECK_CTRLC
+		Allow Control-C to interrupt FPGA configuration
+
+		CFG_FPGA_CHECK_ERROR
+
+		Check for configuration errors during FPGA bitfile
+		loading. For example, abort during Virtex II
+		configuration if the INIT_B line goes low (which
+		indicated a CRC error).
+
+		CFG_FPGA_WAIT_INIT
+
+		Maximum time to wait for the INIT_B line to deassert
+		after PROB_B has been deasserted during a Virtex II
+		FPGA configuration sequence. The default time is 500
+		mS.
+
+		CFG_FPGA_WAIT_BUSY
+
+		Maximum time to wait for BUSY to deassert during
+		Virtex II FPGA configuration. The default is 5 mS.
+
+		CFG_FPGA_WAIT_CONFIG
+
+		Time to wait after FPGA configuration. The default is
+		200 mS.
+
+- Configuration Management:
+		CONFIG_IDENT_STRING
+
+		If defined, this string will be added to the U-Boot
+		version information (U_BOOT_VERSION)
+
+- Vendor Parameter Protection:
+
+		U-Boot considers the values of the environment
+		variables "serial#" (Board Serial Number) and
+		"ethaddr" (Ethernet Address) to be parameters that
+		are set once by the board vendor / manufacturer, and
+		protects these variables from casual modification by
+		the user. Once set, these variables are read-only,
+		and write or delete attempts are rejected. You can
+		change this behviour:
+
+		If CONFIG_ENV_OVERWRITE is #defined in your config
+		file, the write protection for vendor parameters is
+		completely disabled. Anybody can change or delete
+		these parameters.
+
+		Alternatively, if you #define _both_ CONFIG_ETHADDR
+		_and_ CONFIG_OVERWRITE_ETHADDR_ONCE, a default
+		ethernet address is installed in the environment,
+		which can be changed exactly ONCE by the user. [The
+		serial# is unaffected by this, i. e. it remains
+		read-only.]
+
+- Protected RAM:
+		CONFIG_PRAM
+
+		Define this variable to enable the reservation of
+		"protected RAM", i. e. RAM which is not overwritten
+		by U-Boot. Define CONFIG_PRAM to hold the number of
+		kB you want to reserve for pRAM. You can overwrite
+		this default value by defining an environment
+		variable "pram" to the number of kB you want to
+		reserve. Note that the board info structure will
+		still show the full amount of RAM. If pRAM is
+		reserved, a new environment variable "mem" will
+		automatically be defined to hold the amount of
+		remaining RAM in a form that can be passed as boot
+		argument to Linux, for instance like that:
+
+			setenv bootargs ... mem=\${mem}
+			saveenv
+
+		This way you can tell Linux not to use this memory,
+		either, which results in a memory region that will
+		not be affected by reboots.
+
+		*WARNING* If your board configuration uses automatic
+		detection of the RAM size, you must make sure that
+		this memory test is non-destructive. So far, the
+		following board configurations are known to be
+		"pRAM-clean":
+
+			ETX094, IVMS8, IVML24, SPD8xx, TQM8xxL,
+			HERMES, IP860, RPXlite, LWMON, LANTEC,
+			PCU_E, FLAGADM, TQM8260
+
+- Error Recovery:
+		CONFIG_PANIC_HANG
+
+		Define this variable to stop the system in case of a
+		fatal error, so that you have to reset it manually.
+		This is probably NOT a good idea for an embedded
+		system where you want to system to reboot
+		automatically as fast as possible, but it may be
+		useful during development since you can try to debug
+		the conditions that lead to the situation.
+
+		CONFIG_NET_RETRY_COUNT
+
+		This variable defines the number of retries for
+		network operations like ARP, RARP, TFTP, or BOOTP
+		before giving up the operation. If not defined, a
+		default value of 5 is used.
+
+- Command Interpreter:
+		CONFIG_AUTO_COMPLETE
+
+		Enable auto completion of commands using TAB.
+
+		Note that this feature has NOT been implemented yet
+		for the "hush" shell.
+
+
+		CFG_HUSH_PARSER
+
+		Define this variable to enable the "hush" shell (from
+		Busybox) as command line interpreter, thus enabling
+		powerful command line syntax like
+		if...then...else...fi conditionals or `&&' and '||'
+		constructs ("shell scripts").
+
+		If undefined, you get the old, much simpler behaviour
+		with a somewhat smaller memory footprint.
+
+
+		CFG_PROMPT_HUSH_PS2
+
+		This defines the secondary prompt string, which is
+		printed when the command interpreter needs more input
+		to complete a command. Usually "> ".
+
+	Note:
+
+		In the current implementation, the local variables
+		space and global environment variables space are
+		separated. Local variables are those you define by
+		simply typing `name=value'. To access a local
+		variable later on, you have write `$name' or
+		`${name}'; to execute the contents of a variable
+		directly type `$name' at the command prompt.
+
+		Global environment variables are those you use
+		setenv/printenv to work with. To run a command stored
+		in such a variable, you need to use the run command,
+		and you must not use the '$' sign to access them.
+
+		To store commands and special characters in a
+		variable, please use double quotation marks
+		surrounding the whole text of the variable, instead
+		of the backslashes before semicolons and special
+		symbols.
+
+- Commandline Editing and History:
+		CONFIG_CMDLINE_EDITING
+
+		Enable editiong and History functions for interactive
+		commandline input operations
+
+- Default Environment:
+		CONFIG_EXTRA_ENV_SETTINGS
+
+		Define this to contain any number of null terminated
+		strings (variable = value pairs) that will be part of
+		the default environment compiled into the boot image.
+
+		For example, place something like this in your
+		board's config file:
+
+		#define CONFIG_EXTRA_ENV_SETTINGS \
+			"myvar1=value1\0" \
+			"myvar2=value2\0"
+
+		Warning: This method is based on knowledge about the
+		internal format how the environment is stored by the
+		U-Boot code. This is NOT an official, exported
+		interface! Although it is unlikely that this format
+		will change soon, there is no guarantee either.
+		You better know what you are doing here.
+
+		Note: overly (ab)use of the default environment is
+		discouraged. Make sure to check other ways to preset
+		the environment like the autoscript function or the
+		boot command first.
+
+- DataFlash Support:
+		CONFIG_HAS_DATAFLASH
+
+		Defining this option enables DataFlash features and
+		allows to read/write in Dataflash via the standard
+		commands cp, md...
+
+- SystemACE Support:
+		CONFIG_SYSTEMACE
+
+		Adding this option adds support for Xilinx SystemACE
+		chips attached via some sort of local bus. The address
+		of the chip must alsh be defined in the
+		CFG_SYSTEMACE_BASE macro. For example:
+
+		#define CONFIG_SYSTEMACE
+		#define CFG_SYSTEMACE_BASE 0xf0000000
+
+		When SystemACE support is added, the "ace" device type
+		becomes available to the fat commands, i.e. fatls.
+
+- TFTP Fixed UDP Port:
+		CONFIG_TFTP_PORT
+
+		If this is defined, the environment variable tftpsrcp
+		is used to supply the TFTP UDP source port value.
+		If tftpsrcp isn't defined, the normal pseudo-random port
+		number generator is used.
+
+		Also, the environment variable tftpdstp is used to supply
+		the TFTP UDP destination port value.  If tftpdstp isn't
+		defined, the normal port 69 is used.
+
+		The purpose for tftpsrcp is to allow a TFTP server to
+		blindly start the TFTP transfer using the pre-configured
+		target IP address and UDP port. This has the effect of
+		"punching through" the (Windows XP) firewall, allowing
+		the remainder of the TFTP transfer to proceed normally.
+		A better solution is to properly configure the firewall,
+		but sometimes that is not allowed.
+
+- Show boot progress:
+		CONFIG_SHOW_BOOT_PROGRESS
+
+		Defining this option allows to add some board-
+		specific code (calling a user-provided function
+		"show_boot_progress(int)") that enables you to show
+		the system's boot progress on some display (for
+		example, some LED's) on your board. At the moment,
+		the following checkpoints are implemented:
+
+  Arg	Where			When
+    1	common/cmd_bootm.c	before attempting to boot an image
+   -1	common/cmd_bootm.c	Image header has bad	 magic number
+    2	common/cmd_bootm.c	Image header has correct magic number
+   -2	common/cmd_bootm.c	Image header has bad	 checksum
+    3	common/cmd_bootm.c	Image header has correct checksum
+   -3	common/cmd_bootm.c	Image data   has bad	 checksum
+    4	common/cmd_bootm.c	Image data   has correct checksum
+   -4	common/cmd_bootm.c	Image is for unsupported architecture
+    5	common/cmd_bootm.c	Architecture check OK
+   -5	common/cmd_bootm.c	Wrong Image Type (not kernel, multi, standalone)
+    6	common/cmd_bootm.c	Image Type check OK
+   -6	common/cmd_bootm.c	gunzip uncompression error
+   -7	common/cmd_bootm.c	Unimplemented compression type
+    7	common/cmd_bootm.c	Uncompression OK
+   -8	common/cmd_bootm.c	Wrong Image Type (not kernel, multi, standalone)
+    8	common/cmd_bootm.c	Image Type check OK
+   -9	common/cmd_bootm.c	Unsupported OS (not Linux, BSD, VxWorks, QNX)
+    9	common/cmd_bootm.c	Start initial ramdisk verification
+  -10	common/cmd_bootm.c	Ramdisk header has bad	   magic number
+  -11	common/cmd_bootm.c	Ramdisk header has bad	   checksum
+   10	common/cmd_bootm.c	Ramdisk header is OK
+  -12	common/cmd_bootm.c	Ramdisk data   has bad	   checksum
+   11	common/cmd_bootm.c	Ramdisk data   has correct checksum
+   12	common/cmd_bootm.c	Ramdisk verification complete, start loading
+  -13	common/cmd_bootm.c	Wrong Image Type (not PPC Linux Ramdisk)
+   13	common/cmd_bootm.c	Start multifile image verification
+   14	common/cmd_bootm.c	No initial ramdisk, no multifile, continue.
+   15	common/cmd_bootm.c	All preparation done, transferring control to OS
+
+  -30	lib_ppc/board.c		Fatal error, hang the system
+  -31	post/post.c		POST test failed, detected by post_output_backlog()
+  -32	post/post.c		POST test failed, detected by post_run_single()
+
+   34	common/cmd_doc.c	before loading a Image from a DOC device
+  -35	common/cmd_doc.c	Bad usage of "doc" command
+   35	common/cmd_doc.c	correct usage of "doc" command
+  -36	common/cmd_doc.c	No boot device
+   36	common/cmd_doc.c	correct boot device
+  -37	common/cmd_doc.c	Unknown Chip ID on boot device
+   37	common/cmd_doc.c	correct chip ID found, device available
+  -38	common/cmd_doc.c	Read Error on boot device
+   38	common/cmd_doc.c	reading Image header from DOC device OK
+  -39	common/cmd_doc.c	Image header has bad magic number
+   39	common/cmd_doc.c	Image header has correct magic number
+  -40	common/cmd_doc.c	Error reading Image from DOC device
+   40	common/cmd_doc.c	Image header has correct magic number
+   41	common/cmd_ide.c	before loading a Image from a IDE device
+  -42	common/cmd_ide.c	Bad usage of "ide" command
+   42	common/cmd_ide.c	correct usage of "ide" command
+  -43	common/cmd_ide.c	No boot device
+   43	common/cmd_ide.c	boot device found
+  -44	common/cmd_ide.c	Device not available
+   44	common/cmd_ide.c	Device available
+  -45	common/cmd_ide.c	wrong partition selected
+   45	common/cmd_ide.c	partition selected
+  -46	common/cmd_ide.c	Unknown partition table
+   46	common/cmd_ide.c	valid partition table found
+  -47	common/cmd_ide.c	Invalid partition type
+   47	common/cmd_ide.c	correct partition type
+  -48	common/cmd_ide.c	Error reading Image Header on boot device
+   48	common/cmd_ide.c	reading Image Header from IDE device OK
+  -49	common/cmd_ide.c	Image header has bad magic number
+   49	common/cmd_ide.c	Image header has correct magic number
+  -50	common/cmd_ide.c	Image header has bad	 checksum
+   50	common/cmd_ide.c	Image header has correct checksum
+  -51	common/cmd_ide.c	Error reading Image from IDE device
+   51	common/cmd_ide.c	reading Image from IDE device OK
+   52	common/cmd_nand.c	before loading a Image from a NAND device
+  -53	common/cmd_nand.c	Bad usage of "nand" command
+   53	common/cmd_nand.c	correct usage of "nand" command
+  -54	common/cmd_nand.c	No boot device
+   54	common/cmd_nand.c	boot device found
+  -55	common/cmd_nand.c	Unknown Chip ID on boot device
+   55	common/cmd_nand.c	correct chip ID found, device available
+  -56	common/cmd_nand.c	Error reading Image Header on boot device
+   56	common/cmd_nand.c	reading Image Header from NAND device OK
+  -57	common/cmd_nand.c	Image header has bad magic number
+   57	common/cmd_nand.c	Image header has correct magic number
+  -58	common/cmd_nand.c	Error reading Image from NAND device
+   58	common/cmd_nand.c	reading Image from NAND device OK
+
+  -60	common/env_common.c	Environment has a bad CRC, using default
+
+   64	net/eth.c		starting with Ethernetconfiguration.
+  -64	net/eth.c		no Ethernet found.
+   65	net/eth.c		Ethernet found.
+
+  -80	common/cmd_net.c	usage wrong
+   80	common/cmd_net.c	before calling NetLoop()
+  -81	common/cmd_net.c	some error in NetLoop() occured
+   81	common/cmd_net.c	NetLoop() back without error
+  -82	common/cmd_net.c	size == 0 (File with size 0 loaded)
+   82	common/cmd_net.c	trying automatic boot
+   83	common/cmd_net.c	running autoscript
+  -83	common/cmd_net.c	some error in automatic boot or autoscript
+   84	common/cmd_net.c	end without errors
+
+Modem Support:
+--------------
+
+[so far only for SMDK2400 and TRAB boards]
+
+- Modem support endable:
+		CONFIG_MODEM_SUPPORT
+
+- RTS/CTS Flow control enable:
+		CONFIG_HWFLOW
+
+- Modem debug support:
+		CONFIG_MODEM_SUPPORT_DEBUG
+
+		Enables debugging stuff (char screen[1024], dbg())
+		for modem support. Useful only with BDI2000.
+
+- Interrupt support (PPC):
+
+		There are common interrupt_init() and timer_interrupt()
+		for all PPC archs. interrupt_init() calls interrupt_init_cpu()
+		for cpu specific initialization. interrupt_init_cpu()
+		should set decrementer_count to appropriate value. If
+		cpu resets decrementer automatically after interrupt
+		(ppc4xx) it should set decrementer_count to zero.
+		timer_interrupt() calls timer_interrupt_cpu() for cpu
+		specific handling. If board has watchdog / status_led
+		/ other_activity_monitor it works automatically from
+		general timer_interrupt().
+
+- General:
+
+		In the target system modem support is enabled when a
+		specific key (key combination) is pressed during
+		power-on. Otherwise U-Boot will boot normally
+		(autoboot). The key_pressed() fuction is called from
+		board_init(). Currently key_pressed() is a dummy
+		function, returning 1 and thus enabling modem
+		initialization.
+
+		If there are no modem init strings in the
+		environment, U-Boot proceed to autoboot; the
+		previous output (banner, info printfs) will be
+		supressed, though.
+
+		See also: doc/README.Modem
+
+
+Configuration Settings:
+-----------------------
+
+- CFG_LONGHELP: Defined when you want long help messages included;
+		undefine this when you're short of memory.
+
+- CFG_PROMPT:	This is what U-Boot prints on the console to
+		prompt for user input.
+
+- CFG_CBSIZE:	Buffer size for input from the Console
+
+- CFG_PBSIZE:	Buffer size for Console output
+
+- CFG_MAXARGS:	max. Number of arguments accepted for monitor commands
+
+- CFG_BARGSIZE: Buffer size for Boot Arguments which are passed to
+		the application (usually a Linux kernel) when it is
+		booted
+
+- CFG_BAUDRATE_TABLE:
+		List of legal baudrate settings for this board.
+
+- CFG_CONSOLE_INFO_QUIET
+		Suppress display of console information at boot.
+
+- CFG_CONSOLE_IS_IN_ENV
+		If the board specific function
+			extern int overwrite_console (void);
+		returns 1, the stdin, stderr and stdout are switched to the
+		serial port, else the settings in the environment are used.
+
+- CFG_CONSOLE_OVERWRITE_ROUTINE
+		Enable the call to overwrite_console().
+
+- CFG_CONSOLE_ENV_OVERWRITE
+		Enable overwrite of previous console environment settings.
+
+- CFG_MEMTEST_START, CFG_MEMTEST_END:
+		Begin and End addresses of the area used by the
+		simple memory test.
+
+- CFG_ALT_MEMTEST:
+		Enable an alternate, more extensive memory test.
+
+- CFG_MEMTEST_SCRATCH:
+		Scratch address used by the alternate memory test
+		You only need to set this if address zero isn't writeable
+
+- CFG_TFTP_LOADADDR:
+		Default load address for network file downloads
+
+- CFG_LOADS_BAUD_CHANGE:
+		Enable temporary baudrate change while serial download
+
+- CFG_SDRAM_BASE:
+		Physical start address of SDRAM. _Must_ be 0 here.
+
+- CFG_MBIO_BASE:
+		Physical start address of Motherboard I/O (if using a
+		Cogent motherboard)
+
+- CFG_FLASH_BASE:
+		Physical start address of Flash memory.
+
+- CFG_MONITOR_BASE:
+		Physical start address of boot monitor code (set by
+		make config files to be same as the text base address
+		(TEXT_BASE) used when linking) - same as
+		CFG_FLASH_BASE when booting from flash.
+
+- CFG_MONITOR_LEN:
+		Size of memory reserved for monitor code, used to
+		determine _at_compile_time_ (!) if the environment is
+		embedded within the U-Boot image, or in a separate
+		flash sector.
+
+- CFG_MALLOC_LEN:
+		Size of DRAM reserved for malloc() use.
+
+- CFG_BOOTM_LEN:
+		Normally compressed uImages are limited to an
+		uncompressed size of 8 MBytes. If this is not enough,
+		you can define CFG_BOOTM_LEN in your board config file
+		to adjust this setting to your needs.
+
+- CFG_BOOTMAPSZ:
+		Maximum size of memory mapped by the startup code of
+		the Linux kernel; all data that must be processed by
+		the Linux kernel (bd_info, boot arguments, eventually
+		initrd image) must be put below this limit.
+
+- CFG_MAX_FLASH_BANKS:
+		Max number of Flash memory banks
+
+- CFG_MAX_FLASH_SECT:
+		Max number of sectors on a Flash chip
+
+- CFG_FLASH_ERASE_TOUT:
+		Timeout for Flash erase operations (in ms)
+
+- CFG_FLASH_WRITE_TOUT:
+		Timeout for Flash write operations (in ms)
+
+- CFG_FLASH_LOCK_TOUT
+		Timeout for Flash set sector lock bit operation (in ms)
+
+- CFG_FLASH_UNLOCK_TOUT
+		Timeout for Flash clear lock bits operation (in ms)
+
+- CFG_FLASH_PROTECTION
+		If defined, hardware flash sectors protection is used
+		instead of U-Boot software protection.
+
+- CFG_DIRECT_FLASH_TFTP:
+
+		Enable TFTP transfers directly to flash memory;
+		without this option such a download has to be
+		performed in two steps: (1) download to RAM, and (2)
+		copy from RAM to flash.
+
+		The two-step approach is usually more reliable, since
+		you can check if the download worked before you erase
+		the flash, but in some situations (when sytem RAM is
+		too limited to allow for a tempory copy of the
+		downloaded image) this option may be very useful.
+
+- CFG_FLASH_CFI:
+		Define if the flash driver uses extra elements in the
+		common flash structure for storing flash geometry.
+
+- CFG_FLASH_CFI_DRIVER
+		This option also enables the building of the cfi_flash driver
+		in the drivers directory
+
+- CFG_FLASH_QUIET_TEST
+		If this option is defined, the common CFI flash doesn't
+		print it's warning upon not recognized FLASH banks. This
+		is useful, if some of the configured banks are only
+		optionally available.
+
+- CFG_RX_ETH_BUFFER:
+		Defines the number of ethernet receive buffers. On some
+		ethernet controllers it is recommended to set this value
+		to 8 or even higher (EEPRO100 or 405 EMAC), since all
+		buffers can be full shortly after enabling the interface
+		on high ethernet traffic.
+		Defaults to 4 if not defined.
+
+The following definitions that deal with the placement and management
+of environment data (variable area); in general, we support the
+following configurations:
+
+- CFG_ENV_IS_IN_FLASH:
+
+	Define this if the environment is in flash memory.
+
+	a) The environment occupies one whole flash sector, which is
+	   "embedded" in the text segment with the U-Boot code. This
+	   happens usually with "bottom boot sector" or "top boot
+	   sector" type flash chips, which have several smaller
+	   sectors at the start or the end. For instance, such a
+	   layout can have sector sizes of 8, 2x4, 16, Nx32 kB. In
+	   such a case you would place the environment in one of the
+	   4 kB sectors - with U-Boot code before and after it. With
+	   "top boot sector" type flash chips, you would put the
+	   environment in one of the last sectors, leaving a gap
+	   between U-Boot and the environment.
+
+	- CFG_ENV_OFFSET:
+
+	   Offset of environment data (variable area) to the
+	   beginning of flash memory; for instance, with bottom boot
+	   type flash chips the second sector can be used: the offset
+	   for this sector is given here.
+
+	   CFG_ENV_OFFSET is used relative to CFG_FLASH_BASE.
+
+	- CFG_ENV_ADDR:
+
+	   This is just another way to specify the start address of
+	   the flash sector containing the environment (instead of
+	   CFG_ENV_OFFSET).
+
+	- CFG_ENV_SECT_SIZE:
+
+	   Size of the sector containing the environment.
+
+
+	b) Sometimes flash chips have few, equal sized, BIG sectors.
+	   In such a case you don't want to spend a whole sector for
+	   the environment.
+
+	- CFG_ENV_SIZE:
+
+	   If you use this in combination with CFG_ENV_IS_IN_FLASH
+	   and CFG_ENV_SECT_SIZE, you can specify to use only a part
+	   of this flash sector for the environment. This saves
+	   memory for the RAM copy of the environment.
+
+	   It may also save flash memory if you decide to use this
+	   when your environment is "embedded" within U-Boot code,
+	   since then the remainder of the flash sector could be used
+	   for U-Boot code. It should be pointed out that this is
+	   STRONGLY DISCOURAGED from a robustness point of view:
+	   updating the environment in flash makes it always
+	   necessary to erase the WHOLE sector. If something goes
+	   wrong before the contents has been restored from a copy in
+	   RAM, your target system will be dead.
+
+	- CFG_ENV_ADDR_REDUND
+	  CFG_ENV_SIZE_REDUND
+
+	   These settings describe a second storage area used to hold
+	   a redundand copy of the environment data, so that there is
+	   a valid backup copy in case there is a power failure during
+	   a "saveenv" operation.
+
+BE CAREFUL! Any changes to the flash layout, and some changes to the
+source code will make it necessary to adapt <board>/u-boot.lds*
+accordingly!
+
+
+- CFG_ENV_IS_IN_NVRAM:
+
+	Define this if you have some non-volatile memory device
+	(NVRAM, battery buffered SRAM) which you want to use for the
+	environment.
+
+	- CFG_ENV_ADDR:
+	- CFG_ENV_SIZE:
+
+	  These two #defines are used to determin the memory area you
+	  want to use for environment. It is assumed that this memory
+	  can just be read and written to, without any special
+	  provision.
+
+BE CAREFUL! The first access to the environment happens quite early
+in U-Boot initalization (when we try to get the setting of for the
+console baudrate). You *MUST* have mappend your NVRAM area then, or
+U-Boot will hang.
+
+Please note that even with NVRAM we still use a copy of the
+environment in RAM: we could work on NVRAM directly, but we want to
+keep settings there always unmodified except somebody uses "saveenv"
+to save the current settings.
+
+
+- CFG_ENV_IS_IN_EEPROM:
+
+	Use this if you have an EEPROM or similar serial access
+	device and a driver for it.
+
+	- CFG_ENV_OFFSET:
+	- CFG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the
+	  environment area within the total memory of your EEPROM.
+
+	- CFG_I2C_EEPROM_ADDR:
+	  If defined, specified the chip address of the EEPROM device.
+	  The default address is zero.
+
+	- CFG_EEPROM_PAGE_WRITE_BITS:
+	  If defined, the number of bits used to address bytes in a
+	  single page in the EEPROM device.  A 64 byte page, for example
+	  would require six bits.
+
+	- CFG_EEPROM_PAGE_WRITE_DELAY_MS:
+	  If defined, the number of milliseconds to delay between
+	  page writes.	The default is zero milliseconds.
+
+	- CFG_I2C_EEPROM_ADDR_LEN:
+	  The length in bytes of the EEPROM memory array address.  Note
+	  that this is NOT the chip address length!
+
+	- CFG_I2C_EEPROM_ADDR_OVERFLOW:
+	  EEPROM chips that implement "address overflow" are ones
+	  like Catalyst 24WC04/08/16 which has 9/10/11 bits of
+	  address and the extra bits end up in the "chip address" bit
+	  slots. This makes a 24WC08 (1Kbyte) chip look like four 256
+	  byte chips.
+
+	  Note that we consider the length of the address field to
+	  still be one byte because the extra address bits are hidden
+	  in the chip address.
+
+	- CFG_EEPROM_SIZE:
+	  The size in bytes of the EEPROM device.
+
+
+- CFG_ENV_IS_IN_DATAFLASH:
+
+	Define this if you have a DataFlash memory device which you
+	want to use for the environment.
+
+	- CFG_ENV_OFFSET:
+	- CFG_ENV_ADDR:
+	- CFG_ENV_SIZE:
+
+	  These three #defines specify the offset and size of the
+	  environment area within the total memory of your DataFlash placed
+	  at the specified address.
+
+- CFG_ENV_IS_IN_NAND:
+
+	Define this if you have a NAND device which you want to use
+	for the environment.
+
+	- CFG_ENV_OFFSET:
+	- CFG_ENV_SIZE:
+
+	  These two #defines specify the offset and size of the environment
+	  area within the first NAND device.
+
+	- CFG_ENV_OFFSET_REDUND
+
+	  This setting describes a second storage area of CFG_ENV_SIZE
+	  size used to hold a redundant copy of the environment data,
+	  so that there is a valid backup copy in case there is a
+	  power failure during a "saveenv" operation.
+
+	Note: CFG_ENV_OFFSET and CFG_ENV_OFFSET_REDUND must be aligned
+	to a block boundary, and CFG_ENV_SIZE must be a multiple of
+	the NAND devices block size.
+
+- CFG_SPI_INIT_OFFSET
+
+	Defines offset to the initial SPI buffer area in DPRAM. The
+	area is used at an early stage (ROM part) if the environment
+	is configured to reside in the SPI EEPROM: We need a 520 byte
+	scratch DPRAM area. It is used between the two initialization
+	calls (spi_init_f() and spi_init_r()). A value of 0xB00 seems
+	to be a good choice since it makes it far enough from the
+	start of the data area as well as from the stack pointer.
+
+Please note that the environment is read-only until the monitor
+has been relocated to RAM and a RAM copy of the environment has been
+created; also, when using EEPROM you will have to use getenv_r()
+until then to read environment variables.
+
+The environment is protected by a CRC32 checksum. Before the monitor
+is relocated into RAM, as a result of a bad CRC you will be working
+with the compiled-in default environment - *silently*!!! [This is
+necessary, because the first environment variable we need is the
+"baudrate" setting for the console - if we have a bad CRC, we don't
+have any device yet where we could complain.]
+
+Note: once the monitor has been relocated, then it will complain if
+the default environment is used; a new CRC is computed as soon as you
+use the "saveenv" command to store a valid environment.
+
+- CFG_FAULT_ECHO_LINK_DOWN:
+		Echo the inverted Ethernet link state to the fault LED.
+
+		Note: If this option is active, then CFG_FAULT_MII_ADDR
+		      also needs to be defined.
+
+- CFG_FAULT_MII_ADDR:
+		MII address of the PHY to check for the Ethernet link state.
+
+- CFG_64BIT_VSPRINTF:
+		Makes vsprintf (and all *printf functions) support printing
+		of 64bit values by using the L quantifier
+
+- CFG_64BIT_STRTOUL:
+		Adds simple_strtoull that returns a 64bit value
+
+Low Level (hardware related) configuration options:
+---------------------------------------------------
+
+- CFG_CACHELINE_SIZE:
+		Cache Line Size of the CPU.
+
+- CFG_DEFAULT_IMMR:
+		Default address of the IMMR after system reset.
+
+		Needed on some 8260 systems (MPC8260ADS, PQ2FADS-ZU,
+		and RPXsuper) to be able to adjust the position of
+		the IMMR register after a reset.
+
+- Floppy Disk Support:
+		CFG_FDC_DRIVE_NUMBER
+
+		the default drive number (default value 0)
+
+		CFG_ISA_IO_STRIDE
+
+		defines the spacing between fdc chipset registers
+		(default value 1)
+
+		CFG_ISA_IO_OFFSET
+
+		defines the offset of register from address. It
+		depends on which part of the data bus is connected to
+		the fdc chipset. (default value 0)
+
+		If CFG_ISA_IO_STRIDE CFG_ISA_IO_OFFSET and
+		CFG_FDC_DRIVE_NUMBER are undefined, they take their
+		default value.
+
+		if CFG_FDC_HW_INIT is defined, then the function
+		fdc_hw_init() is called at the beginning of the FDC
+		setup. fdc_hw_init() must be provided by the board
+		source code. It is used to make hardware dependant
+		initializations.
+
+- CFG_IMMR:	Physical address of the Internal Memory.
+		DO NOT CHANGE unless you know exactly what you're
+		doing! (11-4) [MPC8xx/82xx systems only]
+
+- CFG_INIT_RAM_ADDR:
+
+		Start address of memory area that can be used for
+		initial data and stack; please note that this must be
+		writable memory that is working WITHOUT special
+		initialization, i. e. you CANNOT use normal RAM which
+		will become available only after programming the
+		memory controller and running certain initialization
+		sequences.
+
+		U-Boot uses the following memory types:
+		- MPC8xx and MPC8260: IMMR (internal memory of the CPU)
+		- MPC824X: data cache
+		- PPC4xx:  data cache
+
+- CFG_GBL_DATA_OFFSET:
+
+		Offset of the initial data structure in the memory
+		area defined by CFG_INIT_RAM_ADDR. Usually
+		CFG_GBL_DATA_OFFSET is chosen such that the initial
+		data is located at the end of the available space
+		(sometimes written as (CFG_INIT_RAM_END -
+		CFG_INIT_DATA_SIZE), and the initial stack is just
+		below that area (growing from (CFG_INIT_RAM_ADDR +
+		CFG_GBL_DATA_OFFSET) downward.
+
+	Note:
+		On the MPC824X (or other systems that use the data
+		cache for initial memory) the address chosen for
+		CFG_INIT_RAM_ADDR is basically arbitrary - it must
+		point to an otherwise UNUSED address space between
+		the top of RAM and the start of the PCI space.
+
+- CFG_SIUMCR:	SIU Module Configuration (11-6)
+
+- CFG_SYPCR:	System Protection Control (11-9)
+
+- CFG_TBSCR:	Time Base Status and Control (11-26)
+
+- CFG_PISCR:	Periodic Interrupt Status and Control (11-31)
+
+- CFG_PLPRCR:	PLL, Low-Power, and Reset Control Register (15-30)
+
+- CFG_SCCR:	System Clock and reset Control Register (15-27)
+
+- CFG_OR_TIMING_SDRAM:
+		SDRAM timing
+
+- CFG_MAMR_PTA:
+		periodic timer for refresh
+
+- CFG_DER:	Debug Event Register (37-47)
+
+- FLASH_BASE0_PRELIM, FLASH_BASE1_PRELIM, CFG_REMAP_OR_AM,
+  CFG_PRELIM_OR_AM, CFG_OR_TIMING_FLASH, CFG_OR0_REMAP,
+  CFG_OR0_PRELIM, CFG_BR0_PRELIM, CFG_OR1_REMAP, CFG_OR1_PRELIM,
+  CFG_BR1_PRELIM:
+		Memory Controller Definitions: BR0/1 and OR0/1 (FLASH)
+
+- SDRAM_BASE2_PRELIM, SDRAM_BASE3_PRELIM, SDRAM_MAX_SIZE,
+  CFG_OR_TIMING_SDRAM, CFG_OR2_PRELIM, CFG_BR2_PRELIM,
+  CFG_OR3_PRELIM, CFG_BR3_PRELIM:
+		Memory Controller Definitions: BR2/3 and OR2/3 (SDRAM)
+
+- CFG_MAMR_PTA, CFG_MPTPR_2BK_4K, CFG_MPTPR_1BK_4K, CFG_MPTPR_2BK_8K,
+  CFG_MPTPR_1BK_8K, CFG_MAMR_8COL, CFG_MAMR_9COL:
+		Machine Mode Register and Memory Periodic Timer
+		Prescaler definitions (SDRAM timing)
+
+- CFG_I2C_UCODE_PATCH, CFG_I2C_DPMEM_OFFSET [0x1FC0]:
+		enable I2C microcode relocation patch (MPC8xx);
+		define relocation offset in DPRAM [DSP2]
+
+- CFG_SPI_UCODE_PATCH, CFG_SPI_DPMEM_OFFSET [0x1FC0]:
+		enable SPI microcode relocation patch (MPC8xx);
+		define relocation offset in DPRAM [SCC4]
+
+- CFG_USE_OSCCLK:
+		Use OSCM clock mode on MBX8xx board. Be careful,
+		wrong setting might damage your board. Read
+		doc/README.MBX before setting this variable!
+
+- CFG_CPM_POST_WORD_ADDR: (MPC8xx, MPC8260 only)
+		Offset of the bootmode word in DPRAM used by post
+		(Power On Self Tests). This definition overrides
+		#define'd default value in commproc.h resp.
+		cpm_8260.h.
+
+- CFG_PCI_SLV_MEM_LOCAL, CFG_PCI_SLV_MEM_BUS, CFG_PICMR0_MASK_ATTRIB,
+  CFG_PCI_MSTR0_LOCAL, CFG_PCIMSK0_MASK, CFG_PCI_MSTR1_LOCAL,
+  CFG_PCIMSK1_MASK, CFG_PCI_MSTR_MEM_LOCAL, CFG_PCI_MSTR_MEM_BUS,
+  CFG_CPU_PCI_MEM_START, CFG_PCI_MSTR_MEM_SIZE, CFG_POCMR0_MASK_ATTRIB,
+  CFG_PCI_MSTR_MEMIO_LOCAL, CFG_PCI_MSTR_MEMIO_BUS, CPU_PCI_MEMIO_START,
+  CFG_PCI_MSTR_MEMIO_SIZE, CFG_POCMR1_MASK_ATTRIB, CFG_PCI_MSTR_IO_LOCAL,
+  CFG_PCI_MSTR_IO_BUS, CFG_CPU_PCI_IO_START, CFG_PCI_MSTR_IO_SIZE,
+  CFG_POCMR2_MASK_ATTRIB: (MPC826x only)
+		Overrides the default PCI memory map in cpu/mpc8260/pci.c if set.
+
+- CONFIG_SPD_EEPROM
+		Get DDR timing information from an I2C EEPROM.  Common with pluggable
+		memory modules such as SODIMMs
+  SPD_EEPROM_ADDRESS
+		I2C address of the SPD EEPROM
+
+- CFG_SPD_BUS_NUM
+		If SPD EEPROM is on an I2C bus other than the first one, specify here.
+		Note that the value must resolve to something your driver can deal with.
+
+- CFG_83XX_DDR_USES_CS0
+		Only for 83xx systems. If specified, then DDR should be configured
+		using CS0 and CS1 instead of CS2 and CS3.
+
+- CFG_83XX_DDR_USES_CS0
+		Only for 83xx systems. If specified, then DDR should be configured
+		using CS0 and CS1 instead of CS2 and CS3.
+
+- CONFIG_ETHER_ON_FEC[12]
+		Define to enable FEC[12] on a 8xx series processor.
+
+- CONFIG_FEC[12]_PHY
+		Define to the hardcoded PHY address which corresponds
+		to the given FEC; i. e.
+			#define CONFIG_FEC1_PHY 4
+		means that the PHY with address 4 is connected to FEC1
+
+		When set to -1, means to probe for first available.
+
+- CONFIG_FEC[12]_PHY_NORXERR
+		The PHY does not have a RXERR line (RMII only).
+		(so program the FEC to ignore it).
+
+- CONFIG_RMII
+		Enable RMII mode for all FECs.
+		Note that this is a global option, we can't
+		have one FEC in standard MII mode and another in RMII mode.
+
+- CONFIG_CRC32_VERIFY
+		Add a verify option to the crc32 command.
+		The syntax is:
+
+		=> crc32 -v <address> <count> <crc32>
+
+		Where address/count indicate a memory area
+		and crc32 is the correct crc32 which the
+		area should have.
+
+- CONFIG_LOOPW
+		Add the "loopw" memory command. This only takes effect if
+		the memory commands are activated globally (CONFIG_CMD_MEM).
+
+- CONFIG_MX_CYCLIC
+		Add the "mdc" and "mwc" memory commands. These are cyclic
+		"md/mw" commands.
+		Examples:
+
+		=> mdc.b 10 4 500
+		This command will print 4 bytes (10,11,12,13) each 500 ms.
+
+		=> mwc.l 100 12345678 10
+		This command will write 12345678 to address 100 all 10 ms.
+
+		This only takes effect if the memory commands are activated
+		globally (CONFIG_CMD_MEM).
+
+- CONFIG_SKIP_LOWLEVEL_INIT
+- CONFIG_SKIP_RELOCATE_UBOOT
+
+		[ARM only] If these variables are defined, then
+		certain low level initializations (like setting up
+		the memory controller) are omitted and/or U-Boot does
+		not relocate itself into RAM.
+		Normally these variables MUST NOT be defined. The
+		only exception is when U-Boot is loaded (to RAM) by
+		some other boot loader or by a debugger which
+		performs these intializations itself.
+
+
+Building the Software:
+======================
+
+Building U-Boot has been tested in native PPC environments (on a
+PowerBook G3 running LinuxPPC 2000) and in cross environments
+(running RedHat 6.x and 7.x Linux on x86, Solaris 2.6 on a SPARC, and
+NetBSD 1.5 on x86).
+
+If you are not using a native PPC environment, it is assumed that you
+have the GNU cross compiling tools available in your path and named
+with a prefix of "powerpc-linux-". If this is not the case, (e.g. if
+you are using Monta Vista's Hard Hat Linux CDK 1.2) you must change
+the definition of CROSS_COMPILE in Makefile. For HHL on a 4xx CPU,
+change it to:
+
+	CROSS_COMPILE = ppc_4xx-
+
+
+U-Boot is intended to be  simple  to  build.  After  installing	 the
+sources	 you must configure U-Boot for one specific board type. This
+is done by typing:
+
+	make NAME_config
+
+where "NAME_config" is the name of one of the existing
+configurations; see the main Makefile for supported names.
+
+Note: for some board special configuration names may exist; check if
+      additional information is available from the board vendor; for
+      instance, the TQM823L systems are available without (standard)
+      or with LCD support. You can select such additional "features"
+      when chosing the configuration, i. e.
+
+      make TQM823L_config
+	- will configure for a plain TQM823L, i. e. no LCD support
+
+      make TQM823L_LCD_config
+	- will configure for a TQM823L with U-Boot console on LCD
+
+      etc.
+
+
+Finally, type "make all", and you should get some working U-Boot
+images ready for download to / installation on your system:
+
+- "u-boot.bin" is a raw binary image
+- "u-boot" is an image in ELF binary format
+- "u-boot.srec" is in Motorola S-Record format
+
+By default the build is performed locally and the objects are saved
+in the source directory. One of the two methods can be used to change
+this behavior and build U-Boot to some external directory:
+
+1. Add O= to the make command line invocations:
+
+	make O=/tmp/build distclean
+	make O=/tmp/build NAME_config
+	make O=/tmp/build all
+
+2. Set environment variable BUILD_DIR to point to the desired location:
+
+	export BUILD_DIR=/tmp/build
+	make distclean
+	make NAME_config
+	make all
+
+Note that the command line "O=" setting overrides the BUILD_DIR environment
+variable.
+
+
+Please be aware that the Makefiles assume you are using GNU make, so
+for instance on NetBSD you might need to use "gmake" instead of
+native "make".
+
+
+If the system board that you have is not listed, then you will need
+to port U-Boot to your hardware platform. To do this, follow these
+steps:
+
+1.  Add a new configuration option for your board to the toplevel
+    "Makefile" and to the "MAKEALL" script, using the existing
+    entries as examples. Note that here and at many other places
+    boards and other names are listed in alphabetical sort order. Please
+    keep this order.
+2.  Create a new directory to hold your board specific code. Add any
+    files you need. In your board directory, you will need at least
+    the "Makefile", a "<board>.c", "flash.c" and "u-boot.lds".
+3.  Create a new configuration file "include/configs/<board>.h" for
+    your board
+3.  If you're porting U-Boot to a new CPU, then also create a new
+    directory to hold your CPU specific code. Add any files you need.
+4.  Run "make <board>_config" with your new name.
+5.  Type "make", and you should get a working "u-boot.srec" file
+    to be installed on your target system.
+6.  Debug and solve any problems that might arise.
+    [Of course, this last step is much harder than it sounds.]
+
+
+Testing of U-Boot Modifications, Ports to New Hardware, etc.:
+==============================================================
+
+If you have modified U-Boot sources (for instance added a new	board
+or  support  for  new  devices,	 a new CPU, etc.) you are expected to
+provide feedback to the other developers. The feedback normally takes
+the form of a "patch", i. e. a context diff against a certain (latest
+official or latest in CVS) version of U-Boot sources.
+
+But before you submit such a patch, please verify that	your  modifi-
+cation	did not break existing code. At least make sure that *ALL* of
+the supported boards compile WITHOUT ANY compiler warnings. To do so,
+just run the "MAKEALL" script, which will configure and build U-Boot
+for ALL supported system. Be warned, this will take a while. You  can
+select	which  (cross)	compiler  to use by passing a `CROSS_COMPILE'
+environment variable to the script, i. e. to use the cross tools from
+MontaVista's Hard Hat Linux you can type
+
+	CROSS_COMPILE=ppc_8xx- MAKEALL
+
+or to build on a native PowerPC system you can type
+
+	CROSS_COMPILE=' ' MAKEALL
+
+When using the MAKEALL script, the default behaviour is to build U-Boot
+in the source directory. This location can be changed by setting the
+BUILD_DIR environment variable. Also, for each target built, the MAKEALL
+script saves two log files (<target>.ERR and <target>.MAKEALL) in the
+<source dir>/LOG directory. This default location can be changed by
+setting the MAKEALL_LOGDIR environment variable. For example:
+
+	export BUILD_DIR=/tmp/build
+	export MAKEALL_LOGDIR=/tmp/log
+	CROSS_COMPILE=ppc_8xx- MAKEALL
+
+With the above settings build objects are saved in the /tmp/build, log
+files are saved in the /tmp/log and the source tree remains clean during
+the whole build process.
+
+
+See also "U-Boot Porting Guide" below.
+
+
+Monitor Commands - Overview:
+============================
+
+go	- start application at address 'addr'
+run	- run commands in an environment variable
+bootm	- boot application image from memory
+bootp	- boot image via network using BootP/TFTP protocol
+tftpboot- boot image via network using TFTP protocol
+	       and env variables "ipaddr" and "serverip"
+	       (and eventually "gatewayip")
+rarpboot- boot image via network using RARP/TFTP protocol
+diskboot- boot from IDE devicebootd   - boot default, i.e., run 'bootcmd'
+loads	- load S-Record file over serial line
+loadb	- load binary file over serial line (kermit mode)
+md	- memory display
+mm	- memory modify (auto-incrementing)
+nm	- memory modify (constant address)
+mw	- memory write (fill)
+cp	- memory copy
+cmp	- memory compare
+crc32	- checksum calculation
+imd	- i2c memory display
+imm	- i2c memory modify (auto-incrementing)
+inm	- i2c memory modify (constant address)
+imw	- i2c memory write (fill)
+icrc32	- i2c checksum calculation
+iprobe	- probe to discover valid I2C chip addresses
+iloop	- infinite loop on address range
+isdram	- print SDRAM configuration information
+sspi	- SPI utility commands
+base	- print or set address offset
+printenv- print environment variables
+setenv	- set environment variables
+saveenv - save environment variables to persistent storage
+protect - enable or disable FLASH write protection
+erase	- erase FLASH memory
+flinfo	- print FLASH memory information
+bdinfo	- print Board Info structure
+iminfo	- print header information for application image
+coninfo - print console devices and informations
+ide	- IDE sub-system
+loop	- infinite loop on address range
+loopw	- infinite write loop on address range
+mtest	- simple RAM test
+icache	- enable or disable instruction cache
+dcache	- enable or disable data cache
+reset	- Perform RESET of the CPU
+echo	- echo args to console
+version - print monitor version
+help	- print online help
+?	- alias for 'help'
+
+
+Monitor Commands - Detailed Description:
+========================================
+
+TODO.
+
+For now: just type "help <command>".
+
+
+Environment Variables:
+======================
+
+U-Boot supports user configuration using Environment Variables which
+can be made persistent by saving to Flash memory.
+
+Environment Variables are set using "setenv", printed using
+"printenv", and saved to Flash using "saveenv". Using "setenv"
+without a value can be used to delete a variable from the
+environment. As long as you don't save the environment you are
+working with an in-memory copy. In case the Flash area containing the
+environment is erased by accident, a default environment is provided.
+
+Some configuration options can be set using Environment Variables:
+
+  baudrate	- see CONFIG_BAUDRATE
+
+  bootdelay	- see CONFIG_BOOTDELAY
+
+  bootcmd	- see CONFIG_BOOTCOMMAND
+
+  bootargs	- Boot arguments when booting an RTOS image
+
+  bootfile	- Name of the image to load with TFTP
+
+  autoload	- if set to "no" (any string beginning with 'n'),
+		  "bootp" will just load perform a lookup of the
+		  configuration from the BOOTP server, but not try to
+		  load any image using TFTP
+
+  autostart	- if set to "yes", an image loaded using the "bootp",
+		  "rarpboot", "tftpboot" or "diskboot" commands will
+		  be automatically started (by internally calling
+		  "bootm")
+
+		  If set to "no", a standalone image passed to the
+		  "bootm" command will be copied to the load address
+		  (and eventually uncompressed), but NOT be started.
+		  This can be used to load and uncompress arbitrary
+		  data.
+
+  i2cfast	- (PPC405GP|PPC405EP only)
+		  if set to 'y' configures Linux I2C driver for fast
+		  mode (400kHZ). This environment variable is used in
+		  initialization code. So, for changes to be effective
+		  it must be saved and board must be reset.
+
+  initrd_high	- restrict positioning of initrd images:
+		  If this variable is not set, initrd images will be
+		  copied to the highest possible address in RAM; this
+		  is usually what you want since it allows for
+		  maximum initrd size. If for some reason you want to
+		  make sure that the initrd image is loaded below the
+		  CFG_BOOTMAPSZ limit, you can set this environment
+		  variable to a value of "no" or "off" or "0".
+		  Alternatively, you can set it to a maximum upper
+		  address to use (U-Boot will still check that it
+		  does not overwrite the U-Boot stack and data).
+
+		  For instance, when you have a system with 16 MB
+		  RAM, and want to reserve 4 MB from use by Linux,
+		  you can do this by adding "mem=12M" to the value of
+		  the "bootargs" variable. However, now you must make
+		  sure that the initrd image is placed in the first
+		  12 MB as well - this can be done with
+
+		  setenv initrd_high 00c00000
+
+		  If you set initrd_high to 0xFFFFFFFF, this is an
+		  indication to U-Boot that all addresses are legal
+		  for the Linux kernel, including addresses in flash
+		  memory. In this case U-Boot will NOT COPY the
+		  ramdisk at all. This may be useful to reduce the
+		  boot time on your system, but requires that this
+		  feature is supported by your Linux kernel.
+
+  ipaddr	- IP address; needed for tftpboot command
+
+  loadaddr	- Default load address for commands like "bootp",
+		  "rarpboot", "tftpboot", "loadb" or "diskboot"
+
+  loads_echo	- see CONFIG_LOADS_ECHO
+
+  serverip	- TFTP server IP address; needed for tftpboot command
+
+  bootretry	- see CONFIG_BOOT_RETRY_TIME
+
+  bootdelaykey	- see CONFIG_AUTOBOOT_DELAY_STR
+
+  bootstopkey	- see CONFIG_AUTOBOOT_STOP_STR
+
+  ethprime	- When CONFIG_NET_MULTI is enabled controls which
+		  interface is used first.
+
+  ethact	- When CONFIG_NET_MULTI is enabled controls which
+		  interface is currently active. For example you
+		  can do the following
+
+		  => setenv ethact FEC ETHERNET
+		  => ping 192.168.0.1 # traffic sent on FEC ETHERNET
+		  => setenv ethact SCC ETHERNET
+		  => ping 10.0.0.1 # traffic sent on SCC ETHERNET
+
+   netretry	- When set to "no" each network operation will
+		  either succeed or fail without retrying.
+		  When set to "once" the network operation will
+		  fail when all the available network interfaces
+		  are tried once without success.
+		  Useful on scripts which control the retry operation
+		  themselves.
+
+  tftpsrcport	- If this is set, the value is used for TFTP's
+		  UDP source port.
+
+  tftpdstport	- If this is set, the value is used for TFTP's UDP
+		  destination port instead of the Well Know Port 69.
+
+   vlan		- When set to a value < 4095 the traffic over
+		  ethernet is encapsulated/received over 802.1q
+		  VLAN tagged frames.
+
+The following environment variables may be used and automatically
+updated by the network boot commands ("bootp" and "rarpboot"),
+depending the information provided by your boot server:
+
+  bootfile	- see above
+  dnsip		- IP address of your Domain Name Server
+  dnsip2	- IP address of your secondary Domain Name Server
+  gatewayip	- IP address of the Gateway (Router) to use
+  hostname	- Target hostname
+  ipaddr	- see above
+  netmask	- Subnet Mask
+  rootpath	- Pathname of the root filesystem on the NFS server
+  serverip	- see above
+
+
+There are two special Environment Variables:
+
+  serial#	- contains hardware identification information such
+		  as type string and/or serial number
+  ethaddr	- Ethernet address
+
+These variables can be set only once (usually during manufacturing of
+the board). U-Boot refuses to delete or overwrite these variables
+once they have been set once.
+
+
+Further special Environment Variables:
+
+  ver		- Contains the U-Boot version string as printed
+		  with the "version" command. This variable is
+		  readonly (see CONFIG_VERSION_VARIABLE).
+
+
+Please note that changes to some configuration parameters may take
+only effect after the next boot (yes, that's just like Windoze :-).
+
+
+Command Line Parsing:
+=====================
+
+There are two different command line parsers available with U-Boot:
+the old "simple" one, and the much more powerful "hush" shell:
+
+Old, simple command line parser:
+--------------------------------
+
+- supports environment variables (through setenv / saveenv commands)
+- several commands on one line, separated by ';'
+- variable substitution using "... ${name} ..." syntax
+- special characters ('$', ';') can be escaped by prefixing with '\',
+  for example:
+	setenv bootcmd bootm \${address}
+- You can also escape text by enclosing in single apostrophes, for example:
+	setenv addip 'setenv bootargs $bootargs ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname::off'
+
+Hush shell:
+-----------
+
+- similar to Bourne shell, with control structures like
+  if...then...else...fi, for...do...done; while...do...done,
+  until...do...done, ...
+- supports environment ("global") variables (through setenv / saveenv
+  commands) and local shell variables (through standard shell syntax
+  "name=value"); only environment variables can be used with "run"
+  command
+
+General rules:
+--------------
+
+(1) If a command line (or an environment variable executed by a "run"
+    command) contains several commands separated by semicolon, and
+    one of these commands fails, then the remaining commands will be
+    executed anyway.
+
+(2) If you execute several variables with one call to run (i. e.
+    calling run with a list af variables as arguments), any failing
+    command will cause "run" to terminate, i. e. the remaining
+    variables are not executed.
+
+Note for Redundant Ethernet Interfaces:
+=======================================
+
+Some boards come with redundant ethernet interfaces; U-Boot supports
+such configurations and is capable of automatic selection of a
+"working" interface when needed. MAC assignment works as follows:
+
+Network interfaces are numbered eth0, eth1, eth2, ... Corresponding
+MAC addresses can be stored in the environment as "ethaddr" (=>eth0),
+"eth1addr" (=>eth1), "eth2addr", ...
+
+If the network interface stores some valid MAC address (for instance
+in SROM), this is used as default address if there is NO correspon-
+ding setting in the environment; if the corresponding environment
+variable is set, this overrides the settings in the card; that means:
+
+o If the SROM has a valid MAC address, and there is no address in the
+  environment, the SROM's address is used.
+
+o If there is no valid address in the SROM, and a definition in the
+  environment exists, then the value from the environment variable is
+  used.
+
+o If both the SROM and the environment contain a MAC address, and
+  both addresses are the same, this MAC address is used.
+
+o If both the SROM and the environment contain a MAC address, and the
+  addresses differ, the value from the environment is used and a
+  warning is printed.
+
+o If neither SROM nor the environment contain a MAC address, an error
+  is raised.
+
+
+Image Formats:
+==============
+
+The "boot" commands of this monitor operate on "image" files which
+can be basicly anything, preceeded by a special header; see the
+definitions in include/image.h for details; basicly, the header
+defines the following image properties:
+
+* Target Operating System (Provisions for OpenBSD, NetBSD, FreeBSD,
+  4.4BSD, Linux, SVR4, Esix, Solaris, Irix, SCO, Dell, NCR, VxWorks,
+  LynxOS, pSOS, QNX, RTEMS, ARTOS;
+  Currently supported: Linux, NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS).
+* Target CPU Architecture (Provisions for Alpha, ARM, AVR32, Intel x86,
+  IA64, MIPS, NIOS, PowerPC, IBM S390, SuperH, Sparc, Sparc 64 Bit;
+  Currently supported: ARM, AVR32, Intel x86, MIPS, NIOS, PowerPC).
+* Compression Type (uncompressed, gzip, bzip2)
+* Load Address
+* Entry Point
+* Image Name
+* Image Timestamp
+
+The header is marked by a special Magic Number, and both the header
+and the data portions of the image are secured against corruption by
+CRC32 checksums.
+
+
+Linux Support:
+==============
+
+Although U-Boot should support any OS or standalone application
+easily, the main focus has always been on Linux during the design of
+U-Boot.
+
+U-Boot includes many features that so far have been part of some
+special "boot loader" code within the Linux kernel. Also, any
+"initrd" images to be used are no longer part of one big Linux image;
+instead, kernel and "initrd" are separate images. This implementation
+serves several purposes:
+
+- the same features can be used for other OS or standalone
+  applications (for instance: using compressed images to reduce the
+  Flash memory footprint)
+
+- it becomes much easier to port new Linux kernel versions because
+  lots of low-level, hardware dependent stuff are done by U-Boot
+
+- the same Linux kernel image can now be used with different "initrd"
+  images; of course this also means that different kernel images can
+  be run with the same "initrd". This makes testing easier (you don't
+  have to build a new "zImage.initrd" Linux image when you just
+  change a file in your "initrd"). Also, a field-upgrade of the
+  software is easier now.
+
+
+Linux HOWTO:
+============
+
+Porting Linux to U-Boot based systems:
+---------------------------------------
+
+U-Boot cannot save you from doing all the necessary modifications to
+configure the Linux device drivers for use with your target hardware
+(no, we don't intend to provide a full virtual machine interface to
+Linux :-).
+
+But now you can ignore ALL boot loader code (in arch/ppc/mbxboot).
+
+Just make sure your machine specific header file (for instance
+include/asm-ppc/tqm8xx.h) includes the same definition of the Board
+Information structure as we define in include/u-boot.h, and make
+sure that your definition of IMAP_ADDR uses the same value as your
+U-Boot configuration in CFG_IMMR.
+
+
+Configuring the Linux kernel:
+-----------------------------
+
+No specific requirements for U-Boot. Make sure you have some root
+device (initial ramdisk, NFS) for your target system.
+
+
+Building a Linux Image:
+-----------------------
+
+With U-Boot, "normal" build targets like "zImage" or "bzImage" are
+not used. If you use recent kernel source, a new build target
+"uImage" will exist which automatically builds an image usable by
+U-Boot. Most older kernels also have support for a "pImage" target,
+which was introduced for our predecessor project PPCBoot and uses a
+100% compatible format.
+
+Example:
+
+	make TQM850L_config
+	make oldconfig
+	make dep
+	make uImage
+
+The "uImage" build target uses a special tool (in 'tools/mkimage') to
+encapsulate a compressed Linux kernel image with header	 information,
+CRC32 checksum etc. for use with U-Boot. This is what we are doing:
+
+* build a standard "vmlinux" kernel image (in ELF binary format):
+
+* convert the kernel into a raw binary image:
+
+	${CROSS_COMPILE}-objcopy -O binary \
+				 -R .note -R .comment \
+				 -S vmlinux linux.bin
+
+* compress the binary image:
+
+	gzip -9 linux.bin
+
+* package compressed binary image for U-Boot:
+
+	mkimage -A ppc -O linux -T kernel -C gzip \
+		-a 0 -e 0 -n "Linux Kernel Image" \
+		-d linux.bin.gz uImage
+
+
+The "mkimage" tool can also be used to create ramdisk images for use
+with U-Boot, either separated from the Linux kernel image, or
+combined into one file. "mkimage" encapsulates the images with a 64
+byte header containing information about target architecture,
+operating system, image type, compression method, entry points, time
+stamp, CRC32 checksums, etc.
+
+"mkimage" can be called in two ways: to verify existing images and
+print the header information, or to build new images.
+
+In the first form (with "-l" option) mkimage lists the information
+contained in the header of an existing U-Boot image; this includes
+checksum verification:
+
+	tools/mkimage -l image
+	  -l ==> list image header information
+
+The second form (with "-d" option) is used to build a U-Boot image
+from a "data file" which is used as image payload:
+
+	tools/mkimage -A arch -O os -T type -C comp -a addr -e ep \
+		      -n name -d data_file image
+	  -A ==> set architecture to 'arch'
+	  -O ==> set operating system to 'os'
+	  -T ==> set image type to 'type'
+	  -C ==> set compression type 'comp'
+	  -a ==> set load address to 'addr' (hex)
+	  -e ==> set entry point to 'ep' (hex)
+	  -n ==> set image name to 'name'
+	  -d ==> use image data from 'datafile'
+
+Right now, all Linux kernels for PowerPC systems use the same load
+address (0x00000000), but the entry point address depends on the
+kernel version:
+
+- 2.2.x kernels have the entry point at 0x0000000C,
+- 2.3.x and later kernels have the entry point at 0x00000000.
+
+So a typical call to build a U-Boot image would read:
+
+	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
+	> -A ppc -O linux -T kernel -C gzip -a 0 -e 0 \
+	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/ppc/coffboot/vmlinux.gz \
+	> examples/uImage.TQM850L
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
+	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+To verify the contents of the image (or check for corruption):
+
+	-> tools/mkimage -l examples/uImage.TQM850L
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (gzip compressed)
+	Data Size:    335725 Bytes = 327.86 kB = 0.32 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+NOTE: for embedded systems where boot time is critical you can trade
+speed for memory and install an UNCOMPRESSED image instead: this
+needs more space in Flash, but boots much faster since it does not
+need to be uncompressed:
+
+	-> gunzip /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/ppc/coffboot/vmlinux.gz
+	-> tools/mkimage -n '2.4.4 kernel for TQM850L' \
+	> -A ppc -O linux -T kernel -C none -a 0 -e 0 \
+	> -d /opt/elsk/ppc_8xx/usr/src/linux-2.4.4/arch/ppc/coffboot/vmlinux \
+	> examples/uImage.TQM850L-uncompressed
+	Image Name:   2.4.4 kernel for TQM850L
+	Created:      Wed Jul 19 02:34:59 2000
+	Image Type:   PowerPC Linux Kernel Image (uncompressed)
+	Data Size:    792160 Bytes = 773.59 kB = 0.76 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+
+Similar you can build U-Boot images from a 'ramdisk.image.gz' file
+when your kernel is intended to use an initial ramdisk:
+
+	-> tools/mkimage -n 'Simple Ramdisk Image' \
+	> -A ppc -O linux -T ramdisk -C gzip \
+	> -d /LinuxPPC/images/SIMPLE-ramdisk.image.gz examples/simple-initrd
+	Image Name:   Simple Ramdisk Image
+	Created:      Wed Jan 12 14:01:50 2000
+	Image Type:   PowerPC Linux RAMDisk Image (gzip compressed)
+	Data Size:    566530 Bytes = 553.25 kB = 0.54 MB
+	Load Address: 0x00000000
+	Entry Point:  0x00000000
+
+
+Installing a Linux Image:
+-------------------------
+
+To downloading a U-Boot image over the serial (console) interface,
+you must convert the image to S-Record format:
+
+	objcopy -I binary -O srec examples/image examples/image.srec
+
+The 'objcopy' does not understand the information in the U-Boot
+image header, so the resulting S-Record file will be relative to
+address 0x00000000. To load it to a given address, you need to
+specify the target address as 'offset' parameter with the 'loads'
+command.
+
+Example: install the image to address 0x40100000 (which on the
+TQM8xxL is in the first Flash bank):
+
+	=> erase 40100000 401FFFFF
+
+	.......... done
+	Erased 8 sectors
+
+	=> loads 40100000
+	## Ready for S-Record download ...
+	~>examples/image.srec
+	1 2 3 4 5 6 7 8 9 10 11 12 13 ...
+	...
+	15989 15990 15991 15992
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00000000
+
+
+You can check the success of the download using the 'iminfo' command;
+this includes a checksum verification so you  can  be  sure  no	 data
+corruption happened:
+
+	=> imi 40100000
+
+	## Checking Image at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+
+
+Boot Linux:
+-----------
+
+The "bootm" command is used to boot an application that is stored in
+memory (RAM or Flash). In case of a Linux kernel image, the contents
+of the "bootargs" environment variable is passed to the kernel as
+parameters. You can check and modify this variable using the
+"printenv" and "setenv" commands:
+
+
+	=> printenv bootargs
+	bootargs=root=/dev/ram
+
+	=> setenv bootargs root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+
+	=> printenv bootargs
+	bootargs=root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+
+	=> bootm 40020000
+	## Booting Linux kernel at 40020000 ...
+	   Image Name:	 2.2.13 for NFS on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 381681 Bytes = 372 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+	   Uncompressing Kernel Image ... OK
+	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:35:17 MEST 2000
+	Boot arguments: root=/dev/nfs rw nfsroot=10.0.0.2:/LinuxPPC nfsaddrs=10.0.0.99:10.0.0.2
+	time_init: decrementer frequency = 187500000/60
+	Calibrating delay loop... 49.77 BogoMIPS
+	Memory: 15208k available (700k kernel code, 444k data, 32k init) [c0000000,c1000000]
+	...
+
+If you want to boot a Linux kernel with initial ram disk, you pass
+the memory addresses of both the kernel and the initrd image (PPBCOOT
+format!) to the "bootm" command:
+
+	=> imi 40100000 40200000
+
+	## Checking Image at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+
+	## Checking Image at 40200000 ...
+	   Image Name:	 Simple Ramdisk Image
+	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
+	   Data Size:	 566530 Bytes = 553 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 00000000
+	   Verifying Checksum ... OK
+
+	=> bootm 40100000 40200000
+	## Booting Linux kernel at 40100000 ...
+	   Image Name:	 2.2.13 for initrd on TQM850L
+	   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+	   Data Size:	 335725 Bytes = 327 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 0000000c
+	   Verifying Checksum ... OK
+	   Uncompressing Kernel Image ... OK
+	## Loading RAMDisk Image at 40200000 ...
+	   Image Name:	 Simple Ramdisk Image
+	   Image Type:	 PowerPC Linux RAMDisk Image (gzip compressed)
+	   Data Size:	 566530 Bytes = 553 kB = 0 MB
+	   Load Address: 00000000
+	   Entry Point:	 00000000
+	   Verifying Checksum ... OK
+	   Loading Ramdisk ... OK
+	Linux version 2.2.13 (wd@denx.local.net) (gcc version 2.95.2 19991024 (release)) #1 Wed Jul 19 02:32:08 MEST 2000
+	Boot arguments: root=/dev/ram
+	time_init: decrementer frequency = 187500000/60
+	Calibrating delay loop... 49.77 BogoMIPS
+	...
+	RAMDISK: Compressed image found at block 0
+	VFS: Mounted root (ext2 filesystem).
+
+	bash#
+
+Boot Linux and pass a flat device tree:
+-----------
+
+First, U-Boot must be compiled with the appropriate defines. See the section
+titled "Linux Kernel Interface" above for a more in depth explanation. The
+following is an example of how to start a kernel and pass an updated
+flat device tree:
+
+=> print oftaddr
+oftaddr=0x300000
+=> print oft
+oft=oftrees/mpc8540ads.dtb
+=> tftp $oftaddr $oft
+Speed: 1000, full duplex
+Using TSEC0 device
+TFTP from server 192.168.1.1; our IP address is 192.168.1.101
+Filename 'oftrees/mpc8540ads.dtb'.
+Load address: 0x300000
+Loading: #
+done
+Bytes transferred = 4106 (100a hex)
+=> tftp $loadaddr $bootfile
+Speed: 1000, full duplex
+Using TSEC0 device
+TFTP from server 192.168.1.1; our IP address is 192.168.1.2
+Filename 'uImage'.
+Load address: 0x200000
+Loading:############
+done
+Bytes transferred = 1029407 (fb51f hex)
+=> print loadaddr
+loadaddr=200000
+=> print oftaddr
+oftaddr=0x300000
+=> bootm $loadaddr - $oftaddr
+## Booting image at 00200000 ...
+   Image Name:	 Linux-2.6.17-dirty
+   Image Type:	 PowerPC Linux Kernel Image (gzip compressed)
+   Data Size:	 1029343 Bytes = 1005.2 kB
+   Load Address: 00000000
+   Entry Point:	 00000000
+   Verifying Checksum ... OK
+   Uncompressing Kernel Image ... OK
+Booting using flat device tree at 0x300000
+Using MPC85xx ADS machine description
+Memory CAM mapping: CAM0=256Mb, CAM1=256Mb, CAM2=0Mb residual: 0Mb
+[snip]
+
+
+More About U-Boot Image Types:
+------------------------------
+
+U-Boot supports the following image types:
+
+   "Standalone Programs" are directly runnable in the environment
+	provided by U-Boot; it is expected that (if they behave
+	well) you can continue to work in U-Boot after return from
+	the Standalone Program.
+   "OS Kernel Images" are usually images of some Embedded OS which
+	will take over control completely. Usually these programs
+	will install their own set of exception handlers, device
+	drivers, set up the MMU, etc. - this means, that you cannot
+	expect to re-enter U-Boot except by resetting the CPU.
+   "RAMDisk Images" are more or less just data blocks, and their
+	parameters (address, size) are passed to an OS kernel that is
+	being started.
+   "Multi-File Images" contain several images, typically an OS
+	(Linux) kernel image and one or more data images like
+	RAMDisks. This construct is useful for instance when you want
+	to boot over the network using BOOTP etc., where the boot
+	server provides just a single image file, but you want to get
+	for instance an OS kernel and a RAMDisk image.
+
+	"Multi-File Images" start with a list of image sizes, each
+	image size (in bytes) specified by an "uint32_t" in network
+	byte order. This list is terminated by an "(uint32_t)0".
+	Immediately after the terminating 0 follow the images, one by
+	one, all aligned on "uint32_t" boundaries (size rounded up to
+	a multiple of 4 bytes).
+
+   "Firmware Images" are binary images containing firmware (like
+	U-Boot or FPGA images) which usually will be programmed to
+	flash memory.
+
+   "Script files" are command sequences that will be executed by
+	U-Boot's command interpreter; this feature is especially
+	useful when you configure U-Boot to use a real shell (hush)
+	as command interpreter.
+
+
+Standalone HOWTO:
+=================
+
+One of the features of U-Boot is that you can dynamically load and
+run "standalone" applications, which can use some resources of
+U-Boot like console I/O functions or interrupt services.
+
+Two simple examples are included with the sources:
+
+"Hello World" Demo:
+-------------------
+
+'examples/hello_world.c' contains a small "Hello World" Demo
+application; it is automatically compiled when you build U-Boot.
+It's configured to run at address 0x00040004, so you can play with it
+like that:
+
+	=> loads
+	## Ready for S-Record download ...
+	~>examples/hello_world.srec
+	1 2 3 4 5 6 7 8 9 10 11 ...
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00040004
+
+	=> go 40004 Hello World! This is a test.
+	## Starting application at 0x00040004 ...
+	Hello World
+	argc = 7
+	argv[0] = "40004"
+	argv[1] = "Hello"
+	argv[2] = "World!"
+	argv[3] = "This"
+	argv[4] = "is"
+	argv[5] = "a"
+	argv[6] = "test."
+	argv[7] = "<NULL>"
+	Hit any key to exit ...
+
+	## Application terminated, rc = 0x0
+
+Another example, which demonstrates how to register a CPM interrupt
+handler with the U-Boot code, can be found in 'examples/timer.c'.
+Here, a CPM timer is set up to generate an interrupt every second.
+The interrupt service routine is trivial, just printing a '.'
+character, but this is just a demo program. The application can be
+controlled by the following keys:
+
+	? - print current values og the CPM Timer registers
+	b - enable interrupts and start timer
+	e - stop timer and disable interrupts
+	q - quit application
+
+	=> loads
+	## Ready for S-Record download ...
+	~>examples/timer.srec
+	1 2 3 4 5 6 7 8 9 10 11 ...
+	[file transfer complete]
+	[connected]
+	## Start Addr = 0x00040004
+
+	=> go 40004
+	## Starting application at 0x00040004 ...
+	TIMERS=0xfff00980
+	Using timer 1
+	  tgcr @ 0xfff00980, tmr @ 0xfff00990, trr @ 0xfff00994, tcr @ 0xfff00998, tcn @ 0xfff0099c, ter @ 0xfff009b0
+
+Hit 'b':
+	[q, b, e, ?] Set interval 1000000 us
+	Enabling timer
+Hit '?':
+	[q, b, e, ?] ........
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0xef6, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x2ad4, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x1efc, ter=0x0
+Hit '?':
+	[q, b, e, ?] .
+	tgcr=0x1, tmr=0xff1c, trr=0x3d09, tcr=0x0, tcn=0x169d, ter=0x0
+Hit 'e':
+	[q, b, e, ?] ...Stopping timer
+Hit 'q':
+	[q, b, e, ?] ## Application terminated, rc = 0x0
+
+
+Minicom warning:
+================
+
+Over time, many people have reported problems when trying to use the
+"minicom" terminal emulation program for serial download. I (wd)
+consider minicom to be broken, and recommend not to use it. Under
+Unix, I recommend to use C-Kermit for general purpose use (and
+especially for kermit binary protocol download ("loadb" command), and
+use "cu" for S-Record download ("loads" command).
+
+Nevertheless, if you absolutely want to use it try adding this
+configuration to your "File transfer protocols" section:
+
+	   Name	   Program			Name U/D FullScr IO-Red. Multi
+	X  kermit  /usr/bin/kermit -i -l %l -s	 Y    U	   Y	   N	  N
+	Y  kermit  /usr/bin/kermit -i -l %l -r	 N    D	   Y	   N	  N
+
+
+NetBSD Notes:
+=============
+
+Starting at version 0.9.2, U-Boot supports NetBSD both as host
+(build U-Boot) and target system (boots NetBSD/mpc8xx).
+
+Building requires a cross environment; it is known to work on
+NetBSD/i386 with the cross-powerpc-netbsd-1.3 package (you will also
+need gmake since the Makefiles are not compatible with BSD make).
+Note that the cross-powerpc package does not install include files;
+attempting to build U-Boot will fail because <machine/ansi.h> is
+missing.  This file has to be installed and patched manually:
+
+	# cd /usr/pkg/cross/powerpc-netbsd/include
+	# mkdir powerpc
+	# ln -s powerpc machine
+	# cp /usr/src/sys/arch/powerpc/include/ansi.h powerpc/ansi.h
+	# ${EDIT} powerpc/ansi.h	## must remove __va_list, _BSD_VA_LIST
+
+Native builds *don't* work due to incompatibilities between native
+and U-Boot include files.
+
+Booting assumes that (the first part of) the image booted is a
+stage-2 loader which in turn loads and then invokes the kernel
+proper. Loader sources will eventually appear in the NetBSD source
+tree (probably in sys/arc/mpc8xx/stand/u-boot_stage2/); in the
+meantime, see ftp://ftp.denx.de/pub/u-boot/ppcboot_stage2.tar.gz
+
+
+Implementation Internals:
+=========================
+
+The following is not intended to be a complete description of every
+implementation detail. However, it should help to understand the
+inner workings of U-Boot and make it easier to port it to custom
+hardware.
+
+
+Initial Stack, Global Data:
+---------------------------
+
+The implementation of U-Boot is complicated by the fact that U-Boot
+starts running out of ROM (flash memory), usually without access to
+system RAM (because the memory controller is not initialized yet).
+This means that we don't have writable Data or BSS segments, and BSS
+is not initialized as zero. To be able to get a C environment working
+at all, we have to allocate at least a minimal stack. Implementation
+options for this are defined and restricted by the CPU used: Some CPU
+models provide on-chip memory (like the IMMR area on MPC8xx and
+MPC826x processors), on others (parts of) the data cache can be
+locked as (mis-) used as memory, etc.
+
+	Chris Hallinan posted a good summary of	 these	issues	to  the
+	u-boot-users mailing list:
+
+	Subject: RE: [U-Boot-Users] RE: More On Memory Bank x (nothingness)?
+	From: "Chris Hallinan" <clh@net1plus.com>
+	Date: Mon, 10 Feb 2003 16:43:46 -0500 (22:43 MET)
+	...
+
+	Correct me if I'm wrong, folks, but the way I understand it
+	is this: Using DCACHE as initial RAM for Stack, etc, does not
+	require any physical RAM backing up the cache. The cleverness
+	is that the cache is being used as a temporary supply of
+	necessary storage before the SDRAM controller is setup. It's
+	beyond the scope of this list to expain the details, but you
+	can see how this works by studying the cache architecture and
+	operation in the architecture and processor-specific manuals.
+
+	OCM is On Chip Memory, which I believe the 405GP has 4K. It
+	is another option for the system designer to use as an
+	initial stack/ram area prior to SDRAM being available. Either
+	option should work for you. Using CS 4 should be fine if your
+	board designers haven't used it for something that would
+	cause you grief during the initial boot! It is frequently not
+	used.
+
+	CFG_INIT_RAM_ADDR should be somewhere that won't interfere
+	with your processor/board/system design. The default value
+	you will find in any recent u-boot distribution in
+	walnut.h should work for you. I'd set it to a value larger
+	than your SDRAM module. If you have a 64MB SDRAM module, set
+	it above 400_0000. Just make sure your board has no resources
+	that are supposed to respond to that address! That code in
+	start.S has been around a while and should work as is when
+	you get the config right.
+
+	-Chris Hallinan
+	DS4.COM, Inc.
+
+It is essential to remember this, since it has some impact on the C
+code for the initialization procedures:
+
+* Initialized global data (data segment) is read-only. Do not attempt
+  to write it.
+
+* Do not use any unitialized global data (or implicitely initialized
+  as zero data - BSS segment) at all - this is undefined, initiali-
+  zation is performed later (when relocating to RAM).
+
+* Stack space is very limited. Avoid big data buffers or things like
+  that.
+
+Having only the stack as writable memory limits means we cannot use
+normal global data to share information beween the code. But it
+turned out that the implementation of U-Boot can be greatly
+simplified by making a global data structure (gd_t) available to all
+functions. We could pass a pointer to this data as argument to _all_
+functions, but this would bloat the code. Instead we use a feature of
+the GCC compiler (Global Register Variables) to share the data: we
+place a pointer (gd) to the global data into a register which we
+reserve for this purpose.
+
+When choosing a register for such a purpose we are restricted by the
+relevant  (E)ABI  specifications for the current architecture, and by
+GCC's implementation.
+
+For PowerPC, the following registers have specific use:
+	R1:	stack pointer
+	R2:	TOC pointer
+	R3-R4:	parameter passing and return values
+	R5-R10: parameter passing
+	R13:	small data area pointer
+	R30:	GOT pointer
+	R31:	frame pointer
+
+	(U-Boot also uses R14 as internal GOT pointer.)
+
+    ==> U-Boot will use R29 to hold a pointer to the global data
+
+    Note: on PPC, we could use a static initializer (since the
+    address of the global data structure is known at compile time),
+    but it turned out that reserving a register results in somewhat
+    smaller code - although the code savings are not that big (on
+    average for all boards 752 bytes for the whole U-Boot image,
+    624 text + 127 data).
+
+On ARM, the following registers are used:
+
+	R0:	function argument word/integer result
+	R1-R3:	function argument word
+	R9:	GOT pointer
+	R10:	stack limit (used only if stack checking if enabled)
+	R11:	argument (frame) pointer
+	R12:	temporary workspace
+	R13:	stack pointer
+	R14:	link register
+	R15:	program counter
+
+    ==> U-Boot will use R8 to hold a pointer to the global data
+
+NOTE: DECLARE_GLOBAL_DATA_PTR must be used with file-global scope,
+or current versions of GCC may "optimize" the code too much.
+
+Memory Management:
+------------------
+
+U-Boot runs in system state and uses physical addresses, i.e. the
+MMU is not used either for address mapping nor for memory protection.
+
+The available memory is mapped to fixed addresses using the memory
+controller. In this process, a contiguous block is formed for each
+memory type (Flash, SDRAM, SRAM), even when it consists of several
+physical memory banks.
+
+U-Boot is installed in the first 128 kB of the first Flash bank (on
+TQM8xxL modules this is the range 0x40000000 ... 0x4001FFFF). After
+booting and sizing and initializing DRAM, the code relocates itself
+to the upper end of DRAM. Immediately below the U-Boot code some
+memory is reserved for use by malloc() [see CFG_MALLOC_LEN
+configuration setting]. Below that, a structure with global Board
+Info data is placed, followed by the stack (growing downward).
+
+Additionally, some exception handler code is copied to the low 8 kB
+of DRAM (0x00000000 ... 0x00001FFF).
+
+So a typical memory configuration with 16 MB of DRAM could look like
+this:
+
+	0x0000 0000	Exception Vector code
+	      :
+	0x0000 1FFF
+	0x0000 2000	Free for Application Use
+	      :
+	      :
+
+	      :
+	      :
+	0x00FB FF20	Monitor Stack (Growing downward)
+	0x00FB FFAC	Board Info Data and permanent copy of global data
+	0x00FC 0000	Malloc Arena
+	      :
+	0x00FD FFFF
+	0x00FE 0000	RAM Copy of Monitor Code
+	...		eventually: LCD or video framebuffer
+	...		eventually: pRAM (Protected RAM - unchanged by reset)
+	0x00FF FFFF	[End of RAM]
+
+
+System Initialization:
+----------------------
+
+In the reset configuration, U-Boot starts at the reset entry point
+(on most PowerPC systens at address 0x00000100). Because of the reset
+configuration for CS0# this is a mirror of the onboard Flash memory.
+To be able to re-map memory U-Boot then jumps to its link address.
+To be able to implement the initialization code in C, a (small!)
+initial stack is set up in the internal Dual Ported RAM (in case CPUs
+which provide such a feature like MPC8xx or MPC8260), or in a locked
+part of the data cache. After that, U-Boot initializes the CPU core,
+the caches and the SIU.
+
+Next, all (potentially) available memory banks are mapped using a
+preliminary mapping. For example, we put them on 512 MB boundaries
+(multiples of 0x20000000: SDRAM on 0x00000000 and 0x20000000, Flash
+on 0x40000000 and 0x60000000, SRAM on 0x80000000). Then UPM A is
+programmed for SDRAM access. Using the temporary configuration, a
+simple memory test is run that determines the size of the SDRAM
+banks.
+
+When there is more than one SDRAM bank, and the banks are of
+different size, the largest is mapped first. For equal size, the first
+bank (CS2#) is mapped first. The first mapping is always for address
+0x00000000, with any additional banks following immediately to create
+contiguous memory starting from 0.
+
+Then, the monitor installs itself at the upper end of the SDRAM area
+and allocates memory for use by malloc() and for the global Board
+Info data; also, the exception vector code is copied to the low RAM
+pages, and the final stack is set up.
+
+Only after this relocation will you have a "normal" C environment;
+until that you are restricted in several ways, mostly because you are
+running from ROM, and because the code will have to be relocated to a
+new address in RAM.
+
+
+U-Boot Porting Guide:
+----------------------
+
+[Based on messages by Jerry Van Baren in the U-Boot-Users mailing
+list, October 2002]
+
+
+int main (int argc, char *argv[])
+{
+	sighandler_t no_more_time;
+
+	signal (SIGALRM, no_more_time);
+	alarm (PROJECT_DEADLINE - toSec (3 * WEEK));
+
+	if (available_money > available_manpower) {
+		pay consultant to port U-Boot;
+		return 0;
+	}
+
+	Download latest U-Boot source;
+
+	Subscribe to u-boot-users mailing list;
+
+	if (clueless) {
+		email ("Hi, I am new to U-Boot, how do I get started?");
+	}
+
+	while (learning) {
+		Read the README file in the top level directory;
+		Read http://www.denx.de/twiki/bin/view/DULG/Manual ;
+		Read the source, Luke;
+	}
+
+	if (available_money > toLocalCurrency ($2500)) {
+		Buy a BDI2000;
+	} else {
+		Add a lot of aggravation and time;
+	}
+
+	Create your own board support subdirectory;
+
+	Create your own board config file;
+
+	while (!running) {
+		do {
+			Add / modify source code;
+		} until (compiles);
+		Debug;
+		if (clueless)
+			email ("Hi, I am having problems...");
+	}
+	Send patch file to Wolfgang;
+
+	return 0;
+}
+
+void no_more_time (int sig)
+{
+      hire_a_guru();
+}
+
+
+Coding Standards:
+-----------------
+
+All contributions to U-Boot should conform to the Linux kernel
+coding style; see the file "Documentation/CodingStyle" and the script
+"scripts/Lindent" in your Linux kernel source directory.  In sources
+originating from U-Boot a style corresponding to "Lindent -pcs" (adding
+spaces before parameters to function calls) is actually used.
+
+Source files originating from a different project (for example the
+MTD subsystem) are generally exempt from these guidelines and are not
+reformated to ease subsequent migration to newer versions of those
+sources.
+
+Please note that U-Boot is implemented in C (and to some small parts in
+Assembler); no C++ is used, so please do not use C++ style comments (//)
+in your code.
+
+Please also stick to the following formatting rules:
+- remove any trailing white space
+- use TAB characters for indentation, not spaces
+- make sure NOT to use DOS '\r\n' line feeds
+- do not add more than 2 empty lines to source files
+- do not add trailing empty lines to source files
+
+Submissions which do not conform to the standards may be returned
+with a request to reformat the changes.
+
+
+Submitting Patches:
+-------------------
+
+Since the number of patches for U-Boot is growing, we need to
+establish some rules. Submissions which do not conform to these rules
+may be rejected, even when they contain important and valuable stuff.
+
+Patches shall be sent to the u-boot-users mailing list.
+
+When you send a patch, please include the following information with
+it:
+
+* For bug fixes: a description of the bug and how your patch fixes
+  this bug. Please try to include a way of demonstrating that the
+  patch actually fixes something.
+
+* For new features: a description of the feature and your
+  implementation.
+
+* A CHANGELOG entry as plaintext (separate from the patch)
+
+* For major contributions, your entry to the CREDITS file
+
+* When you add support for a new board, don't forget to add this
+  board to the MAKEALL script, too.
+
+* If your patch adds new configuration options, don't forget to
+  document these in the README file.
+
+* The patch itself. If you are accessing the CVS repository use "cvs
+  update; cvs diff -puRN"; else, use "diff -purN OLD NEW". If your
+  version of diff does not support these options, then get the latest
+  version of GNU diff.
+
+  The current directory when running this command shall be the top
+  level directory of the U-Boot source tree, or it's parent directory
+  (i. e. please make sure that your patch includes sufficient
+  directory information for the affected files).
+
+  We accept patches as plain text, MIME attachments or as uuencoded
+  gzipped text.
+
+* If one logical set of modifications affects or creates several
+  files, all these changes shall be submitted in a SINGLE patch file.
+
+* Changesets that contain different, unrelated modifications shall be
+  submitted as SEPARATE patches, one patch per changeset.
+
+
+Notes:
+
+* Before sending the patch, run the MAKEALL script on your patched
+  source tree and make sure that no errors or warnings are reported
+  for any of the boards.
+
+* Keep your modifications to the necessary minimum: A patch
+  containing several unrelated changes or arbitrary reformats will be
+  returned with a request to re-formatting / split it.
+
+* If you modify existing code, make sure that your new code does not
+  add to the memory footprint of the code ;-) Small is beautiful!
+  When adding new features, these should compile conditionally only
+  (using #ifdef), and the resulting code with the new feature
+  disabled must not need more memory than the old code without your
+  modification.
+
+* Remember that there is a size limit of 40 kB per message on the
+  u-boot-users mailing list. Compression may help.
diff -Nur u-boot-1.3.1/tools/mkimage.c u-boot-1.3.1-patched/tools/mkimage.c
--- u-boot-1.3.1/tools/mkimage.c	2011-07-02 21:08:15.588078903 +0200
+++ u-boot-1.3.1-patched/tools/mkimage.c	2011-07-02 21:07:58.136086370 +0200
@@ -140,6 +140,7 @@
     {	IH_COMP_NONE,	"none",		"uncompressed",		},
     {	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
     {	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+    {	IH_COMP_LZMA,	"lzma",		"lzma compressed",	},
     {	-1,		"",		"",			},
 };
 
